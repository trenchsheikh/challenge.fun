"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@toruslabs";
exports.ids = ["vendor-chunks/@toruslabs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACCOUNT_CATEGORY: () => (/* binding */ ACCOUNT_CATEGORY),\n/* harmony export */   ACTIVITY_ACTION: () => (/* binding */ ACTIVITY_ACTION),\n/* harmony export */   ACTIVITY_ACTION_ACCEPT_NFT_OFFER: () => (/* binding */ ACTIVITY_ACTION_ACCEPT_NFT_OFFER),\n/* harmony export */   ACTIVITY_ACTION_ALL: () => (/* binding */ ACTIVITY_ACTION_ALL),\n/* harmony export */   ACTIVITY_ACTION_BURN: () => (/* binding */ ACTIVITY_ACTION_BURN),\n/* harmony export */   ACTIVITY_ACTION_CANCEL_NFT_OFFER: () => (/* binding */ ACTIVITY_ACTION_CANCEL_NFT_OFFER),\n/* harmony export */   ACTIVITY_ACTION_CREATE_NFT_OFFER: () => (/* binding */ ACTIVITY_ACTION_CREATE_NFT_OFFER),\n/* harmony export */   ACTIVITY_ACTION_CREATE_TRUSTLINE: () => (/* binding */ ACTIVITY_ACTION_CREATE_TRUSTLINE),\n/* harmony export */   ACTIVITY_ACTION_RECEIVE: () => (/* binding */ ACTIVITY_ACTION_RECEIVE),\n/* harmony export */   ACTIVITY_ACTION_REMOVE_TRUSTLINE: () => (/* binding */ ACTIVITY_ACTION_REMOVE_TRUSTLINE),\n/* harmony export */   ACTIVITY_ACTION_SEND: () => (/* binding */ ACTIVITY_ACTION_SEND),\n/* harmony export */   ACTIVITY_ACTION_TOPUP: () => (/* binding */ ACTIVITY_ACTION_TOPUP),\n/* harmony export */   ACTIVITY_PERIOD_ALL: () => (/* binding */ ACTIVITY_PERIOD_ALL),\n/* harmony export */   ACTIVITY_PERIOD_MONTH_ONE: () => (/* binding */ ACTIVITY_PERIOD_MONTH_ONE),\n/* harmony export */   ACTIVITY_PERIOD_MONTH_SIX: () => (/* binding */ ACTIVITY_PERIOD_MONTH_SIX),\n/* harmony export */   ACTIVITY_PERIOD_WEEK_ONE: () => (/* binding */ ACTIVITY_PERIOD_WEEK_ONE),\n/* harmony export */   ACTIVITY_STATUS_CANCELLED: () => (/* binding */ ACTIVITY_STATUS_CANCELLED),\n/* harmony export */   ACTIVITY_STATUS_CANCELLING: () => (/* binding */ ACTIVITY_STATUS_CANCELLING),\n/* harmony export */   ACTIVITY_STATUS_PENDING: () => (/* binding */ ACTIVITY_STATUS_PENDING),\n/* harmony export */   ACTIVITY_STATUS_SUCCESSFUL: () => (/* binding */ ACTIVITY_STATUS_SUCCESSFUL),\n/* harmony export */   ACTIVITY_STATUS_UNSUCCESSFUL: () => (/* binding */ ACTIVITY_STATUS_UNSUCCESSFUL),\n/* harmony export */   BROADCAST_CHANNELS: () => (/* binding */ BROADCAST_CHANNELS),\n/* harmony export */   BROADCAST_CHANNELS_MSGS: () => (/* binding */ BROADCAST_CHANNELS_MSGS),\n/* harmony export */   BUTTON_POSITION: () => (/* binding */ BUTTON_POSITION),\n/* harmony export */   BaseBlockTracker: () => (/* binding */ BaseBlockTracker),\n/* harmony export */   BaseController: () => (/* binding */ BaseController),\n/* harmony export */   BaseCurrencyController: () => (/* binding */ BaseCurrencyController),\n/* harmony export */   BaseEmbedController: () => (/* binding */ BaseEmbedController),\n/* harmony export */   BaseKeyringController: () => (/* binding */ BaseKeyringController),\n/* harmony export */   BasePreferencesController: () => (/* binding */ BasePreferencesController),\n/* harmony export */   BaseTransactionStateManager: () => (/* binding */ BaseTransactionStateManager),\n/* harmony export */   BroadcastChannelHandler: () => (/* binding */ BroadcastChannelHandler),\n/* harmony export */   CHAIN_NAMESPACES: () => (/* binding */ CHAIN_NAMESPACES),\n/* harmony export */   COMMUNICATION_JRPC_METHODS: () => (/* binding */ COMMUNICATION_JRPC_METHODS),\n/* harmony export */   COMMUNICATION_NOTIFICATIONS: () => (/* binding */ COMMUNICATION_NOTIFICATIONS),\n/* harmony export */   CONFIRMATION_STRATEGY: () => (/* binding */ CONFIRMATION_STRATEGY),\n/* harmony export */   CommunicationWindowManager: () => (/* binding */ CommunicationWindowManager),\n/* harmony export */   ControllerEvents: () => (/* binding */ ControllerEvents),\n/* harmony export */   DEFAULT_PREFERENCES: () => (/* binding */ DEFAULT_PREFERENCES),\n/* harmony export */   FEATURES_CONFIRM_WINDOW: () => (/* binding */ FEATURES_CONFIRM_WINDOW),\n/* harmony export */   FEATURES_DEFAULT_POPUP_WINDOW: () => (/* binding */ FEATURES_DEFAULT_POPUP_WINDOW),\n/* harmony export */   FEATURES_DEFAULT_WALLET_WINDOW: () => (/* binding */ FEATURES_DEFAULT_WALLET_WINDOW),\n/* harmony export */   FEATURES_PROVIDER_CHANGE_WINDOW: () => (/* binding */ FEATURES_PROVIDER_CHANGE_WINDOW),\n/* harmony export */   LOGIN_PROVIDER: () => (/* binding */ LOGIN_PROVIDER),\n/* harmony export */   PAYMENT_PROVIDER: () => (/* binding */ PAYMENT_PROVIDER),\n/* harmony export */   POPUP_LOADED: () => (/* binding */ POPUP_LOADED),\n/* harmony export */   POPUP_RESULT: () => (/* binding */ POPUP_RESULT),\n/* harmony export */   PROVIDER_JRPC_METHODS: () => (/* binding */ PROVIDER_JRPC_METHODS),\n/* harmony export */   PROVIDER_NOTIFICATIONS: () => (/* binding */ PROVIDER_NOTIFICATIONS),\n/* harmony export */   PopupHandler: () => (/* binding */ PopupHandler),\n/* harmony export */   PopupStoreChannel: () => (/* binding */ PopupStoreChannel),\n/* harmony export */   PopupWithBcHandler: () => (/* binding */ PopupWithBcHandler),\n/* harmony export */   RedirectHandler: () => (/* binding */ RedirectHandler),\n/* harmony export */   SETUP_COMPLETE: () => (/* binding */ SETUP_COMPLETE),\n/* harmony export */   StreamWindow: () => (/* binding */ StreamWindow),\n/* harmony export */   TRANSACTION_TYPES: () => (/* binding */ TRANSACTION_TYPES),\n/* harmony export */   TX_EVENTS: () => (/* binding */ TX_EVENTS),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   UserError: () => (/* binding */ UserError),\n/* harmony export */   WSApiClient: () => (/* binding */ WSApiClient),\n/* harmony export */   addressSlicer: () => (/* binding */ addressSlicer),\n/* harmony export */   authServer: () => (/* binding */ authServer),\n/* harmony export */   broadcastChannelOptions: () => (/* binding */ broadcastChannelOptions),\n/* harmony export */   cloneDeep: () => (/* binding */ cloneDeep),\n/* harmony export */   concatSig: () => (/* binding */ concatSig),\n/* harmony export */   createChangeProviderMiddlewareMiddleware: () => (/* binding */ createChangeProviderMiddlewareMiddleware),\n/* harmony export */   createCommunicationMiddleware: () => (/* binding */ createCommunicationMiddleware),\n/* harmony export */   createEventEmitterProxy: () => (/* binding */ createEventEmitterProxy),\n/* harmony export */   createFetchConfigFromReq: () => (/* binding */ createFetchConfigFromReq),\n/* harmony export */   createFetchMiddleware: () => (/* binding */ createFetchMiddleware),\n/* harmony export */   createGenericJRPCMiddleware: () => (/* binding */ createGenericJRPCMiddleware),\n/* harmony export */   createInflightCacheMiddleware: () => (/* binding */ createInflightCacheMiddleware),\n/* harmony export */   createLoggerMiddleware: () => (/* binding */ createLoggerMiddleware),\n/* harmony export */   createOriginMiddleware: () => (/* binding */ createOriginMiddleware),\n/* harmony export */   createRandomId: () => (/* binding */ createRandomId),\n/* harmony export */   createSwappableProxy: () => (/* binding */ createSwappableProxy),\n/* harmony export */   createTopupMiddleware: () => (/* binding */ createTopupMiddleware),\n/* harmony export */   formatDate: () => (/* binding */ formatDate),\n/* harmony export */   formatSmallNumbers: () => (/* binding */ formatSmallNumbers),\n/* harmony export */   formatTime: () => (/* binding */ formatTime),\n/* harmony export */   getCustomDeviceInfo: () => (/* binding */ getCustomDeviceInfo),\n/* harmony export */   getHeaders: () => (/* binding */ getHeaders),\n/* harmony export */   getPopupFeatures: () => (/* binding */ getPopupFeatures),\n/* harmony export */   getTxStatusText: () => (/* binding */ getTxStatusText),\n/* harmony export */   handleRedirectParameters: () => (/* binding */ handleRedirectParameters),\n/* harmony export */   hashMessage: () => (/* binding */ hashMessage),\n/* harmony export */   intToHex: () => (/* binding */ intToHex),\n/* harmony export */   isUnauthorizedError: () => (/* binding */ isUnauthorizedError),\n/* harmony export */   omitBy: () => (/* binding */ omitBy),\n/* harmony export */   padWithZeroes: () => (/* binding */ padWithZeroes),\n/* harmony export */   pickBy: () => (/* binding */ pickBy),\n/* harmony export */   randomId: () => (/* binding */ randomId),\n/* harmony export */   signChallenge: () => (/* binding */ signChallenge),\n/* harmony export */   signMessage: () => (/* binding */ signMessage),\n/* harmony export */   significantDigits: () => (/* binding */ significantDigits),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   timeout: () => (/* binding */ timeout$1),\n/* harmony export */   transactionMatchesNetwork: () => (/* binding */ transactionMatchesNetwork),\n/* harmony export */   verifySignedChallenge: () => (/* binding */ verifySignedChallenge)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/openlogin-jrpc */ \"(ssr)/./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\");\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/./node_modules/@ethereumjs/util/dist/esm/index.js\");\n/* harmony import */ var _toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @toruslabs/openlogin-utils */ \"(ssr)/./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! bignumber.js */ \"(ssr)/./node_modules/bignumber.js/bignumber.mjs\");\n/* harmony import */ var _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @toruslabs/broadcast-channel */ \"(ssr)/./node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! bowser */ \"(ssr)/./node_modules/bowser/src/bowser.js\");\n/* harmony import */ var jwt_decode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! jwt-decode */ \"(ssr)/./node_modules/jwt-decode/build/esm/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Controller class that provides configuration, state management, and subscriptions\n */ class BaseController extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.SafeEventEmitter {\n    /**\n   * Creates a BaseController instance. Both initial state and initial\n   * configuration options are merged with defaults upon initialization.\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */ constructor({ config = {}, state = {} }){\n        super();\n        // Use assign since generics can't be spread: https://git.io/vpRhY\n        /**\n     * Default options used to configure this controller\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"defaultConfig\", {});\n        /**\n     * Default state set on this controller\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"defaultState\", {});\n        /**\n     * Determines if listeners are notified of state changes\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"disabled\", false);\n        /**\n     * Name of this controller used during composition\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"name\", \"BaseController\");\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"initialConfig\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"initialState\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"internalConfig\", this.defaultConfig);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"internalState\", this.defaultState);\n        this.initialState = state;\n        this.initialConfig = config;\n    }\n    /**\n   * Retrieves current controller configuration options\n   *\n   * @returns - Current configuration\n   */ get config() {\n        return this.internalConfig;\n    }\n    /**\n   * Retrieves current controller state\n   *\n   * @returns - Current state\n   */ get state() {\n        return this.internalState;\n    }\n    /**\n   * Updates controller configuration\n   *\n   * @param config - New configuration options\n   * @param overwrite - Overwrite config instead of merging\n   * @param fullUpdate - Boolean that defines if the update is partial or not\n   */ configure(config, overwrite = false, fullUpdate = true) {\n        if (fullUpdate) {\n            this.internalConfig = overwrite ? config : Object.assign(this.internalConfig, config);\n            for(const key in this.internalConfig){\n                if (typeof this.internalConfig[key] !== \"undefined\") {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    this[key] = this.internalConfig[key];\n                }\n            }\n        } else {\n            for(const key in config){\n                /* istanbul ignore else */ if (typeof this.internalConfig[key] !== \"undefined\") {\n                    this.internalConfig[key] = config[key];\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    this[key] = config[key];\n                }\n            }\n        }\n    }\n    /**\n   * Updates controller state\n   *\n   * @param state - New state\n   * @param overwrite - Overwrite state instead of merging\n   */ update(state, overwrite = false) {\n        this.internalState = overwrite ? _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, state) : _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.internalState), state);\n        this.emit(\"store\", this.internalState);\n    }\n    /**\n   * Enables the controller. This sets each config option as a member\n   * variable on this instance and triggers any defined setters. This\n   * also sets initial state and triggers any listeners.\n   *\n   * @returns - This controller instance\n   */ initialize() {\n        this.internalState = this.defaultState;\n        this.internalConfig = this.defaultConfig;\n        this.configure(this.initialConfig);\n        this.update(this.initialState);\n        return this;\n    }\n}\nconst sec = 1000;\nconst calculateSum = (accumulator, currentValue)=>accumulator + currentValue;\nconst blockTrackerEvents = [\n    \"sync\",\n    \"latest\"\n];\nclass BaseBlockTracker extends BaseController {\n    constructor({ config = {}, state = {} }){\n        super({\n            config,\n            state\n        });\n        // config\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"name\", \"BaseBlockTracker\");\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"_blockResetTimeout\", void 0);\n        this.defaultState = {\n            _currentBlock: {\n                idempotencyKey: \"\"\n            },\n            _isRunning: false\n        };\n        this.defaultConfig = {\n            blockResetDuration: 20 * sec\n        };\n        this.initialize();\n        // bind functions for internal use\n        this._onNewListener = this._onNewListener.bind(this);\n        this._onRemoveListener = this._onRemoveListener.bind(this);\n        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);\n        // listen for handler changes\n        this._setupInternalEvents();\n    }\n    isRunning() {\n        return this.state._isRunning;\n    }\n    getCurrentBlock() {\n        return this.state._currentBlock;\n    }\n    async getLatestBlock() {\n        // return if available\n        if (this.state._currentBlock.idempotencyKey) {\n            return this.state._currentBlock;\n        }\n        // wait for a new latest block\n        const latestBlock = await new Promise((resolve)=>{\n            this.once(\"latest\", (block)=>{\n                if (block) {\n                    resolve(block);\n                }\n            });\n        });\n        // return newly set current block\n        return latestBlock;\n    }\n    // dont allow module consumer to remove our internal event listeners\n    removeAllListeners(eventName) {\n        if (eventName) {\n            super.removeAllListeners(eventName);\n        } else {\n            super.removeAllListeners();\n        }\n        // re-add internal events\n        this._setupInternalEvents();\n        // trigger stop check just in case\n        this._onRemoveListener();\n        return this;\n    }\n    /**\n   * To be implemented in subclass.\n   */ _start() {\n    // default behavior is noop\n    }\n    /**\n   * To be implemented in subclass.\n   */ _end() {\n    // default behavior is noop\n    }\n    _newPotentialLatest(newBlock) {\n        const currentBlock = this.state._currentBlock;\n        // only update if block number is higher\n        if (currentBlock && newBlock.idempotencyKey === currentBlock.idempotencyKey) {\n            return;\n        }\n        this._setCurrentBlock(newBlock);\n    }\n    _setupInternalEvents() {\n        // first remove listeners for idempotency\n        this.removeListener(\"newListener\", this._onNewListener);\n        this.removeListener(\"removeListener\", this._onRemoveListener);\n        // then add them\n        this.on(\"removeListener\", this._onRemoveListener);\n        this.on(\"newListener\", this._onNewListener);\n    }\n    _onNewListener() {\n        this._maybeStart();\n    }\n    _onRemoveListener() {\n        // `removeListener` is called *after* the listener is removed\n        if (this._getBlockTrackerEventCount() > 0) {\n            return;\n        }\n        this._maybeEnd();\n    }\n    _maybeStart() {\n        if (this.state._isRunning) {\n            return;\n        }\n        this.state._isRunning = true;\n        // cancel setting latest block to stale\n        this._cancelBlockResetTimeout();\n        this._start();\n    }\n    _maybeEnd() {\n        if (!this.state._isRunning) {\n            return;\n        }\n        this.state._isRunning = false;\n        this._setupBlockResetTimeout();\n        this._end();\n    }\n    _getBlockTrackerEventCount() {\n        return blockTrackerEvents.map((eventName)=>this.listenerCount(eventName)).reduce(calculateSum);\n    }\n    _setCurrentBlock(newBlock) {\n        const oldBlock = this.state._currentBlock;\n        this.update({\n            _currentBlock: newBlock\n        });\n        this.emit(\"latest\", newBlock);\n        this.emit(\"sync\", {\n            oldBlock,\n            newBlock\n        });\n    }\n    _setupBlockResetTimeout() {\n        // clear any existing timeout\n        this._cancelBlockResetTimeout();\n        // clear latest block when stale\n        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this.config.blockResetDuration);\n        // nodejs - dont hold process open\n        if (this._blockResetTimeout.unref) {\n            this._blockResetTimeout.unref();\n        }\n    }\n    _cancelBlockResetTimeout() {\n        if (this._blockResetTimeout) {\n            clearTimeout(this._blockResetTimeout);\n        }\n    }\n    _resetCurrentBlock() {\n        this.update({\n            _currentBlock: {\n                idempotencyKey: \"\"\n            }\n        });\n    }\n}\nconst filterNoop = ()=>true;\nconst internalEvents = [\n    \"newListener\",\n    \"removeListener\"\n];\nconst externalEventFilter = (name)=>!internalEvents.includes(name);\nfunction getRawListeners(eventEmitter, name) {\n    // prefer native\n    return typeof eventEmitter.rawListeners !== \"undefined\" ? eventEmitter.rawListeners(name) : eventEmitter.listeners(name);\n}\nfunction createEventEmitterProxy(initialTarget, opts) {\n    // parse options\n    const finalOpts = opts || {};\n    let eventFilter = finalOpts.eventFilter || filterNoop;\n    if (typeof eventFilter === \"string\" && eventFilter === \"skipInternal\") eventFilter = externalEventFilter;\n    if (typeof eventFilter !== \"function\") throw new Error(\"createEventEmitterProxy - Invalid eventFilter\");\n    let target = initialTarget;\n    let setTarget = (newTarget)=>{\n        const oldTarget = target;\n        target = newTarget;\n        oldTarget.eventNames().filter(eventFilter).forEach((name)=>{\n            getRawListeners(oldTarget, name).forEach((handler)=>{\n                newTarget.on(name, handler);\n            });\n        });\n        // remove old listeners\n        oldTarget.removeAllListeners();\n    };\n    const proxy = new Proxy({}, {\n        get: (_, name)=>{\n            // override `setTarget` access\n            if (name === \"setTarget\") return setTarget;\n            return target[name];\n        },\n        set: (_, name, value)=>{\n            // allow `setTarget` overrides\n            if (name === \"setTarget\") {\n                setTarget = value;\n                return true;\n            }\n            target[name] = value;\n            return true;\n        }\n    });\n    return proxy;\n}\nfunction createSwappableProxy(initialTarget) {\n    let target = initialTarget;\n    let setTarget = (newTarget)=>{\n        target = newTarget;\n    };\n    const proxy = new Proxy({}, {\n        get: (_, name)=>{\n            // override `setTarget` access\n            if (name === \"setTarget\") return setTarget;\n            return target[name];\n        },\n        set: (_, name, value)=>{\n            // allow `setTarget` overrides\n            if (name === \"setTarget\") {\n                setTarget = value;\n                return true;\n            }\n            target[name] = value;\n            return true;\n        }\n    });\n    return proxy;\n}\n// every ten minutes\nconst POLLING_INTERVAL = 600000;\nclass BaseCurrencyController extends BaseController {\n    constructor({ config = {}, state }){\n        super({\n            config,\n            state\n        });\n        this.defaultState = {\n            currentCurrency: \"usd\",\n            conversionRate: 0,\n            conversionDate: \"N/A\",\n            nativeCurrency: \"ETH\"\n        };\n        this.defaultConfig = {\n            pollInterval: POLLING_INTERVAL\n        };\n        this.initialize();\n    }\n    //\n    // PUBLIC METHODS\n    //\n    getNativeCurrency() {\n        return this.state.nativeCurrency;\n    }\n    setNativeCurrency(nativeCurrency) {\n        this.update({\n            nativeCurrency,\n            ticker: nativeCurrency\n        });\n    }\n    getCurrentCurrency() {\n        return this.state.currentCurrency;\n    }\n    setCurrentCurrency(currentCurrency) {\n        this.update({\n            currentCurrency\n        });\n    }\n    /**\n   * A getter for the conversionRate property\n   *\n   * @returns The conversion rate from ETH to the selected currency.\n   *\n   */ getConversionRate() {\n        return this.state.conversionRate;\n    }\n    setConversionRate(conversionRate) {\n        this.update({\n            conversionRate\n        });\n    }\n    /**\n   * A getter for the conversionDate property\n   *\n   * @returns The date at which the conversion rate was set. Expressed in milliseconds since midnight of\n   * January 1, 1970\n   *\n   */ getConversionDate() {\n        return this.state.conversionDate;\n    }\n    setConversionDate(conversionDate) {\n        this.update({\n            conversionDate\n        });\n    }\n}\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\n    height: 660,\n    width: 375\n};\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\n    height: 740,\n    width: 1315\n};\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\n    height: 700,\n    width: 1200\n};\nconst FEATURES_CONFIRM_WINDOW = {\n    height: 700,\n    width: 450\n};\nconst POPUP_LOADED = \"popup_loaded\";\nconst POPUP_RESULT = \"popup_result\";\nconst SETUP_COMPLETE = \"setup_complete\";\nconst ACTIVITY_ACTION_ALL = \"walletActivity.allTransactions\";\nconst ACTIVITY_ACTION_SEND = \"walletActivity.send\";\nconst ACTIVITY_ACTION_BURN = \"walletActivity.burn\";\nconst ACTIVITY_ACTION_RECEIVE = \"walletActivity.receive\";\nconst ACTIVITY_ACTION_TOPUP = \"walletActivity.topup\";\nconst ACTIVITY_ACTION_CREATE_TRUSTLINE = \"walletActivity.createTrustline\";\nconst ACTIVITY_ACTION_REMOVE_TRUSTLINE = \"walletActivity.removeTrustline\";\nconst ACTIVITY_ACTION_CREATE_NFT_OFFER = \"walletActivity.createNftOffer\";\nconst ACTIVITY_ACTION_ACCEPT_NFT_OFFER = \"walletActivity.acceptNftOffer\";\nconst ACTIVITY_ACTION_CANCEL_NFT_OFFER = \"walletActivity.cancelNftOffer\";\nconst ACTIVITY_PERIOD_ALL = \"walletActivity.all\";\nconst ACTIVITY_PERIOD_WEEK_ONE = \"walletActivity.lastOneWeek\";\nconst ACTIVITY_PERIOD_MONTH_ONE = \"walletActivity.lastOneMonth\";\nconst ACTIVITY_PERIOD_MONTH_SIX = \"walletActivity.lastSixMonts\";\nconst ACTIVITY_STATUS_SUCCESSFUL = \"walletActivity.successful\";\nconst ACTIVITY_STATUS_UNSUCCESSFUL = \"walletActivity.unsuccessful\";\nconst ACTIVITY_STATUS_PENDING = \"walletActivity.pending\";\nconst ACTIVITY_STATUS_CANCELLED = \"walletActivity.cancelled\";\nconst ACTIVITY_STATUS_CANCELLING = \"walletActivity.cancelling\";\nconst COMMUNICATION_NOTIFICATIONS = {\n    IFRAME_STATUS: \"iframe_status\",\n    // Tell embed to close the window\n    CLOSE_WINDOW: \"close_window\",\n    USER_LOGGED_IN: \"user_logged_in\",\n    USER_LOGGED_OUT: \"user_logged_out\"\n};\nconst COMMUNICATION_JRPC_METHODS = {\n    LOGOUT: \"logout\",\n    WALLET_INSTANCE_ID: \"wallet_instance_id\",\n    USER_INFO: \"user_info\",\n    SET_PROVIDER: \"set_provider\",\n    TOPUP: \"topup\",\n    IFRAME_STATUS: \"iframe_status\",\n    // user has closed the window from embed's side\n    CLOSED_WINDOW: \"closed_window\",\n    WINDOW_BLOCKED: \"window_blocked\",\n    GET_PROVIDER_STATE: \"get_provider_state\",\n    LOGIN_WITH_PRIVATE_KEY: \"login_with_private_key\",\n    SHOW_WALLET_CONNECT: \"show_wallet_connect\",\n    SHOW_CHECKOUT: \"show_checkout\",\n    SHOW_WALLET_UI: \"show_wallet_ui\",\n    LOGIN_WITH_SESSION_ID: \"login_with_session_id\"\n};\nconst PROVIDER_JRPC_METHODS = {\n    GET_PROVIDER_STATE: \"wallet_get_provider_state\"\n};\nconst PROVIDER_NOTIFICATIONS = {\n    ACCOUNTS_CHANGED: \"wallet_accounts_changed\",\n    CHAIN_CHANGED: \"wallet_chain_changed\",\n    UNLOCK_STATE_CHANGED: \"wallet_unlock_state_changed\"\n};\nconst BROADCAST_CHANNELS = {\n    REDIRECT_CHANNEL: \"redirect_channel\",\n    PROVIDER_CHANGE_CHANNEL: \"torus_provider_change_channel\",\n    TRANSACTION_CHANNEL: \"torus_channel\",\n    MESSAGE_CHANNEL: \"torus_message_channel\",\n    WALLET_LOGOUT_CHANNEL: \"wallet_logout_channel\",\n    WALLET_SELECTED_ADDRESS_CHANNEL: \"wallet_selected_address_channel\",\n    WALLET_NETWORK_CHANGE_CHANNEL: \"wallet_network_change_channel\",\n    WALLET_ACCOUNT_IMPORT_CHANNEL: \"wallet_account_import_channel\",\n    THEME_CHANGE: \"theme_change_channel\",\n    TOP_UP_CHANNEL: \"top_up_channel\"\n};\nconst BROADCAST_CHANNELS_MSGS = {\n    LOGOUT: \"logout\",\n    ACCOUNT_IMPORTED: \"account_imported\",\n    SELECTED_ADDRESS_CHANGE: \"selected_address_change\",\n    NETWORK_CHANGE: \"network_change\",\n    SET_THEME: \"set_theme\"\n};\nlet ControllerEvents = /*#__PURE__*/ function(ControllerEvents) {\n    ControllerEvents[\"UserUnauthorized\"] = \"user.unauthorized\";\n    return ControllerEvents;\n}({});\nfunction createChangeProviderMiddlewareMiddleware({ changeProvider }) {\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (request, response, next)=>{\n        const { method } = request;\n        if (method !== COMMUNICATION_JRPC_METHODS.SET_PROVIDER) return next();\n        if (!changeProvider) throw new Error(\"CommunicationMiddleware - opts.changeProvider not provided\");\n        response.result = await changeProvider(request);\n    });\n}\nfunction createTopupMiddleware({ topup }) {\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (request, response, next)=>{\n        const { method } = request;\n        if (method !== COMMUNICATION_JRPC_METHODS.TOPUP) return next();\n        if (!topup) throw new Error(\"CommunicationMiddleware - opts.topup not provided\");\n        response.result = await topup(request);\n    });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (request, response, next)=>{\n        const { method } = request;\n        if (method !== targetMethod) return next();\n        if (!handler) throw new Error(`CommunicationMiddleware - ${targetMethod} not provided`);\n        const result = await handler(request);\n        if (!result) {\n            return next();\n        }\n        response.result = result;\n        return undefined;\n    });\n}\nfunction createCommunicationMiddleware(providerHandlers) {\n    const { getUserInfo, getWalletInstanceId, topup, logout, changeProvider, setIFrameStatus, handleWindowRpc, getProviderState, loginWithPrivateKey, showWalletConnect, showCheckout, showWalletUi, showWindowBlockAlert, loginWithSessionId } = providerHandlers;\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.mergeMiddleware)([\n        createChangeProviderMiddlewareMiddleware({\n            changeProvider\n        }),\n        createTopupMiddleware({\n            topup\n        }),\n        (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createScaffoldMiddleware)({\n            [COMMUNICATION_JRPC_METHODS.LOGOUT]: logout,\n            [COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID]: getWalletInstanceId,\n            [COMMUNICATION_JRPC_METHODS.USER_INFO]: getUserInfo,\n            [COMMUNICATION_JRPC_METHODS.IFRAME_STATUS]: setIFrameStatus,\n            // Do this in the orchestrator because communicationWindowManager needs to be passed into PopupHandlers\n            [COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW]: handleWindowRpc,\n            [COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE]: getProviderState,\n            [COMMUNICATION_JRPC_METHODS.SHOW_WALLET_CONNECT]: showWalletConnect,\n            [COMMUNICATION_JRPC_METHODS.SHOW_CHECKOUT]: showCheckout,\n            [COMMUNICATION_JRPC_METHODS.SHOW_WALLET_UI]: showWalletUi,\n            [COMMUNICATION_JRPC_METHODS.WINDOW_BLOCKED]: showWindowBlockAlert\n        }),\n        createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_PRIVATE_KEY, loginWithPrivateKey),\n        createGenericJRPCMiddleware(COMMUNICATION_JRPC_METHODS.LOGIN_WITH_SESSION_ID, loginWithSessionId)\n    ]);\n}\nclass BaseEmbedController extends BaseController {\n    constructor({ config = {}, state }){\n        super({\n            config,\n            state\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"_communicationProviderProxy\", void 0);\n        this.defaultState = {\n            isIFrameFullScreen: true,\n            oauthModalVisibility: false,\n            loginInProgress: false,\n            dappMetadata: {\n                name: \"\",\n                icon: \"\"\n            },\n            web3AuthClientId: \"\",\n            web3AuthNetwork: \"mainnet\",\n            whiteLabel: null,\n            confirmationStrategy: \"popup\"\n        };\n        this.initialize();\n    }\n    /**\n   * Called by orchestrator once while initializing the class\n   * @param handlers - JRPC handlers for provider\n   * @returns - provider - Returns the providerProxy\n   */ initializeProvider(handlers) {\n        const engine = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.JRPCEngine();\n        const communicationMiddleware = createCommunicationMiddleware(handlers);\n        engine.push(communicationMiddleware);\n        const communicationProvider = (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.providerFromEngine)(engine);\n        this.setCommunicationProvider(communicationProvider);\n    }\n    setCommunicationProvider(communicationProvider) {\n        if (this._communicationProviderProxy) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            this._communicationProviderProxy.setTarget(communicationProvider);\n        } else {\n            this._communicationProviderProxy = createSwappableProxy(communicationProvider);\n        }\n    }\n}\nclass CommunicationWindowManager extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.SafeEventEmitter {\n    constructor(...args){\n        super(...args);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleWindowRpc\", (request, response, next, end)=>{\n            const { method, params } = request;\n            if (method === COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW) {\n                const { windowId } = params;\n                // I've been informed that a window has been closed\n                this.emit(`${windowId}:closed`);\n                response.result = true;\n                end();\n            } else {\n                next();\n            }\n        });\n    }\n}\nconst BUTTON_POSITION = {\n    BOTTOM_LEFT: \"bottom-left\",\n    TOP_LEFT: \"top-left\",\n    BOTTOM_RIGHT: \"bottom-right\",\n    TOP_RIGHT: \"top-right\"\n};\nconst CONFIRMATION_STRATEGY = {\n    POPUP: \"popup\",\n    MODAL: \"modal\",\n    AUTO_APPROVE: \"auto-approve\",\n    DEFAULT: \"default\"\n};\n/**\n * State change callbacks\n */ /**\n * Base controller configuration\n */ /**\n * Base state representation\n */ const LOGIN_PROVIDER = {\n    GOOGLE: \"google\",\n    FACEBOOK: \"facebook\",\n    REDDIT: \"reddit\",\n    DISCORD: \"discord\",\n    TWITCH: \"twitch\",\n    APPLE: \"apple\",\n    LINE: \"line\",\n    GITHUB: \"github\",\n    KAKAO: \"kakao\",\n    LINKEDIN: \"linkedin\",\n    TWITTER: \"twitter\",\n    WEIBO: \"weibo\",\n    WECHAT: \"wechat\",\n    EMAIL_PASSWORDLESS: \"email_passwordless\",\n    SMS_PASSWORDLESS: \"sms_passwordless\"\n};\n/**\n * {@label loginProviderType}\n */ const PAYMENT_PROVIDER = {\n    MOONPAY: \"moonpay\",\n    WYRE: \"wyre\",\n    RAMPNETWORK: \"rampnetwork\",\n    XANPOOL: \"xanpool\",\n    MERCURYO: \"mercuryo\",\n    TRANSAK: \"transak\"\n};\nfunction omitBy(object, predicate) {\n    // Create a new object to store the results\n    const result = {};\n    // Iterate over all own properties of the object\n    for (const [key, value] of Object.entries(object)){\n        if (!predicate(value, key)) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\nfunction pickBy(object, predicate) {\n    // Create a new object to store the results\n    const result = {};\n    for (const [key, value] of Object.entries(object)){\n        if (predicate(value, key)) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\nfunction cloneDeep(object) {\n    try {\n        return structuredClone(object);\n    } catch (error) {\n        return JSON.parse(JSON.stringify(object));\n    }\n}\nconst authServer = \"https://authjs.web3auth.io\";\nconst signChallenge = async (payload, chainNamespace)=>{\n    const t = chainNamespace === \"solana\" ? \"sip99\" : \"eip191\";\n    const header = {\n        t\n    };\n    const network = chainNamespace === \"solana\" ? \"solana\" : \"ethereum\";\n    const data = {\n        payload,\n        header,\n        network\n    };\n    const res = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${authServer}/siww/get`, data);\n    if (!res.success) {\n        throw new Error(\"Failed to authenticate user, Please reach out to Web3Auth Support team\");\n    }\n    return res.challenge;\n};\nconst verifySignedChallenge = async (chainNamespace, signedMessage, challenge, issuer, sessionTime, clientId, web3AuthNetwork, audience, additionalMetadata)=>{\n    var _window$location;\n    const t = chainNamespace === \"solana\" ? \"sip99\" : \"eip191\";\n    const sigData = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n        signature: {\n            s: signedMessage,\n            t\n        },\n        message: challenge,\n        issuer,\n        audience: audience || ( false ? 0 : \"com://reactnative\"),\n        timeout: sessionTime\n    }, additionalMetadata || {});\n    const idTokenRes = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${authServer}/siww/verify`, sigData, {\n        headers: {\n            client_id: clientId,\n            wallet_provider: issuer,\n            web3auth_network: web3AuthNetwork\n        }\n    });\n    if (!idTokenRes.success) {\n        loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"Failed to authenticate user, ,message verification failed\", idTokenRes.error);\n        throw new Error(\"Failed to authenticate user, ,message verification failed\");\n    }\n    return idTokenRes.token;\n};\nconst getTxStatusText = (txStatus)=>{\n    switch(txStatus){\n        case \"rejected\":\n        case \"unapproved\":\n        case \"failed\":\n            return ACTIVITY_STATUS_UNSUCCESSFUL;\n        case \"confirmed\":\n            return ACTIVITY_STATUS_SUCCESSFUL;\n        case \"submitted\":\n            return ACTIVITY_STATUS_PENDING;\n        case \"cancelled\":\n            return ACTIVITY_STATUS_CANCELLED;\n        default:\n            return \"\";\n    }\n};\n/**\n * General utility functions\n */ function intToHex(i) {\n    const hex = i.toString(16);\n    return `0x${hex}`;\n}\n/**\n * Returns a random number. Don't use for cryptographic purposes.\n * @returns a random number\n */ const randomId = ()=>Math.random().toString(36).slice(2);\n/**\n * Pads the front of the given hex string with zeroes until it reaches the\n * target length. If the input string is already longer than or equal to the\n * target length, it is returned unmodified.\n *\n * If the input string is \"0x\"-prefixed or not a hex string, an error will be\n * thrown.\n *\n * @param hexString - The hexadecimal string to pad with zeroes.\n * @param targetLength - The target length of the hexadecimal string.\n * @returns The input string front-padded with zeroes, or the original string\n * if it was already greater than or equal to to the target length.\n */ function padWithZeroes(hexString, targetLength) {\n    if (hexString !== \"\" && !/^[a-f0-9]+$/iu.test(hexString)) {\n        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);\n    }\n    if (targetLength < 0) {\n        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);\n    }\n    return String.prototype.padStart.call(hexString, targetLength, \"0\");\n}\n/**\n * Concatenate an extended ECDSA signature into a hex string.\n *\n * @param v - The 'v' portion of the signature.\n * @param r - The 'r' portion of the signature.\n * @param s - The 's' portion of the signature.\n * @returns The concatenated ECDSA signature.\n */ function concatSig(v, r, s) {\n    const rSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.fromSigned)(r);\n    const sSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.fromSigned)(s);\n    const vSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.bytesToBigInt)(v);\n    const rStr = padWithZeroes(Buffer.from((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.toUnsigned)(rSig)).toString(\"hex\"), 64);\n    const sStr = padWithZeroes(Buffer.from((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.toUnsigned)(sSig)).toString(\"hex\"), 64);\n    const vStr = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.stripHexPrefix)((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.bigIntToHex)(vSig));\n    return (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.addHexPrefix)(rStr.concat(sStr, vStr));\n}\nfunction timeout$1(duration) {\n    return new Promise((resolve)=>{\n        const timeoutRef = window.setTimeout(()=>{\n            resolve();\n            window.clearTimeout(timeoutRef);\n        }, duration);\n    });\n}\nconst getHeaders = (jwt, publicAddress)=>{\n    return {\n        headers: {\n            Authorization: `Bearer ${jwt}`,\n            \"Content-Type\": \"application/json; charset=utf-8\",\n            \"public-address\": publicAddress\n        }\n    };\n};\n/**\n * Text/number formatting utilities\n */ const formatSmallNumbers = (number, currency = \"usd\", noTilde = false)=>{\n    const finalNumber = bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].isBigNumber(number) ? number.toNumber() : number;\n    if (!Number.isFinite(finalNumber)) return \"\";\n    const value = currency.toLowerCase() === \"usd\" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));\n    const tilde = value > 0 ? \"~ \" : \"\";\n    return `${currency.toLowerCase() === \"usd\" || noTilde ? \"\" : tilde}${Number(value)} ${currency.toUpperCase()}`;\n};\nconst addressSlicer = (address, sliceLength = 5)=>{\n    if (!address) return \"\";\n    if (address.length < 11) {\n        return address;\n    }\n    if (typeof address !== \"string\") return \"\";\n    return `${address.slice(0, sliceLength)}...${address.slice(-sliceLength)}`;\n};\nconst significantDigits = (number, perc = false, length_ = 2)=>{\n    let input = !bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].isBigNumber(number) ? new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](number) : number;\n    if (input.isZero()) return input;\n    if (perc) {\n        input = input.times(new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](100));\n    }\n    let depth;\n    if (input.gte(new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](1))) {\n        depth = length_;\n    } else {\n        depth = length_ - 1 + Math.ceil(Math.log10(new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](\"1\").div(input).toNumber()));\n    }\n    const shift = new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](10).pow(new bignumber_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](depth));\n    const roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();\n    return roundedNumber;\n};\nconst formatDate = (inputDate)=>{\n    const monthList = [\n        \"Jan\",\n        \"Feb\",\n        \"Mar\",\n        \"Apr\",\n        \"May\",\n        \"Jun\",\n        \"Jul\",\n        \"Aug\",\n        \"Sep\",\n        \"Oct\",\n        \"Nov\",\n        \"Dec\"\n    ];\n    const date = new Date(inputDate);\n    const day = date.getDate();\n    const month = monthList[date.getMonth()];\n    const year = date.getFullYear();\n    return `${day} ${month} ${year}`;\n};\nconst formatTime = (time)=>{\n    return new Date(time).toTimeString().slice(0, 8);\n};\n/**\n * Network utilities\n */ const transactionMatchesNetwork = (transaction, chainId)=>{\n    if (typeof transaction.chainId !== \"undefined\") {\n        return transaction.chainId === chainId;\n    }\n    return false;\n};\n/**\n * Signing utils\n */ const hashMessage = (message)=>{\n    const bufferedMessage = Buffer.from(message, \"utf8\");\n    const el = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.hashPersonalMessage)(bufferedMessage);\n    return Buffer.from(el);\n};\nconst signMessage = async (privateKey, data)=>{\n    const privKey = Buffer.from(privateKey, \"hex\");\n    const message = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.stripHexPrefix)(data);\n    const msgSig = (0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.ecsign)(Buffer.from(message, \"hex\"), privKey);\n    const rawMsgSig = concatSig(Buffer.from((0,_ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__.bigIntToBytes)(msgSig.v)), Buffer.from(msgSig.r), Buffer.from(msgSig.s));\n    return rawMsgSig;\n};\n/**\n * popup handler utils\n */ function getPopupFeatures({ width: w, height: h }) {\n    // Fixes dual-screen position                             Most browsers      Firefox\n    const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n    const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n    const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n    const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n    const systemZoom = 1; // No reliable estimate\n    const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n    const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n    const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;\n    return features;\n}\nconst broadcastChannelOptions = {\n    type: \"server\",\n    // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']\n    webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)\n};\nfunction getCustomDeviceInfo() {\n    var _navigator;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {\n        return {\n            browser: \"Brave\"\n        };\n    }\n}\nclass UserError extends Error {\n}\nconst handleRedirectParameters = (hash, queryParameters)=>{\n    const hashParameters = {};\n    const hashUrl = new URL(`${window.location.origin}/?${hash.slice(1)}`);\n    hashUrl.searchParams.forEach((value, key)=>{\n        hashParameters[key] = value;\n    });\n    let instanceParameters = {};\n    let error = \"\";\n    if (!queryParameters.windowId) {\n        if (Object.keys(hashParameters).length > 0 && hashParameters.state) {\n            instanceParameters = JSON.parse((0,_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.safeatob)(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};\n            error = hashParameters.error_description || hashParameters.error || error;\n        } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {\n            instanceParameters = JSON.parse((0,_toruslabs_openlogin_utils__WEBPACK_IMPORTED_MODULE_6__.safeatob)(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};\n            if (queryParameters.error) error = queryParameters.error;\n        }\n    }\n    return {\n        error,\n        instanceParameters,\n        hashParameters\n    };\n};\nfunction sleep(ms) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, ms);\n    });\n}\nconst isUnauthorizedError = (error)=>{\n    return error instanceof Response && error.status === 401;\n};\nclass BaseKeyringController extends BaseController {\n    constructor({ config = {}, state }){\n        var _state$wallets;\n        super({\n            config,\n            state\n        });\n        this.defaultState = {\n            wallets: (_state$wallets = state.wallets) !== null && _state$wallets !== void 0 ? _state$wallets : []\n        };\n        this.initialize();\n    }\n    // for signing auth message\n    async signAuthMessage(address, message) {\n        const keyring = this.state.wallets.find((x)=>x.address === address);\n        if (!keyring) {\n            throw new Error(\"key does not exist\");\n        }\n        const hashedMessage = hashMessage(message).toString(\"hex\");\n        const rawMessageSig = await signMessage(keyring.privateKey, hashedMessage);\n        return rawMessageSig;\n    }\n}\nconst RETRIABLE_ERRORS = [\n    // ignore server overload errors\n    \"Gateway timeout\",\n    \"ETIMEDOUT\",\n    // ignore server sent html error pages\n    // or truncated json responses\n    \"failed to parse response body\",\n    // ignore errors where http req failed to establish\n    \"Failed to fetch\"\n];\nfunction checkForHttpErrors(fetchRes) {\n    // check for errors\n    switch(fetchRes.status){\n        case 405:\n            throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.methodNotFound();\n        case 418:\n            throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.internal({\n                message: `Request is being rate limited.`,\n                data: {\n                    cause: fetchRes\n                }\n            });\n        case 503:\n        case 504:\n            throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.internal({\n                message: `Gateway timeout. The request took too long to process.` + `This can happen when querying over too wide a block range.`\n            });\n    }\n}\nfunction timeout(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\nfunction parseResponse(fetchRes, body) {\n    // check for error code\n    if (fetchRes.status !== 200) {\n        throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.internal({\n            message: `Non-200 status code: '${fetchRes.status}'`,\n            data: body\n        });\n    }\n    // check for rpc error\n    if (body.error) {\n        throw _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.rpcErrors.internal({\n            data: body.error\n        });\n    }\n    // return successful result\n    return body.result;\n}\nfunction createFetchConfigFromReq({ req, rpcTarget, originHttpHeaderKey }) {\n    const parsedUrl = new URL(rpcTarget);\n    // prepare payload\n    // copy only canonical json rpc properties\n    const payload = {\n        id: req.id,\n        jsonrpc: req.jsonrpc,\n        method: req.method,\n        params: req.params\n    };\n    // extract 'origin' parameter from request\n    const originDomain = req.origin;\n    // serialize request body\n    const serializedPayload = JSON.stringify(payload);\n    // configure fetch params\n    const fetchParams = {\n        method: \"POST\",\n        headers: {\n            Accept: \"application/json\",\n            \"Content-Type\": \"application/json\"\n        },\n        body: serializedPayload\n    };\n    // optional: add request origin as header\n    if (originHttpHeaderKey && originDomain) {\n        fetchParams.headers[originHttpHeaderKey] = originDomain;\n    }\n    return {\n        fetchUrl: parsedUrl.href,\n        fetchParams\n    };\n}\nfunction createFetchMiddleware({ rpcTarget, originHttpHeaderKey }) {\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (req, res, _next)=>{\n        const { fetchUrl, fetchParams } = createFetchConfigFromReq({\n            req,\n            rpcTarget,\n            originHttpHeaderKey\n        });\n        // attempt request multiple times\n        const maxAttempts = 5;\n        const retryInterval = 1000;\n        for(let attempt = 0; attempt < maxAttempts; attempt++){\n            try {\n                const fetchRes = await fetch(fetchUrl, fetchParams);\n                // check for http errrors\n                checkForHttpErrors(fetchRes);\n                // parse response body\n                const fetchBody = await fetchRes.json();\n                const result = parseResponse(fetchRes, fetchBody);\n                // set result and exit retry loop\n                res.result = result;\n                return;\n            } catch (err) {\n                const errMsg = (err.message || err).toString();\n                const isRetriable = RETRIABLE_ERRORS.some((phrase)=>errMsg.includes(phrase));\n                // re-throw error if not retriable\n                if (!isRetriable) {\n                    throw err;\n                }\n            }\n            // delay before retrying\n            await timeout(retryInterval);\n        }\n    });\n}\nfunction deferredPromise() {\n    let resolve;\n    const promise = new Promise((_resolve)=>{\n        resolve = _resolve;\n    });\n    return {\n        resolve,\n        promise\n    };\n}\nfunction createInflightCacheMiddleware({ cacheIdentifierForRequest }) {\n    const inflightRequests = {};\n    async function createActiveRequestHandler(res, activeRequestHandlers) {\n        const { resolve, promise } = deferredPromise();\n        activeRequestHandlers.push((handledRes)=>{\n            // append a copy of the result and error to the response\n            res.result = cloneDeep(handledRes.result);\n            res.error = cloneDeep(handledRes.error);\n            resolve();\n        });\n        return promise;\n    }\n    function handleActiveRequest(res, activeRequestHandlers) {\n        // use setTimeout so we can resolve our original request first\n        setTimeout(()=>{\n            activeRequestHandlers.forEach((handler)=>{\n                try {\n                    handler(res);\n                } catch (err) {\n                    // catch error so all requests are handled correctly\n                    loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(err);\n                }\n            });\n        });\n    }\n    return (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_2__.createAsyncMiddleware)(async (req, res, next)=>{\n        // allow cach to be skipped if so specified\n        if (req.skipCache) {\n            return next();\n        }\n        // get cacheId, if cacheable\n        const cacheId = cacheIdentifierForRequest(req);\n        // if not cacheable, skip\n        if (!cacheId) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Request is not cacheable, proceeding. req = %o\", req);\n            return next();\n        }\n        // check for matching requests\n        let activeRequestHandlers = inflightRequests[cacheId];\n        // if found, wait for the active request to be handled\n        if (activeRequestHandlers) {\n            // setup the response listener and wait for it to be called\n            // it will handle copying the result and request fields\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Running %i handler(s) for request %o\", activeRequestHandlers.length, req);\n            await createActiveRequestHandler(res, activeRequestHandlers);\n            return undefined;\n        }\n        // setup response handler array for subsequent requests\n        activeRequestHandlers = [];\n        inflightRequests[cacheId] = activeRequestHandlers;\n        // allow request to be handled normally\n        loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Carrying original request forward %o\", req);\n        await next();\n        // clear inflight requests\n        delete inflightRequests[cacheId];\n        // schedule activeRequestHandlers to be handled\n        loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Running %i collected handler(s) for request %o\", activeRequestHandlers.length, req);\n        handleActiveRequest(res, activeRequestHandlers);\n        // complete\n        return undefined;\n    });\n}\nfunction createLoggerMiddleware(options) {\n    return function loggerMiddleware(request, response, next) {\n        next((callback)=>{\n            if (response.error) {\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().warn(\"Error in RPC response:\\n\", response);\n            }\n            if (request.isTorusInternal) return;\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(`RPC (${options.origin}):`, request, \"->\", response);\n            callback();\n        });\n    };\n}\nfunction createOriginMiddleware(options) {\n    return function originMiddleware(request, _, next) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        request.origin = options.origin;\n        next();\n    };\n}\nconst createRandomId = ()=>Math.random().toString(36).substring(2);\nconst CHAIN_NAMESPACES = {\n    EIP155: \"eip155\",\n    SOLANA: \"solana\",\n    CASPER: \"casper\",\n    XRPL: \"xrpl\",\n    OTHER: \"other\"\n};\n// eip155 for all evm chains\n/**\n * Custom network properties\n * @example isEIP1559Compatible: true etc.\n */ /**\n *\n */ class BroadcastChannelHandler {\n    constructor(channelPrefix, instanceId){\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"bc\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"channel\", void 0);\n        const queryParameters = new URLSearchParams(window.location.search);\n        const windowId = queryParameters.get(\"windowId\");\n        this.channel = `${channelPrefix}_${instanceId}_${windowId}`;\n        this.bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(this.channel, broadcastChannelOptions);\n    }\n    getMessageFromChannel() {\n        return new Promise((resolve, reject)=>{\n            this.bc.addEventListener(\"message\", async (ev)=>{\n                this.bc.close();\n                if (ev.error) {\n                    reject(ev.error);\n                } else {\n                    resolve(ev.data);\n                }\n            });\n            this.bc.postMessage({\n                data: {\n                    type: POPUP_LOADED\n                }\n            });\n        });\n    }\n}\nclass StreamWindow extends BaseController {\n    constructor({ config, state = {} }){\n        super({\n            config,\n            state\n        });\n        // if window has been closed by users\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"closed\", false);\n        this.initialize();\n    }\n    async open() {\n        return new Promise((resolve, reject)=>{\n            const { communicationEngine, communicationWindowManager } = this.config;\n            let popupSuccess = false;\n            communicationWindowManager.once(`${this.state.windowId}:closed`, ()=>{\n                this.closed = true;\n            });\n            // Window is not open yet\n            if (!this.state.windowId) {\n                // since, we're opening window now, no need to tell window anything\n                this.update({\n                    windowId: randomId()\n                });\n                if (typeof this.config.handleWindowBlockAlert !== \"function\") reject(new Error(\"handleWindowBlockAlert is not a function\"));\n                communicationWindowManager.once(`${this.state.windowId}:iframe-opened`, ()=>{\n                    // this means iframe is full screen now\n                    // there might be multiple block alerts at a time. so, we don't set iframe to close after handling this here\n                    this.config.handleWindowBlockAlert({\n                        windowId: this.state.windowId,\n                        finalUrl: this.state.url.href\n                    }).then(resolve).catch(reject);\n                });\n                // Tell the other party to maximize the iframe\n                communicationEngine.emit(\"notification\", {\n                    method: COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS,\n                    params: {\n                        isFullScreen: true,\n                        rid: this.state.windowId\n                    }\n                });\n            } else {\n                // this is a pre-opened window. so, we need to tell it to redirect to correct url. it's currently waiting on /redirect and uses `RedirectHandler` code\n                // Send this window with `windowId` the url to open via bc\n                const channelName = `${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${this.config.instanceId}_${this.state.windowId}`;\n                const bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(channelName, broadcastChannelOptions);\n                bc.addEventListener(\"message\", async (ev)=>{\n                    try {\n                        loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(ev, `receiving data on channel: ${bc.name}`);\n                        const { error } = ev;\n                        if (error) {\n                            // Popup says some error. so, we say it's not really opened\n                            reject(new Error(error));\n                            return;\n                        }\n                        const { message } = ev.data;\n                        if (message === POPUP_LOADED) {\n                            popupSuccess = true;\n                            await bc.postMessage({\n                                data: {\n                                    url: this.state.url.href,\n                                    message: \"\" // No need of a msg\n                                }\n                            });\n                            resolve(this);\n                            bc.close();\n                        }\n                    } catch (error) {\n                        reject(error);\n                        bc.close();\n                        // Something went wrong. so, we close that window\n                        this.close();\n                    }\n                });\n                // We don't know if the other end is ready to receive this msg. So, we keep writing until it receives and sends back something\n                // we need backoff strategy\n                // we need to wait for first attempt to succeed/fail until the second attempt\n                // If we get 429, we need to wait for a while and then try again\n                const postMsg = async ()=>{\n                    // this never throws\n                    const localResponse = await bc.postMessage({\n                        data: {\n                            message: SETUP_COMPLETE\n                        }\n                    });\n                    return localResponse;\n                };\n                let currentDelay = bc.type === \"server\" ? 1000 : 200;\n                const recursiveFn = async ()=>{\n                    if (!popupSuccess && !this.closed) {\n                        const localResponse = await postMsg();\n                        if (bc.type === \"server\") {\n                            const serverResponse = localResponse;\n                            if (serverResponse.status >= 400) {\n                                // We need to wait for a while and then try again\n                                currentDelay = Math.round(currentDelay * 1.5);\n                            }\n                        }\n                        await sleep(currentDelay);\n                        await recursiveFn();\n                    }\n                };\n                recursiveFn();\n            }\n        });\n    }\n    close() {\n        const { communicationEngine } = this.config;\n        communicationEngine.emit(\"notification\", {\n            method: COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW,\n            params: {\n                windowId: this.state.windowId\n            }\n        });\n    }\n}\n/*\nScenarios:\n1. Open a normal popup window and no communication with it - Use PopupHandler\n2. Open a popup window and communicate with it - Use PopupWithBcHandler (can initiate communication by waiting for window to open or not)\n\n3. If window is already opened, pass in windowId to the popup handler. \n   This will establish communication with the popup window and sends it a new url to redirect to\n\n\nIf you're trying to open a window and it gets blocked (happens if you're in iframe or delay b/w click and opening window),\n  StreamWindow is invoked and it writes in a channel to display a message to the user\n\nOnce user clicks on that modal/dialog, we pre-open the window and pass in the windowId (goes to 3)\n*/ /**\n * Handles popup window management.\n * For broadcast channel communication, use url with `instanceId` coded into state parameter.\n * This state parameter will be passed across redirects according to OAuth spec.\n */ class PopupHandler extends BaseController {\n    constructor({ config, state }){\n        super({\n            config,\n            state\n        });\n        // this.id = randomId()\n        // Add in dapp storage key to all popups as a hash parameter\n        this.defaultConfig = {\n            features: getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW),\n            target: \"_blank\",\n            communicationEngine: null,\n            communicationWindowManager: null,\n            timeout: 30000,\n            instanceId: \"\",\n            handleWindowBlockAlert: null\n        };\n        this.defaultState = {\n            windowTimer: null,\n            window: null,\n            iClosedWindow: false,\n            windowId: \"\",\n            url: state.url\n        };\n        this.initialize();\n        this._setupTimer();\n    }\n    async open() {\n        // if window is already open\n        const { target, features, communicationEngine, communicationWindowManager } = this.config;\n        const { windowId, url } = this.state;\n        // No window has been pre-opened\n        if (!windowId) {\n            // try to open a window first\n            let localWindow = window.open(url.href, target, features);\n            let finalWindowId = \"\";\n            if (!localWindow) {\n                // if it's blocked, open StreamWindow\n                const streamWindow = new StreamWindow({\n                    config: {\n                        communicationEngine,\n                        communicationWindowManager,\n                        instanceId: this.config.instanceId,\n                        handleWindowBlockAlert: this.config.handleWindowBlockAlert\n                    },\n                    state: {\n                        url\n                    }\n                });\n                streamWindow.open();\n                finalWindowId = streamWindow.state.windowId;\n                localWindow = streamWindow;\n            }\n            this.update({\n                window: localWindow,\n                windowId: finalWindowId || randomId()\n            });\n            return;\n        }\n        // A window has been pre-opened with a query parameter `windowId`\n        const localWindow = new StreamWindow({\n            config: {\n                communicationEngine,\n                communicationWindowManager,\n                instanceId: this.config.instanceId,\n                handleWindowBlockAlert: this.config.handleWindowBlockAlert\n            },\n            state: {\n                url,\n                windowId\n            }\n        });\n        this.update({\n            window: localWindow,\n            windowId: localWindow.state.windowId\n        });\n        await localWindow.open();\n    }\n    close() {\n        this.update({\n            iClosedWindow: true\n        });\n        const { window: window1 } = this.state;\n        if (window1) window1.close();\n    }\n    _setupTimer() {\n        const timer = window.setInterval(()=>{\n            const { window: window1, windowTimer, iClosedWindow } = this.state;\n            if (window1 && window1.closed) {\n                if (windowTimer) clearInterval(windowTimer);\n                setTimeout(()=>{\n                    if (!iClosedWindow) {\n                        this.emit(\"close\");\n                    }\n                    this.update({\n                        iClosedWindow: false,\n                        window: null\n                    });\n                }, this.config.timeout);\n            }\n            if (window1 === null && windowTimer) clearInterval(windowTimer);\n        }, 500);\n        this.update({\n            windowTimer: timer\n        });\n    }\n}\n// Always listening channels. Hence, no window id\nclass PopupStoreChannel {\n    constructor({ instanceId, handleLogout, handleAccountImport, handleNetworkChange, handleSelectedAddressChange, handleThemeChange }){\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleLogout\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleAccountImport\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleNetworkChange\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleThemeChange\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"handleSelectedAddressChange\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"instanceId\", void 0);\n        this.instanceId = instanceId;\n        this.handleLogout = handleLogout;\n        this.handleAccountImport = handleAccountImport;\n        this.handleNetworkChange = handleNetworkChange;\n        this.handleSelectedAddressChange = handleSelectedAddressChange;\n        this.handleThemeChange = handleThemeChange;\n    }\n    setupStoreChannels() {\n        this.logoutChannel();\n        this.importAccountChannel();\n        this.networkChangeChannel();\n        this.selectedAddressChangeChannel();\n        this.themeChangedChannel();\n    }\n    logoutChannel() {\n        const logoutChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_LOGOUT_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        logoutChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data;\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"received logout message\", ev);\n            if (!ev.error && ((_ev$data = ev.data) === null || _ev$data === void 0 ? void 0 : _ev$data.type) === BROADCAST_CHANNELS_MSGS.LOGOUT) {\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"Logging Out\");\n                this.handleLogout();\n            }\n        });\n    }\n    importAccountChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_ACCOUNT_IMPORT_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data2;\n            if (!ev.error && ((_ev$data2 = ev.data) === null || _ev$data2 === void 0 ? void 0 : _ev$data2.type) === BROADCAST_CHANNELS_MSGS.ACCOUNT_IMPORTED) {\n                var _ev$data3;\n                this.handleAccountImport((_ev$data3 = ev.data) === null || _ev$data3 === void 0 ? void 0 : _ev$data3.privKey);\n            }\n        });\n    }\n    networkChangeChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_NETWORK_CHANGE_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data4;\n            if (!ev.error && ((_ev$data4 = ev.data) === null || _ev$data4 === void 0 ? void 0 : _ev$data4.type) === BROADCAST_CHANNELS_MSGS.NETWORK_CHANGE) {\n                var _ev$data5;\n                this.handleNetworkChange((_ev$data5 = ev.data) === null || _ev$data5 === void 0 ? void 0 : _ev$data5.network);\n            }\n        });\n    }\n    themeChangedChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.THEME_CHANGE}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data6;\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info({\n                ev\n            });\n            if (!ev.error && ((_ev$data6 = ev.data) === null || _ev$data6 === void 0 ? void 0 : _ev$data6.type) === BROADCAST_CHANNELS_MSGS.SET_THEME) {\n                var _ev$data7;\n                this.handleThemeChange((_ev$data7 = ev.data) === null || _ev$data7 === void 0 ? void 0 : _ev$data7.theme);\n            }\n        });\n    }\n    selectedAddressChangeChannel() {\n        const walletAccountImportChannel = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(`${BROADCAST_CHANNELS.WALLET_SELECTED_ADDRESS_CHANNEL}_${this.instanceId}`, broadcastChannelOptions);\n        walletAccountImportChannel.addEventListener(\"message\", (ev)=>{\n            var _ev$data8;\n            if (!ev.error && ((_ev$data8 = ev.data) === null || _ev$data8 === void 0 ? void 0 : _ev$data8.type) === BROADCAST_CHANNELS_MSGS.SELECTED_ADDRESS_CHANGE) {\n                var _ev$data9;\n                this.handleSelectedAddressChange((_ev$data9 = ev.data) === null || _ev$data9 === void 0 ? void 0 : _ev$data9.selectedAddress);\n            }\n        });\n    }\n}\n/**\n * PopupWithBcHandler is a PopupHandler which uses broadcast channel to communicate with the popup window.\n */ class PopupWithBcHandler extends PopupHandler {\n    constructor({ config, state, channelPrefix }){\n        super({\n            config,\n            state\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"channelPrefix\", void 0);\n        this.channelPrefix = channelPrefix;\n    }\n    /**\n   * Receives the data from popup window and closes the window\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */ handle(successExtraFn) {\n        const channelName = `${this.channelPrefix}_${this.config.instanceId}_${this.state.windowId}`;\n        const bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(channelName, broadcastChannelOptions);\n        return new Promise((resolve, reject)=>{\n            const closeListener = ()=>{\n                bc.close();\n                reject(new UserError(\"user closed popup\"));\n                this.removeListener(\"close\", closeListener);\n            };\n            this.on(\"close\", closeListener);\n            bc.addEventListener(\"message\", async (ev)=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(ev, `receiving data on channel: ${bc.name}`);\n                try {\n                    const { error, data } = ev;\n                    if (error) {\n                        reject(new Error(error));\n                        return;\n                    }\n                    if (successExtraFn) await successExtraFn.call(this, data);\n                    resolve(data);\n                } catch (error) {\n                    reject(error);\n                } finally{\n                    bc.close();\n                    this.close();\n                }\n            });\n            this.open().then(()=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(`opened window ${bc.name}`);\n                // Opened window. yay.  let the bc events do their job\n                return undefined;\n            }).catch((err)=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(err, \"something went wrong while opening window\");\n                reject(err);\n            });\n        });\n    }\n    /**\n   * Use this if we have to send large payloads which don't fit in query/hash params.\n   * Waits for ack that popup window is ready to receive data.\n   * Receives the data from popup window and closes the window\n   * @param payload - The data to be sent to the popup window once we have ack that window is ready to receive data\n   * @param successExtraFn - Extra function to be called after the data is received\n   * @returns The data to be received\n   */ handleWithHandshake(payload, successExtraFn) {\n        const channelName = `${this.channelPrefix}_${this.config.instanceId}_${this.state.windowId}`;\n        const bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(channelName, broadcastChannelOptions);\n        return new Promise((resolve, reject)=>{\n            const closeListener = ()=>{\n                bc.close();\n                reject(new UserError(\"user closed popup\"));\n                this.removeListener(\"close\", closeListener);\n            };\n            this.on(\"close\", closeListener);\n            bc.addEventListener(\"message\", async (ev)=>{\n                try {\n                    loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(ev, `receiving data on channel: ${bc.name}`);\n                    const { error, data } = ev;\n                    if (error) {\n                        reject(new Error(error));\n                        return;\n                    }\n                    // Do handshake\n                    const { type = \"\" } = data;\n                    if (type === POPUP_LOADED) {\n                        // Hack with generic to use the same type for both send and receive\n                        await bc.postMessage({\n                            data: payload\n                        });\n                    } else if (type === POPUP_RESULT) {\n                        if (successExtraFn) await successExtraFn.call(this, data);\n                        resolve(data);\n                        // Must only close the bc after result is done\n                        bc.close();\n                        this.close();\n                    }\n                } catch (error) {\n                    reject(error);\n                    bc.close();\n                    this.close();\n                }\n            });\n            this.open().then(()=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(`opened window ${bc.name}`);\n                // Opened window. yay.  let the bc events do their job\n                return undefined;\n            }).catch((err)=>{\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(err, \"something went wrong while opening window\");\n                reject(err);\n            });\n        });\n    }\n}\nclass RedirectHandler {\n    // private hashParameters: Record<string, string>;\n    constructor(instanceId){\n        // private error: string;\n        // this is sessionid post login\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"instanceId\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"finalQueryParams\", {});\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"instanceParameters\", void 0);\n        const { hash } = window.location;\n        const queryParameters = new URLSearchParams(window.location.search);\n        queryParameters.forEach((value, key)=>{\n            this.finalQueryParams[key] = value;\n        });\n        const { instanceParameters } = handleRedirectParameters(hash, this.finalQueryParams);\n        // this.error = error;\n        this.instanceParameters = instanceParameters;\n        // this.hashParameters = hashParameters;\n        this.instanceId = instanceId;\n    }\n    async handle() {\n        return new Promise((resolve, reject)=>{\n            const { finalQueryParams, instanceParameters } = this;\n            let bc;\n            try {\n                // used for login case. there's no windowId here\n                // if (!finalQueryParams.windowId) {\n                //   bc = new BroadcastChannel(`${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${instanceParameters.instanceId}`, broadcastChannelOptions);\n                //   bc.addEventListener(\"message\", async (ev) => {\n                //     if (ev.error) {\n                //       reject(ev.error);\n                //       window.close();\n                //     } else {\n                //       resolve();\n                //       bc.close();\n                //       log.info(\"posted\", { finalQueryParams, hashParameters, instanceParameters });\n                //     }\n                //   });\n                //   bc.postMessage({\n                //     data: {\n                //       instanceParams: instanceParameters,\n                //       hashParams: hashParameters,\n                //       queryParams: finalQueryParams,\n                //     },\n                //     error,\n                //   });\n                //   setTimeout(() => {\n                //     resolve();\n                //     window.location.href = window.location.origin + window.location.search + window.location.hash;\n                //   }, 5000);\n                // } else {\n                const channelName = `${BROADCAST_CHANNELS.REDIRECT_CHANNEL}_${this.instanceId || instanceParameters.instanceId}_${finalQueryParams.windowId || instanceParameters.windowId}`;\n                bc = new _toruslabs_broadcast_channel__WEBPACK_IMPORTED_MODULE_10__.BroadcastChannel(channelName, broadcastChannelOptions);\n                bc.addEventListener(\"message\", async (ev)=>{\n                    const { url, message } = ev.data;\n                    if (url) {\n                        resolve();\n                        window.location.href = url;\n                    } else if (message === SETUP_COMPLETE) {\n                        await bc.postMessage({\n                            data: {\n                                windowId: finalQueryParams.windowId,\n                                message: POPUP_LOADED\n                            }\n                        });\n                    }\n                    if (ev.error && ev.error !== \"\") {\n                        loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(ev.error);\n                        resolve();\n                        bc.close();\n                    }\n                });\n            // }\n            } catch (err) {\n                loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(err, \"something went wrong\");\n                reject(err);\n                if (bc) bc.close();\n                window.close();\n            }\n        });\n    }\n}\nvar HTTP_METHOD = /*#__PURE__*/ function(HTTP_METHOD) {\n    HTTP_METHOD[HTTP_METHOD[\"GET\"] = 0] = \"GET\";\n    HTTP_METHOD[HTTP_METHOD[\"POST\"] = 1] = \"POST\";\n    HTTP_METHOD[HTTP_METHOD[\"PUT\"] = 2] = \"PUT\";\n    HTTP_METHOD[HTTP_METHOD[\"PATCH\"] = 3] = \"PATCH\";\n    HTTP_METHOD[HTTP_METHOD[\"DELETE\"] = 4] = \"DELETE\";\n    return HTTP_METHOD;\n}(HTTP_METHOD || {});\nconst constructAuthHeaders = ({ jwtToken, publicAddress })=>{\n    return {\n        headers: {\n            Authorization: `Bearer ${jwtToken}`,\n            \"public-address\": publicAddress\n        }\n    };\n};\nconst withUnauthorizedHandler = async (fn, emitter)=>{\n    try {\n        const response = await fn();\n        return response;\n    } catch (e) {\n        if (isUnauthorizedError(e)) {\n            emitter.emit(ControllerEvents.UserUnauthorized);\n        }\n        throw e;\n    }\n};\nconst jwtTokenExpired = (jwt)=>{\n    const decoded = (0,jwt_decode__WEBPACK_IMPORTED_MODULE_9__.jwtDecode)(jwt);\n    const jwtExpiry = decoded.exp * 1000;\n    const currentTime = new Date().getTime();\n    return currentTime >= jwtExpiry;\n};\nconst WSApiClient = (baseApiUrl, emitter)=>{\n    const authRequest = (method, url, data, authCredentials, customOptions)=>{\n        if (jwtTokenExpired(authCredentials.jwtToken)) {\n            emitter.emit(ControllerEvents.UserUnauthorized);\n            // eslint-disable-next-line @typescript-eslint/no-throw-literal\n            throw new Response(null, {\n                status: 401,\n                statusText: \"Unauthorized\"\n            });\n        }\n        const headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }, constructAuthHeaders(authCredentials));\n        if (method === HTTP_METHOD.GET) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.get)(url, headers, customOptions), emitter);\n        }\n        if (method === HTTP_METHOD.POST) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(url, data, headers, customOptions), emitter);\n        }\n        if (method === HTTP_METHOD.PUT) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.put)(url, data, headers, customOptions), emitter);\n        }\n        if (method === HTTP_METHOD.PATCH) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.patch)(url, data, headers, customOptions), emitter);\n        }\n        if (method === HTTP_METHOD.DELETE) {\n            return withUnauthorizedHandler(()=>(0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.remove)(url, data, headers, customOptions), emitter);\n        }\n    };\n    return {\n        authGet: (url, authCredentials, customOptions)=>authRequest(HTTP_METHOD.GET, `${baseApiUrl}/${url}`, {}, authCredentials, customOptions),\n        authPost: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.POST, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),\n        authPut: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.PUT, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),\n        authPatch: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.PATCH, `${baseApiUrl}/${url}`, data, authCredentials, customOptions),\n        authRemove: (url, data, authCredentials, customOptions)=>authRequest(HTTP_METHOD.DELETE, `${baseApiUrl}/${url}`, data, authCredentials, customOptions)\n    };\n};\nconst ACTIVITY_ACTION = {\n    ACTIVITY_ACTION_ALL: \"walletActivity.allTransactions\",\n    ACTIVITY_ACTION_SEND: \"walletActivity.send\",\n    ACTIVITY_ACTION_RECEIVE: \"walletActivity.receive\",\n    ACTIVITY_ACTION_TOPUP: \"walletActivity.topup\"\n};\nconst ACCOUNT_CATEGORY = {\n    NORMAL: \"normal\",\n    THRESHOLD: \"threshold\",\n    IMPORTED: \"imported\",\n    // we have private key here\n    APP_SCOPED: \"app_scoped\",\n    ACCOUNT_ABSTRACTION: \"account_abstraction\",\n    EXTERNAL: \"external\",\n    // like metamask, wallet connect\n    MPC: \"mpc\",\n    SFA: \"sfa\"\n};\n/**\n * Preferences controller state\n */ /**\n * @param address - address of the user\n * @param jwtToken - if jwt token already exists, it will be used instead of fetching from backend\n * @param calledFromEmbed - if called from embed\n * @param userInfo - optional user info\n * @param rehydrate - Rehydrate the preferences from the local storage\n */ // By default, poll every 3 minutes\nconst DEFAULT_INTERVAL = 180 * 1000;\nconst DEFAULT_PREFERENCES = {\n    selectedCurrency: \"USD\",\n    theme: \"dark\",\n    locale: \"en\",\n    accountType: ACCOUNT_CATEGORY.NORMAL,\n    contacts: [],\n    jwtToken: \"\",\n    fetchedPastTx: [],\n    pastTransactions: [],\n    paymentTx: [],\n    defaultPublicAddress: \"\",\n    customTokens: [],\n    customNfts: [],\n    crashReport: true,\n    userInfo: {\n        aggregateVerifier: \"\",\n        email: \"\",\n        name: \"\",\n        profileImage: \"\",\n        typeOfLogin: LOGIN_PROVIDER.GOOGLE,\n        verifier: \"\",\n        verifierId: \"\"\n    }\n};\n/**\n * Controller that stores shared settings and exposes convenience methods\n */ class BasePreferencesController extends BaseController {\n    /**\n   * Creates a PreferencesController instance\n   *\n   * @param config - Initial options used to configure this controller\n   * @param state - Initial state to set on this controller\n   */ constructor({ config, state, defaultPreferences, signAuthMessage, validateSignMessage }){\n        super({\n            config,\n            state\n        });\n        /**\n     * Name of this controller used during composition\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"name\", \"PreferencesController\");\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"iframeOrigin\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"wsApiClient\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"signAuthMessage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"validateSignMessage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"defaultPreferences\", void 0);\n        if (!config.api) {\n            throw new Error(\"PreferencesController - no api specified in config.\");\n        }\n        this.defaultState = {\n            identities: {},\n            selectedAddress: \"\",\n            lastErrorMessage: \"\",\n            lastSuccessMessage: \"\"\n        };\n        this.defaultConfig = {\n            api: config.api,\n            pollInterval: DEFAULT_INTERVAL\n        };\n        this.initialize();\n        this.defaultPreferences = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, DEFAULT_PREFERENCES), defaultPreferences);\n        this.signAuthMessage = signAuthMessage;\n        this.validateSignMessage = validateSignMessage;\n        this.wsApiClient = WSApiClient(this.config.api, this);\n    }\n    setIframeOrigin(origin) {\n        this.iframeOrigin = origin;\n    }\n    getAddressState(address) {\n        const selectedAddress = address || this.state.selectedAddress;\n        return this.state.identities[selectedAddress];\n    }\n    /**\n   * Sets selected address\n   *\n   * @param selectedAddress - casper account hash\n   */ setSelectedAddress(selectedAddress) {\n        this.update({\n            selectedAddress\n        });\n    }\n    async getUser(address) {\n        const user = await this.wsApiClient.authGet(\"user?fetchTx=false\", this.authCredentials(address), {\n            useAPIKey: true\n        });\n        return user.data;\n    }\n    async createUser(params) {\n        const { selectedCurrency, theme, verifier, verifierId, locale, address, idToken, type, web3AuthNetwork } = params;\n        const userPayload = {\n            default_currency: selectedCurrency,\n            theme,\n            verifier,\n            verifier_id: verifierId,\n            locale,\n            idToken,\n            account_type: type,\n            web3auth_network: web3AuthNetwork\n        };\n        await this.wsApiClient.authPost(\"user\", userPayload, this.authCredentials(address), {\n            useAPIKey: true\n        });\n        this.updateState({\n            theme,\n            defaultPublicAddress: address,\n            selectedCurrency,\n            locale,\n            accountType: type\n        }, address);\n    }\n    async storeUserLogin(params) {\n        const { verifierId, verifier, options, address, idToken, web3AuthClientId, web3AuthNetwork, sessionPubKey, loginMode } = params;\n        if (!options.rehydrate) {\n            const browser = bowser__WEBPACK_IMPORTED_MODULE_8__[\"default\"].getParser(window.navigator.userAgent);\n            const specialBrowser = getCustomDeviceInfo();\n            const recordLoginPayload = {\n                os: browser.getOSName(),\n                os_version: browser.getOSVersion() || \"unidentified\",\n                browser: (specialBrowser === null || specialBrowser === void 0 ? void 0 : specialBrowser.browser) || browser.getBrowserName() || \"unidentified\",\n                browser_version: browser.getBrowserVersion() || \"unidentified\",\n                platform: browser.getPlatform().type || \"desktop\",\n                hostname: this.iframeOrigin,\n                verifier,\n                verifier_id: verifierId,\n                idToken,\n                web3auth_client_id: web3AuthClientId,\n                web3auth_network: web3AuthNetwork,\n                session_pub_key: sessionPubKey,\n                login_mode: loginMode\n            };\n            await this.wsApiClient.authPost(\"user/recordLogin\", recordLoginPayload, this.authCredentials(address), {\n                useAPIKey: true\n            });\n        }\n    }\n    async setCrashReport(isEnabled) {\n        var _this$getAddressState;\n        if (isEnabled === ((_this$getAddressState = this.getAddressState()) === null || _this$getAddressState === void 0 ? void 0 : _this$getAddressState.crashReport)) return true;\n        try {\n            await this.wsApiClient.authPatch(\"user\", {\n                enable_crash_reporter: isEnabled\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                crashReport: isEnabled\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error);\n            return false;\n        }\n    }\n    async setUserTheme(theme) {\n        var _this$getAddressState2;\n        if (theme === ((_this$getAddressState2 = this.getAddressState()) === null || _this$getAddressState2 === void 0 ? void 0 : _this$getAddressState2.theme)) return true;\n        try {\n            await this.wsApiClient.authPatch(\"user\", {\n                theme\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                theme\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error);\n            return false;\n        }\n    }\n    async setUserLocale(locale) {\n        var _this$getAddressState3;\n        if (locale === ((_this$getAddressState3 = this.getAddressState()) === null || _this$getAddressState3 === void 0 ? void 0 : _this$getAddressState3.locale)) return;\n        try {\n            await this.wsApiClient.authPatch(\"user\", {\n                locale\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                locale\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to set locale\", error);\n            return false;\n        }\n    }\n    async setSelectedCurrency(payload) {\n        var _this$getAddressState4;\n        if (payload.selectedCurrency === ((_this$getAddressState4 = this.getAddressState()) === null || _this$getAddressState4 === void 0 ? void 0 : _this$getAddressState4.selectedCurrency)) return true;\n        try {\n            await this.wsApiClient.authPatch(\"user\", {\n                default_currency: payload.selectedCurrency\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                selectedCurrency: payload.selectedCurrency\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error);\n            return false;\n        }\n    }\n    async addContact(contact) {\n        try {\n            var _this$getAddressState5;\n            const response = await this.wsApiClient.authPost(\"contact\", contact, this.authCredentials(), {\n                useAPIKey: true\n            });\n            this.updateState({\n                contacts: [\n                    ...((_this$getAddressState5 = this.getAddressState()) === null || _this$getAddressState5 === void 0 ? void 0 : _this$getAddressState5.contacts) || [],\n                    response.data\n                ]\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to add contact\", error);\n            return false;\n        }\n    }\n    async deleteContact(contactId) {\n        try {\n            var _this$getAddressState6;\n            const response = await this.wsApiClient.authRemove(`contact/${contactId}`, {}, this.authCredentials(), {\n                useAPIKey: true\n            });\n            const finalContacts = (_this$getAddressState6 = this.getAddressState()) === null || _this$getAddressState6 === void 0 ? void 0 : _this$getAddressState6.contacts.filter((contact)=>contact.id !== response.data.id);\n            if (finalContacts) this.updateState({\n                contacts: [\n                    ...finalContacts\n                ]\n            });\n            return true;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to delete contact\", error);\n            return false;\n        }\n    }\n    async revokeDiscord(idToken) {\n        try {\n            const resp = await this.wsApiClient.authPost(\"revoke/discord\", {\n                token: idToken\n            }, this.authCredentials(), {\n                useAPIKey: true\n            });\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(resp);\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error);\n        }\n    }\n    async patchPastTx(body, address) {\n        try {\n            const response = await this.wsApiClient.authPatch(\"transaction\", body, this.authCredentials(address), {\n                useAPIKey: true\n            });\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"successfully patched\", response);\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to patch tx\", error);\n        }\n    }\n    async postPastTx(tx, address) {\n        try {\n            const response = await this.wsApiClient.authPost(\"transaction\", tx, this.authCredentials(address), {\n                useAPIKey: true\n            });\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().info(\"successfully posted tx\", response);\n            return response;\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(error, \"unable to insert transaction\");\n        }\n    }\n    async getWalletOrders(address) {\n        try {\n            const response = await this.wsApiClient.authGet(\"transaction\", this.authCredentials(address), {\n                useAPIKey: true\n            });\n            return response.success ? response.data ? response.data : [] : [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to get wallet orders tx\", error);\n            return [];\n        }\n    }\n    async getTopUpOrders(address) {\n        try {\n            const response = await this.wsApiClient.authGet(\"transaction\", this.authCredentials(address), {\n                useAPIKey: true\n            });\n            return response.data || [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to fetch past Top up orders\", error);\n        }\n    }\n    async getBillBoardData() {\n        try {\n            const response = await this.wsApiClient.authGet(\"billboard\", this.authCredentials(), {\n                useAPIKey: true\n            });\n            return response.success ? response.data : [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to get billboard data\", error);\n            return [];\n        }\n    }\n    async getMessageForSigning(publicAddress, web3AuthIdToken) {\n        const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/message`, {\n            public_address: publicAddress,\n            id_token: web3AuthIdToken\n        }, {}, {\n            useAPIKey: true\n        });\n        return response.message;\n    }\n    async getTwitterId(payload) {\n        const res = await this.wsApiClient.authGet(`twitter?screen_name=${payload.nick}`, this.authCredentials(), {\n            useAPIKey: true\n        });\n        return `${payload.typeOfLogin.toLowerCase()}|${res.data.toString()}`;\n    }\n    async sendEmail(payload) {\n        return this.wsApiClient.authPost(\"transaction/sendemail\", payload.emailObject, this.authCredentials(), {\n            useAPIKey: true\n        });\n    }\n    async refreshJwt() {\n        const address = this.state.selectedAddress;\n        const messageToSign = await this.getMessageForSigning(address);\n        await this.validateSignMessage(messageToSign);\n        const signedMessage = await this.signAuthMessage(address, messageToSign);\n        const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, {\n            challenge: messageToSign,\n            public_address: address,\n            signed_message: signedMessage\n        }, {}, {\n            useAPIKey: true\n        });\n        this.updateState({\n            jwtToken: response.token\n        }, address);\n    }\n    async getDappList() {\n        try {\n            const response = await this.wsApiClient.authGet(\"dapps\", this.authCredentials(), {\n                useAPIKey: true\n            });\n            return response.success ? response.data : [];\n        } catch (error) {\n            loglevel__WEBPACK_IMPORTED_MODULE_4___default().error(\"unable to get dapps list\", error);\n            return [];\n        }\n    }\n    /**\n   * Strategy\n   * For account type: threshold, normal (web3auth login)\n   * idToken from web3auth login must be present. We use it directly\n   *\n   * For account type: app_scoped, IMPORTED\n   * idToken from web3auth login must be present. We request a message for signing using the idToken\n   * and sign it using the private key of the account. We then send the signed message to the backend\n   * to verify the signature and return a new jwtToken that includes the app_scoped address\n   *\n   * For account type: Account abstraction\n   * idToken from web3auth login must be present. We use it to exchange for a new jwtToken.\n   * Because backend can derive AA address from public address and issue this token easily.\n   *\n   * For account type: external\n   * idToken from web3auth `authenticateUser` (siww) login must be present. We use it directly\n   */ async init(params) {\n        const { address, userInfo, idToken, metadata = {}, type } = params;\n        if (this.getAddressState(address)) return;\n        let jwtToken;\n        switch(type){\n            case ACCOUNT_CATEGORY.IMPORTED:\n                {\n                    if (!idToken) throw new Error(\"Web3Auth idToken must be present\");\n                    const messageToSign = await this.getMessageForSigning(address, idToken);\n                    await this.validateSignMessage(messageToSign);\n                    const signedMessage = await this.signAuthMessage(address, messageToSign);\n                    const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                        challenge: messageToSign,\n                        account_type: type,\n                        public_address: address,\n                        signed_message: signedMessage,\n                        verifier: userInfo.aggregateVerifier || userInfo.verifier,\n                        verifier_id: userInfo.verifierId\n                    }, metadata), {}, {\n                        useAPIKey: true\n                    });\n                    jwtToken = response.token;\n                    break;\n                }\n            case ACCOUNT_CATEGORY.EXTERNAL:\n                {\n                    if (!idToken) throw new Error(\"SIWW idToken must be present\");\n                    const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                        account_type: type,\n                        public_address: address,\n                        id_token: idToken,\n                        verifier: userInfo.aggregateVerifier || userInfo.verifier,\n                        verifier_id: userInfo.verifierId\n                    }, metadata), {}, {\n                        useAPIKey: true\n                    });\n                    jwtToken = response.token;\n                    break;\n                }\n            case ACCOUNT_CATEGORY.ACCOUNT_ABSTRACTION:\n                {\n                    if (!idToken) throw new Error(\"Web3Auth idToken must be present\");\n                    const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                        public_address: address,\n                        id_token: idToken,\n                        verifier: userInfo.aggregateVerifier || userInfo.verifier,\n                        verifier_id: userInfo.verifierId,\n                        account_type: type\n                    }, metadata), {}, {\n                        useAPIKey: true\n                    });\n                    jwtToken = response.token;\n                    break;\n                }\n            case ACCOUNT_CATEGORY.MPC:\n            case ACCOUNT_CATEGORY.SFA:\n                {\n                    if (!metadata.signatures) throw new Error(\"MPC signatures must be present\");\n                    const response = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_3__.post)(`${this.config.api}/auth/verify`, _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({\n                        public_address: address,\n                        verifier: userInfo.aggregateVerifier || userInfo.verifier,\n                        verifier_id: userInfo.verifierId,\n                        account_type: type\n                    }, metadata), {}, {\n                        useAPIKey: true\n                    });\n                    jwtToken = response.token;\n                    break;\n                }\n            case ACCOUNT_CATEGORY.NORMAL:\n            case ACCOUNT_CATEGORY.THRESHOLD:\n            case ACCOUNT_CATEGORY.APP_SCOPED:\n            default:\n                if (!idToken) throw new Error(\"Web3Auth idToken must be present\");\n                jwtToken = idToken;\n                break;\n        }\n        this.updateState({\n            jwtToken,\n            userInfo,\n            accountType: type !== null && type !== void 0 ? type : this.defaultPreferences.accountType\n        }, address);\n    }\n    updateState(preferences, address) {\n        const selectedAddress = address || this.state.selectedAddress;\n        const currentState = this.getAddressState(selectedAddress) || cloneDeep(this.defaultPreferences);\n        const mergedState = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, currentState), preferences);\n        this.update({\n            identities: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.state.identities), {}, {\n                [selectedAddress]: mergedState\n            })\n        });\n        return mergedState;\n    }\n    authCredentials(address) {\n        var _this$getAddressState7;\n        const selectedAddress = address || this.state.selectedAddress;\n        const jwtToken = ((_this$getAddressState7 = this.getAddressState(selectedAddress)) === null || _this$getAddressState7 === void 0 ? void 0 : _this$getAddressState7.jwtToken) || \"\";\n        return {\n            jwtToken,\n            publicAddress: selectedAddress\n        };\n    }\n    headers(address) {\n        var _this$getAddressState8;\n        const selectedAddress = address || this.state.selectedAddress;\n        return getHeaders(((_this$getAddressState8 = this.getAddressState(selectedAddress)) === null || _this$getAddressState8 === void 0 ? void 0 : _this$getAddressState8.jwtToken) || \"\", selectedAddress);\n    }\n}\n/**\n * The status of the transaction. Each status represents the state of the transaction internally\n * in the wallet. Some of these correspond with the state of the transaction on the network, but\n * some are wallet-specific.\n */ let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {\n    TransactionStatus[\"approved\"] = \"approved\";\n    TransactionStatus[\"cancelled\"] = \"cancelled\";\n    TransactionStatus[\"cancelling\"] = \"cancelling\";\n    TransactionStatus[\"confirmed\"] = \"confirmed\";\n    TransactionStatus[\"failed\"] = \"failed\";\n    TransactionStatus[\"finalized\"] = \"finalized\";\n    TransactionStatus[\"processed\"] = \"processed\";\n    TransactionStatus[\"rejected\"] = \"rejected\";\n    TransactionStatus[\"signed\"] = \"signed\";\n    TransactionStatus[\"submitted\"] = \"submitted\";\n    TransactionStatus[\"unapproved\"] = \"unapproved\";\n    TransactionStatus[\"dropped\"] = \"dropped\";\n    TransactionStatus[\"expired\"] = \"expired\";\n    TransactionStatus[\"pending\"] = \"pending\";\n    return TransactionStatus;\n}({});\nconst TRANSACTION_TYPES = {\n    CANCEL: \"cancel\",\n    RETRY: \"retry\",\n    CONTRACT_INTERACTION: \"contractInteraction\",\n    DEPLOY_CONTRACT: \"contractDeployment\",\n    WASM_BASED_DEPLOY: \"wasmBasedDeploy\",\n    STANDARD_TRANSACTION: \"transaction\",\n    STANDARD_PAYMENT_TRANSACTION: \"payment_transaction\",\n    // specific to chains like solana and casper\n    SENT_ETHER: \"sentEther\",\n    TOKEN_METHOD_TRANSFER: \"transfer\",\n    TOKEN_METHOD_TRANSFER_FROM: \"transferFrom\",\n    TOKEN_METHOD_APPROVE: \"approve\",\n    COLLECTIBLE_METHOD_SAFE_TRANSFER_FROM: \"safeTransferFrom\",\n    SET_APPROVAL_FOR_ALL: \"setApprovalForAll\"\n};\nconst TX_EVENTS = {\n    TX_WARNING: \"tx:warning\",\n    TX_ERROR: \"tx:error\",\n    TX_FAILED: \"tx:failed\",\n    TX_CONFIRMED: \"tx:confirmed\",\n    TX_DROPPED: \"tx:dropped\",\n    TX_EXPIRED: \"tx:expired\",\n    TX_STATUS_UPDATE: \"tx:status_update\",\n    TX_UNAPPROVED: \"tx:unapproved\",\n    TX_RETRY: \"tx:retry\",\n    TX_BLOCK_UPDATE: \"tx:block_update\"\n};\n/**\n * Transaction controller configuration\n */ /**\n * Transaction controller state\n */ /**\n * Result\n *\n * result - Promise resolving to a new transaction hash\n * transactionMeta - Meta information about this new transaction\n */ class BaseTransactionStateManager extends BaseController {\n    constructor({ config, state, getCurrentChainId }){\n        super({\n            config,\n            state\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"getCurrentChainId\", void 0);\n        this.defaultConfig = {\n            txHistoryLimit: 40\n        };\n        this.defaultState = {\n            transactions: {},\n            unapprovedTxs: {},\n            currentNetworkTxsList: []\n        };\n        this.initialize();\n        this.getCurrentChainId = getCurrentChainId;\n    }\n    getUnapprovedTxList() {\n        const chainId = this.getCurrentChainId();\n        return pickBy(this.state.transactions, (transaction)=>transaction.status === TransactionStatus.unapproved && transactionMatchesNetwork(transaction, chainId));\n    }\n    getTransaction(txId) {\n        const { transactions } = this.state;\n        return transactions[txId];\n    }\n    updateTransaction(txMeta) {\n        // commit txMeta to state\n        const txId = txMeta.id;\n        txMeta.updated_at = new Date().toISOString();\n        this.update({\n            transactions: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, this.state.transactions), {}, {\n                [txId]: txMeta\n            })\n        });\n    }\n    setTxStatusRejected(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.rejected);\n        this._deleteTransaction(txId);\n    }\n    /**\n   * The implementing controller can override this functionality and add custom logic + call super.()\n   */ setTxStatusUnapproved(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.unapproved);\n    }\n    setTxStatusApproved(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.approved);\n    }\n    setTxStatusSigned(txId, isFinalStep) {\n        this._setTransactionStatus(txId, TransactionStatus.signed, isFinalStep);\n    }\n    setTxStatusSubmitted(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.submitted);\n    }\n    setTxStatusDropped(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.dropped);\n    }\n    setTxStatusExpired(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.expired);\n    }\n    setTxStatusConfirmed(txId) {\n        this._setTransactionStatus(txId, TransactionStatus.confirmed);\n    }\n    setTxStatusFailed(txId, error_) {\n        const error = !error_ ? new Error(\"Internal torus failure\") : error_;\n        const txMeta = this.getTransaction(txId);\n        txMeta.error = error;\n        this.updateTransaction(txMeta);\n        this._setTransactionStatus(txId, TransactionStatus.failed);\n    }\n    /**\n   * Method to determine if the transaction is in a final state\n   * @param status - Transaction status\n   * @returns boolean if the transaction is in a final state\n   */ isFinalState(status) {\n        return status === TransactionStatus.rejected || status === TransactionStatus.submitted || status === TransactionStatus.confirmed || status === TransactionStatus.failed || status === TransactionStatus.cancelled || status === TransactionStatus.expired;\n    }\n    /**\n   * Filters out the unapproved transactions from state\n   */ clearUnapprovedTxs() {\n        this.update({\n            transactions: omitBy(this.state.transactions, (transaction)=>transaction.status === TransactionStatus.unapproved)\n        });\n    }\n    /**\n   * will append new transactions to old txns.\n   */ _addTransactionsToState(transactions) {\n        this.update({\n            transactions: transactions.reduce((result, newTx)=>{\n                result[newTx.id] = newTx;\n                return result;\n            }, this.state.transactions)\n        });\n    }\n    /**\n   * will set new txns, override existing if any in state.\n   */ _setTransactionsToState(transactions) {\n        this.update({\n            transactions: transactions.reduce((result, newTx)=>{\n                result[newTx.id] = newTx;\n                return result;\n            }, {})\n        });\n    }\n    _deleteTransaction(targetTransactionId) {\n        const { transactions } = this.state;\n        delete transactions[targetTransactionId];\n        this.update({\n            transactions\n        });\n    }\n    _deleteTransactions(targetTransactionIds) {\n        const { transactions } = this.state;\n        targetTransactionIds.forEach((transactionId)=>{\n            delete transactions[transactionId];\n        });\n        this.update({\n            transactions\n        });\n    }\n    _setTransactionStatus(txId, status, isFinalStep) {\n        const txMeta = this.getTransaction(txId);\n        if (!txMeta) {\n            return;\n        }\n        txMeta.status = status;\n        // only updating status so no validation required on txn.\n        this.updateTransaction(txMeta);\n        this.emit(TX_EVENTS.TX_STATUS_UPDATE, {\n            txId,\n            status\n        });\n        if (this.isFinalState(status) || isFinalStep) {\n            this.emit(`${txMeta.id}:finished`, txMeta);\n        } else {\n            this.emit(`${txMeta.id}:${status}`, txId);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9iYXNlLWNvbnRyb2xsZXJzL2Rpc3QvYmFzZUNvbnRyb2xsZXJzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTtBQUNHO0FBQ3NHO0FBQ2xHO0FBQzdDO0FBQ3FJO0FBQzFHO0FBQ2pCO0FBQzJCO0FBQ3BDO0FBQ1c7QUFFdkM7O0NBRUMsR0FDRCxNQUFNNkIsdUJBQXVCM0IsdUVBQWdCQTtJQUMzQzs7Ozs7O0dBTUMsR0FDRDRCLFlBQVksRUFDVkMsU0FBUyxDQUFDLENBQUMsRUFDWEMsUUFBUSxDQUFDLENBQUMsRUFDWCxDQUFFO1FBQ0QsS0FBSztRQUNMLGtFQUFrRTtRQUNsRTs7S0FFQyxHQUNEL0IsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGlCQUFpQixDQUFDO1FBQ3hDOztLQUVDLEdBQ0RBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxnQkFBZ0IsQ0FBQztRQUN2Qzs7S0FFQyxHQUNEQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsWUFBWTtRQUNsQzs7S0FFQyxHQUNEQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsUUFBUTtRQUM5QkEsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGlCQUFpQixLQUFLO1FBQzVDQSw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLEtBQUs7UUFDM0NBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxrQkFBa0IsSUFBSSxDQUFDZ0MsYUFBYTtRQUMxRGhDLDRFQUFlQSxDQUFDLElBQUksRUFBRSxpQkFBaUIsSUFBSSxDQUFDaUMsWUFBWTtRQUN4RCxJQUFJLENBQUNDLFlBQVksR0FBR0g7UUFDcEIsSUFBSSxDQUFDSSxhQUFhLEdBQUdMO0lBQ3ZCO0lBRUE7Ozs7R0FJQyxHQUNELElB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eUMsY0FBYztRQUNwQztRQUNBLElBQUksQ0FBQ3p4QixNQUFNLENBQUM7WUFDVmd2QjtRQUNGO0lBQ0Y7SUFDQVksc0JBQXNCTixJQUFJLEVBQUV4VSxNQUFNLEVBQUVxVixXQUFXLEVBQUU7UUFDL0MsTUFBTVgsU0FBUyxJQUFJLENBQUNILGNBQWMsQ0FBQ0M7UUFDbkMsSUFBSSxDQUFDRSxRQUFRO1lBQ1g7UUFDRjtRQUNBQSxPQUFPMVUsTUFBTSxHQUFHQTtRQUNoQix5REFBeUQ7UUFDekQsSUFBSSxDQUFDeVUsaUJBQWlCLENBQUNDO1FBQ3ZCLElBQUksQ0FBQ3Z2QixJQUFJLENBQUNpdUIsVUFBVU8sZ0JBQWdCLEVBQUU7WUFDcENhO1lBQ0F4VTtRQUNGO1FBQ0EsSUFBSSxJQUFJLENBQUNrVyxZQUFZLENBQUNsVyxXQUFXcVYsYUFBYTtZQUM1QyxJQUFJLENBQUNsd0IsSUFBSSxDQUFDLENBQUMsRUFBRXV2QixPQUFPblQsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFbVQ7UUFDckMsT0FBTztZQUNMLElBQUksQ0FBQ3Z2QixJQUFJLENBQUMsQ0FBQyxFQUFFdXZCLE9BQU9uVCxFQUFFLENBQUMsQ0FBQyxFQUFFdkIsT0FBTyxDQUFDLEVBQUV3VTtRQUN0QztJQUNGO0FBQ0Y7QUFFdWtFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29sLXBvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9iYXNlLWNvbnRyb2xsZXJzL2Rpc3QvYmFzZUNvbnRyb2xsZXJzLmVzbS5qcz9kOTRiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMic7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknO1xuaW1wb3J0IHsgU2FmZUV2ZW50RW1pdHRlciwgY3JlYXRlQXN5bmNNaWRkbGV3YXJlLCBtZXJnZU1pZGRsZXdhcmUsIGNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSwgSlJQQ0VuZ2luZSwgcHJvdmlkZXJGcm9tRW5naW5lLCBycGNFcnJvcnMgfSBmcm9tICdAdG9ydXNsYWJzL29wZW5sb2dpbi1qcnBjJztcbmltcG9ydCB7IHBvc3QsIGdldCwgcHV0LCBwYXRjaCwgcmVtb3ZlIH0gZnJvbSAnQHRvcnVzbGFicy9odHRwLWhlbHBlcnMnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgeyBmcm9tU2lnbmVkLCBieXRlc1RvQmlnSW50LCB0b1Vuc2lnbmVkLCBzdHJpcEhleFByZWZpeCwgYmlnSW50VG9IZXgsIGFkZEhleFByZWZpeCwgaGFzaFBlcnNvbmFsTWVzc2FnZSwgZWNzaWduLCBiaWdJbnRUb0J5dGVzIH0gZnJvbSAnQGV0aGVyZXVtanMvdXRpbCc7XG5pbXBvcnQgeyBzYWZlYXRvYiB9IGZyb20gJ0B0b3J1c2xhYnMvb3BlbmxvZ2luLXV0aWxzJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IEJyb2FkY2FzdENoYW5uZWwgfSBmcm9tICdAdG9ydXNsYWJzL2Jyb2FkY2FzdC1jaGFubmVsJztcbmltcG9ydCBib3dzZXIgZnJvbSAnYm93c2VyJztcbmltcG9ydCB7IGp3dERlY29kZSB9IGZyb20gJ2p3dC1kZWNvZGUnO1xuXG4vKipcbiAqIENvbnRyb2xsZXIgY2xhc3MgdGhhdCBwcm92aWRlcyBjb25maWd1cmF0aW9uLCBzdGF0ZSBtYW5hZ2VtZW50LCBhbmQgc3Vic2NyaXB0aW9uc1xuICovXG5jbGFzcyBCYXNlQ29udHJvbGxlciBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIEJhc2VDb250cm9sbGVyIGluc3RhbmNlLiBCb3RoIGluaXRpYWwgc3RhdGUgYW5kIGluaXRpYWxcbiAgICogY29uZmlndXJhdGlvbiBvcHRpb25zIGFyZSBtZXJnZWQgd2l0aCBkZWZhdWx0cyB1cG9uIGluaXRpYWxpemF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb25maWcgPSB7fSxcbiAgICBzdGF0ZSA9IHt9XG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIC8vIFVzZSBhc3NpZ24gc2luY2UgZ2VuZXJpY3MgY2FuJ3QgYmUgc3ByZWFkOiBodHRwczovL2dpdC5pby92cFJoWVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0Q29uZmlnXCIsIHt9KTtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHN0YXRlIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0U3RhdGVcIiwge30pO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgbGlzdGVuZXJzIGFyZSBub3RpZmllZCBvZiBzdGF0ZSBjaGFuZ2VzXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCBcIkJhc2VDb250cm9sbGVyXCIpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaXRpYWxDb25maWdcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbml0aWFsU3RhdGVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnRlcm5hbENvbmZpZ1wiLCB0aGlzLmRlZmF1bHRDb25maWcpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImludGVybmFsU3RhdGVcIiwgdGhpcy5kZWZhdWx0U3RhdGUpO1xuICAgIHRoaXMuaW5pdGlhbFN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5pbml0aWFsQ29uZmlnID0gY29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBjdXJyZW50IGNvbnRyb2xsZXIgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIC0gQ3VycmVudCBjb25maWd1cmF0aW9uXG4gICAqL1xuICBnZXQgY29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLmludGVybmFsQ29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBjdXJyZW50IGNvbnRyb2xsZXIgc3RhdGVcbiAgICpcbiAgICogQHJldHVybnMgLSBDdXJyZW50IHN0YXRlXG4gICAqL1xuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbnRyb2xsZXIgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAcGFyYW0gY29uZmlnIC0gTmV3IGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3ZlcndyaXRlIC0gT3ZlcndyaXRlIGNvbmZpZyBpbnN0ZWFkIG9mIG1lcmdpbmdcbiAgICogQHBhcmFtIGZ1bGxVcGRhdGUgLSBCb29sZWFuIHRoYXQgZGVmaW5lcyBpZiB0aGUgdXBkYXRlIGlzIHBhcnRpYWwgb3Igbm90XG4gICAqL1xuICBjb25maWd1cmUoY29uZmlnLCBvdmVyd3JpdGUgPSBmYWxzZSwgZnVsbFVwZGF0ZSA9IHRydWUpIHtcbiAgICBpZiAoZnVsbFVwZGF0ZSkge1xuICAgICAgdGhpcy5pbnRlcm5hbENvbmZpZyA9IG92ZXJ3cml0ZSA/IGNvbmZpZyA6IE9iamVjdC5hc3NpZ24odGhpcy5pbnRlcm5hbENvbmZpZywgY29uZmlnKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuaW50ZXJuYWxDb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmludGVybmFsQ29uZmlnW2tleV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgIHRoaXNba2V5XSA9IHRoaXMuaW50ZXJuYWxDb25maWdba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb25maWcpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmludGVybmFsQ29uZmlnW2tleV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aGlzLmludGVybmFsQ29uZmlnW2tleV0gPSBjb25maWdba2V5XTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgIHRoaXNba2V5XSA9IGNvbmZpZ1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgY29udHJvbGxlciBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGUgLSBOZXcgc3RhdGVcbiAgICogQHBhcmFtIG92ZXJ3cml0ZSAtIE92ZXJ3cml0ZSBzdGF0ZSBpbnN0ZWFkIG9mIG1lcmdpbmdcbiAgICovXG4gIHVwZGF0ZShzdGF0ZSwgb3ZlcndyaXRlID0gZmFsc2UpIHtcbiAgICB0aGlzLmludGVybmFsU3RhdGUgPSBvdmVyd3JpdGUgPyBfb2JqZWN0U3ByZWFkKHt9LCBzdGF0ZSkgOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMuaW50ZXJuYWxTdGF0ZSksIHN0YXRlKTtcbiAgICB0aGlzLmVtaXQoXCJzdG9yZVwiLCB0aGlzLmludGVybmFsU3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgdGhlIGNvbnRyb2xsZXIuIFRoaXMgc2V0cyBlYWNoIGNvbmZpZyBvcHRpb24gYXMgYSBtZW1iZXJcbiAgICogdmFyaWFibGUgb24gdGhpcyBpbnN0YW5jZSBhbmQgdHJpZ2dlcnMgYW55IGRlZmluZWQgc2V0dGVycy4gVGhpc1xuICAgKiBhbHNvIHNldHMgaW5pdGlhbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgYW55IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHJldHVybnMgLSBUaGlzIGNvbnRyb2xsZXIgaW5zdGFuY2VcbiAgICovXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gdGhpcy5kZWZhdWx0U3RhdGU7XG4gICAgdGhpcy5pbnRlcm5hbENvbmZpZyA9IHRoaXMuZGVmYXVsdENvbmZpZztcbiAgICB0aGlzLmNvbmZpZ3VyZSh0aGlzLmluaXRpYWxDb25maWcpO1xuICAgIHRoaXMudXBkYXRlKHRoaXMuaW5pdGlhbFN0YXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5jb25zdCBzZWMgPSAxMDAwO1xuY29uc3QgY2FsY3VsYXRlU3VtID0gKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlO1xuY29uc3QgYmxvY2tUcmFja2VyRXZlbnRzID0gW1wic3luY1wiLCBcImxhdGVzdFwiXTtcbmNsYXNzIEJhc2VCbG9ja1RyYWNrZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb25maWcgPSB7fSxcbiAgICBzdGF0ZSA9IHt9XG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuXG4gICAgLy8gY29uZmlnXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCBcIkJhc2VCbG9ja1RyYWNrZXJcIik7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2Jsb2NrUmVzZXRUaW1lb3V0XCIsIHZvaWQgMCk7XG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICBfY3VycmVudEJsb2NrOiB7XG4gICAgICAgIGlkZW1wb3RlbmN5S2V5OiBcIlwiXG4gICAgICB9LFxuICAgICAgX2lzUnVubmluZzogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgIGJsb2NrUmVzZXREdXJhdGlvbjogMjAgKiBzZWNcbiAgICB9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuXG4gICAgLy8gYmluZCBmdW5jdGlvbnMgZm9yIGludGVybmFsIHVzZVxuICAgIHRoaXMuX29uTmV3TGlzdGVuZXIgPSB0aGlzLl9vbk5ld0xpc3RlbmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lciA9IHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9yZXNldEN1cnJlbnRCbG9jayA9IHRoaXMuX3Jlc2V0Q3VycmVudEJsb2NrLmJpbmQodGhpcyk7XG5cbiAgICAvLyBsaXN0ZW4gZm9yIGhhbmRsZXIgY2hhbmdlc1xuICAgIHRoaXMuX3NldHVwSW50ZXJuYWxFdmVudHMoKTtcbiAgfVxuICBpc1J1bm5pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuX2lzUnVubmluZztcbiAgfVxuICBnZXRDdXJyZW50QmxvY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuX2N1cnJlbnRCbG9jaztcbiAgfVxuICBhc3luYyBnZXRMYXRlc3RCbG9jaygpIHtcbiAgICAvLyByZXR1cm4gaWYgYXZhaWxhYmxlXG4gICAgaWYgKHRoaXMuc3RhdGUuX2N1cnJlbnRCbG9jay5pZGVtcG90ZW5jeUtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuX2N1cnJlbnRCbG9jaztcbiAgICB9XG4gICAgLy8gd2FpdCBmb3IgYSBuZXcgbGF0ZXN0IGJsb2NrXG4gICAgY29uc3QgbGF0ZXN0QmxvY2sgPSBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMub25jZShcImxhdGVzdFwiLCBibG9jayA9PiB7XG4gICAgICAgIGlmIChibG9jaykge1xuICAgICAgICAgIHJlc29sdmUoYmxvY2spO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyByZXR1cm4gbmV3bHkgc2V0IGN1cnJlbnQgYmxvY2tcbiAgICByZXR1cm4gbGF0ZXN0QmxvY2s7XG4gIH1cblxuICAvLyBkb250IGFsbG93IG1vZHVsZSBjb25zdW1lciB0byByZW1vdmUgb3VyIGludGVybmFsIGV2ZW50IGxpc3RlbmVyc1xuICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvLyByZS1hZGQgaW50ZXJuYWwgZXZlbnRzXG4gICAgdGhpcy5fc2V0dXBJbnRlcm5hbEV2ZW50cygpO1xuICAgIC8vIHRyaWdnZXIgc3RvcCBjaGVjayBqdXN0IGluIGNhc2VcbiAgICB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVG8gYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3MuXG4gICAqL1xuICBfc3RhcnQoKSB7XG4gICAgLy8gZGVmYXVsdCBiZWhhdmlvciBpcyBub29wXG4gIH1cblxuICAvKipcbiAgICogVG8gYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3MuXG4gICAqL1xuICBfZW5kKCkge1xuICAgIC8vIGRlZmF1bHQgYmVoYXZpb3IgaXMgbm9vcFxuICB9XG4gIF9uZXdQb3RlbnRpYWxMYXRlc3QobmV3QmxvY2spIHtcbiAgICBjb25zdCBjdXJyZW50QmxvY2sgPSB0aGlzLnN0YXRlLl9jdXJyZW50QmxvY2s7XG4gICAgLy8gb25seSB1cGRhdGUgaWYgYmxvY2sgbnVtYmVyIGlzIGhpZ2hlclxuICAgIGlmIChjdXJyZW50QmxvY2sgJiYgbmV3QmxvY2suaWRlbXBvdGVuY3lLZXkgPT09IGN1cnJlbnRCbG9jay5pZGVtcG90ZW5jeUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zZXRDdXJyZW50QmxvY2sobmV3QmxvY2spO1xuICB9XG4gIF9zZXR1cEludGVybmFsRXZlbnRzKCkge1xuICAgIC8vIGZpcnN0IHJlbW92ZSBsaXN0ZW5lcnMgZm9yIGlkZW1wb3RlbmN5XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcIm5ld0xpc3RlbmVyXCIsIHRoaXMuX29uTmV3TGlzdGVuZXIpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJyZW1vdmVMaXN0ZW5lclwiLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKTtcbiAgICAvLyB0aGVuIGFkZCB0aGVtXG4gICAgdGhpcy5vbihcInJlbW92ZUxpc3RlbmVyXCIsIHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIpO1xuICAgIHRoaXMub24oXCJuZXdMaXN0ZW5lclwiLCB0aGlzLl9vbk5ld0xpc3RlbmVyKTtcbiAgfVxuICBfb25OZXdMaXN0ZW5lcigpIHtcbiAgICB0aGlzLl9tYXliZVN0YXJ0KCk7XG4gIH1cbiAgX29uUmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgLy8gYHJlbW92ZUxpc3RlbmVyYCBpcyBjYWxsZWQgKmFmdGVyKiB0aGUgbGlzdGVuZXIgaXMgcmVtb3ZlZFxuICAgIGlmICh0aGlzLl9nZXRCbG9ja1RyYWNrZXJFdmVudENvdW50KCkgPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21heWJlRW5kKCk7XG4gIH1cbiAgX21heWJlU3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuX2lzUnVubmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLl9pc1J1bm5pbmcgPSB0cnVlO1xuICAgIC8vIGNhbmNlbCBzZXR0aW5nIGxhdGVzdCBibG9jayB0byBzdGFsZVxuICAgIHRoaXMuX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgdGhpcy5fc3RhcnQoKTtcbiAgfVxuICBfbWF5YmVFbmQoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fc2V0dXBCbG9ja1Jlc2V0VGltZW91dCgpO1xuICAgIHRoaXMuX2VuZCgpO1xuICB9XG4gIF9nZXRCbG9ja1RyYWNrZXJFdmVudENvdW50KCkge1xuICAgIHJldHVybiBibG9ja1RyYWNrZXJFdmVudHMubWFwKGV2ZW50TmFtZSA9PiB0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSkucmVkdWNlKGNhbGN1bGF0ZVN1bSk7XG4gIH1cbiAgX3NldEN1cnJlbnRCbG9jayhuZXdCbG9jaykge1xuICAgIGNvbnN0IG9sZEJsb2NrID0gdGhpcy5zdGF0ZS5fY3VycmVudEJsb2NrO1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIF9jdXJyZW50QmxvY2s6IG5ld0Jsb2NrXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFwibGF0ZXN0XCIsIG5ld0Jsb2NrKTtcbiAgICB0aGlzLmVtaXQoXCJzeW5jXCIsIHtcbiAgICAgIG9sZEJsb2NrLFxuICAgICAgbmV3QmxvY2tcbiAgICB9KTtcbiAgfVxuICBfc2V0dXBCbG9ja1Jlc2V0VGltZW91dCgpIHtcbiAgICAvLyBjbGVhciBhbnkgZXhpc3RpbmcgdGltZW91dFxuICAgIHRoaXMuX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0KCk7XG4gICAgLy8gY2xlYXIgbGF0ZXN0IGJsb2NrIHdoZW4gc3RhbGVcbiAgICB0aGlzLl9ibG9ja1Jlc2V0VGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5fcmVzZXRDdXJyZW50QmxvY2ssIHRoaXMuY29uZmlnLmJsb2NrUmVzZXREdXJhdGlvbik7XG5cbiAgICAvLyBub2RlanMgLSBkb250IGhvbGQgcHJvY2VzcyBvcGVuXG4gICAgaWYgKHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0LnVucmVmKSB7XG4gICAgICB0aGlzLl9ibG9ja1Jlc2V0VGltZW91dC51bnJlZigpO1xuICAgIH1cbiAgfVxuICBfY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fYmxvY2tSZXNldFRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBfcmVzZXRDdXJyZW50QmxvY2soKSB7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgX2N1cnJlbnRCbG9jazoge1xuICAgICAgICBpZGVtcG90ZW5jeUtleTogXCJcIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IGZpbHRlck5vb3AgPSAoKSA9PiB0cnVlO1xuY29uc3QgaW50ZXJuYWxFdmVudHMgPSBbXCJuZXdMaXN0ZW5lclwiLCBcInJlbW92ZUxpc3RlbmVyXCJdO1xuY29uc3QgZXh0ZXJuYWxFdmVudEZpbHRlciA9IG5hbWUgPT4gIWludGVybmFsRXZlbnRzLmluY2x1ZGVzKG5hbWUpO1xuZnVuY3Rpb24gZ2V0UmF3TGlzdGVuZXJzKGV2ZW50RW1pdHRlciwgbmFtZSkge1xuICAvLyBwcmVmZXIgbmF0aXZlXG4gIHJldHVybiB0eXBlb2YgZXZlbnRFbWl0dGVyLnJhd0xpc3RlbmVycyAhPT0gXCJ1bmRlZmluZWRcIiA/IGV2ZW50RW1pdHRlci5yYXdMaXN0ZW5lcnMobmFtZSkgOiBldmVudEVtaXR0ZXIubGlzdGVuZXJzKG5hbWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnRFbWl0dGVyUHJveHkoaW5pdGlhbFRhcmdldCwgb3B0cykge1xuICAvLyBwYXJzZSBvcHRpb25zXG4gIGNvbnN0IGZpbmFsT3B0cyA9IG9wdHMgfHwge307XG4gIGxldCBldmVudEZpbHRlciA9IGZpbmFsT3B0cy5ldmVudEZpbHRlciB8fCBmaWx0ZXJOb29wO1xuICBpZiAodHlwZW9mIGV2ZW50RmlsdGVyID09PSBcInN0cmluZ1wiICYmIGV2ZW50RmlsdGVyID09PSBcInNraXBJbnRlcm5hbFwiKSBldmVudEZpbHRlciA9IGV4dGVybmFsRXZlbnRGaWx0ZXI7XG4gIGlmICh0eXBlb2YgZXZlbnRGaWx0ZXIgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiY3JlYXRlRXZlbnRFbWl0dGVyUHJveHkgLSBJbnZhbGlkIGV2ZW50RmlsdGVyXCIpO1xuICBsZXQgdGFyZ2V0ID0gaW5pdGlhbFRhcmdldDtcbiAgbGV0IHNldFRhcmdldCA9IG5ld1RhcmdldCA9PiB7XG4gICAgY29uc3Qgb2xkVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRhcmdldCA9IG5ld1RhcmdldDtcbiAgICBvbGRUYXJnZXQuZXZlbnROYW1lcygpLmZpbHRlcihldmVudEZpbHRlcikuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGdldFJhd0xpc3RlbmVycyhvbGRUYXJnZXQsIG5hbWUpLmZvckVhY2goaGFuZGxlciA9PiB7XG4gICAgICAgIG5ld1RhcmdldC5vbihuYW1lLCBoYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIG9sZCBsaXN0ZW5lcnNcbiAgICBvbGRUYXJnZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH07XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0OiAoXywgbmFtZSkgPT4ge1xuICAgICAgLy8gb3ZlcnJpZGUgYHNldFRhcmdldGAgYWNjZXNzXG4gICAgICBpZiAobmFtZSA9PT0gXCJzZXRUYXJnZXRcIikgcmV0dXJuIHNldFRhcmdldDtcbiAgICAgIHJldHVybiB0YXJnZXRbbmFtZV07XG4gICAgfSxcbiAgICBzZXQ6IChfLCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgLy8gYWxsb3cgYHNldFRhcmdldGAgb3ZlcnJpZGVzXG4gICAgICBpZiAobmFtZSA9PT0gXCJzZXRUYXJnZXRcIikge1xuICAgICAgICBzZXRUYXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcm94eTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3dhcHBhYmxlUHJveHkoaW5pdGlhbFRhcmdldCkge1xuICBsZXQgdGFyZ2V0ID0gaW5pdGlhbFRhcmdldDtcbiAgbGV0IHNldFRhcmdldCA9IG5ld1RhcmdldCA9PiB7XG4gICAgdGFyZ2V0ID0gbmV3VGFyZ2V0O1xuICB9O1xuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh7fSwge1xuICAgIGdldDogKF8sIG5hbWUpID0+IHtcbiAgICAgIC8vIG92ZXJyaWRlIGBzZXRUYXJnZXRgIGFjY2Vzc1xuICAgICAgaWYgKG5hbWUgPT09IFwic2V0VGFyZ2V0XCIpIHJldHVybiBzZXRUYXJnZXQ7XG4gICAgICByZXR1cm4gdGFyZ2V0W25hbWVdO1xuICAgIH0sXG4gICAgc2V0OiAoXywgbmFtZSwgdmFsdWUpID0+IHtcbiAgICAgIC8vIGFsbG93IGBzZXRUYXJnZXRgIG92ZXJyaWRlc1xuICAgICAgaWYgKG5hbWUgPT09IFwic2V0VGFyZ2V0XCIpIHtcbiAgICAgICAgc2V0VGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcHJveHk7XG59XG5cbi8vIGV2ZXJ5IHRlbiBtaW51dGVzXG5jb25zdCBQT0xMSU5HX0lOVEVSVkFMID0gNjAwMDAwO1xuY2xhc3MgQmFzZUN1cnJlbmN5Q29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbmZpZyA9IHt9LFxuICAgIHN0YXRlXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgY3VycmVudEN1cnJlbmN5OiBcInVzZFwiLFxuICAgICAgY29udmVyc2lvblJhdGU6IDAsXG4gICAgICBjb252ZXJzaW9uRGF0ZTogXCJOL0FcIixcbiAgICAgIG5hdGl2ZUN1cnJlbmN5OiBcIkVUSFwiXG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICBwb2xsSW50ZXJ2YWw6IFBPTExJTkdfSU5URVJWQUxcbiAgICB9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gUFVCTElDIE1FVEhPRFNcbiAgLy9cblxuICBnZXROYXRpdmVDdXJyZW5jeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5uYXRpdmVDdXJyZW5jeTtcbiAgfVxuICBzZXROYXRpdmVDdXJyZW5jeShuYXRpdmVDdXJyZW5jeSkge1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIG5hdGl2ZUN1cnJlbmN5LFxuICAgICAgdGlja2VyOiBuYXRpdmVDdXJyZW5jeVxuICAgIH0pO1xuICB9XG4gIGdldEN1cnJlbnRDdXJyZW5jeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50Q3VycmVuY3k7XG4gIH1cbiAgc2V0Q3VycmVudEN1cnJlbmN5KGN1cnJlbnRDdXJyZW5jeSkge1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIGN1cnJlbnRDdXJyZW5jeVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIGZvciB0aGUgY29udmVyc2lvblJhdGUgcHJvcGVydHlcbiAgICpcbiAgICogQHJldHVybnMgVGhlIGNvbnZlcnNpb24gcmF0ZSBmcm9tIEVUSCB0byB0aGUgc2VsZWN0ZWQgY3VycmVuY3kuXG4gICAqXG4gICAqL1xuICBnZXRDb252ZXJzaW9uUmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb252ZXJzaW9uUmF0ZTtcbiAgfVxuICBzZXRDb252ZXJzaW9uUmF0ZShjb252ZXJzaW9uUmF0ZSkge1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIGNvbnZlcnNpb25SYXRlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBnZXR0ZXIgZm9yIHRoZSBjb252ZXJzaW9uRGF0ZSBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgZGF0ZSBhdCB3aGljaCB0aGUgY29udmVyc2lvbiByYXRlIHdhcyBzZXQuIEV4cHJlc3NlZCBpbiBtaWxsaXNlY29uZHMgc2luY2UgbWlkbmlnaHQgb2ZcbiAgICogSmFudWFyeSAxLCAxOTcwXG4gICAqXG4gICAqL1xuICBnZXRDb252ZXJzaW9uRGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb252ZXJzaW9uRGF0ZTtcbiAgfVxuICBzZXRDb252ZXJzaW9uRGF0ZShjb252ZXJzaW9uRGF0ZSkge1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIGNvbnZlcnNpb25EYXRlXG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgRkVBVFVSRVNfUFJPVklERVJfQ0hBTkdFX1dJTkRPVyA9IHtcbiAgaGVpZ2h0OiA2NjAsXG4gIHdpZHRoOiAzNzVcbn07XG5jb25zdCBGRUFUVVJFU19ERUZBVUxUX1dBTExFVF9XSU5ET1cgPSB7XG4gIGhlaWdodDogNzQwLFxuICB3aWR0aDogMTMxNVxufTtcbmNvbnN0IEZFQVRVUkVTX0RFRkFVTFRfUE9QVVBfV0lORE9XID0ge1xuICBoZWlnaHQ6IDcwMCxcbiAgd2lkdGg6IDEyMDBcbn07XG5jb25zdCBGRUFUVVJFU19DT05GSVJNX1dJTkRPVyA9IHtcbiAgaGVpZ2h0OiA3MDAsXG4gIHdpZHRoOiA0NTBcbn07XG5jb25zdCBQT1BVUF9MT0FERUQgPSBcInBvcHVwX2xvYWRlZFwiO1xuY29uc3QgUE9QVVBfUkVTVUxUID0gXCJwb3B1cF9yZXN1bHRcIjtcbmNvbnN0IFNFVFVQX0NPTVBMRVRFID0gXCJzZXR1cF9jb21wbGV0ZVwiO1xuY29uc3QgQUNUSVZJVFlfQUNUSU9OX0FMTCA9IFwid2FsbGV0QWN0aXZpdHkuYWxsVHJhbnNhY3Rpb25zXCI7XG5jb25zdCBBQ1RJVklUWV9BQ1RJT05fU0VORCA9IFwid2FsbGV0QWN0aXZpdHkuc2VuZFwiO1xuY29uc3QgQUNUSVZJVFlfQUNUSU9OX0JVUk4gPSBcIndhbGxldEFjdGl2aXR5LmJ1cm5cIjtcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9SRUNFSVZFID0gXCJ3YWxsZXRBY3Rpdml0eS5yZWNlaXZlXCI7XG5jb25zdCBBQ1RJVklUWV9BQ1RJT05fVE9QVVAgPSBcIndhbGxldEFjdGl2aXR5LnRvcHVwXCI7XG5jb25zdCBBQ1RJVklUWV9BQ1RJT05fQ1JFQVRFX1RSVVNUTElORSA9IFwid2FsbGV0QWN0aXZpdHkuY3JlYXRlVHJ1c3RsaW5lXCI7XG5jb25zdCBBQ1RJVklUWV9BQ1RJT05fUkVNT1ZFX1RSVVNUTElORSA9IFwid2FsbGV0QWN0aXZpdHkucmVtb3ZlVHJ1c3RsaW5lXCI7XG5jb25zdCBBQ1RJVklUWV9BQ1RJT05fQ1JFQVRFX05GVF9PRkZFUiA9IFwid2FsbGV0QWN0aXZpdHkuY3JlYXRlTmZ0T2ZmZXJcIjtcbmNvbnN0IEFDVElWSVRZX0FDVElPTl9BQ0NFUFRfTkZUX09GRkVSID0gXCJ3YWxsZXRBY3Rpdml0eS5hY2NlcHROZnRPZmZlclwiO1xuY29uc3QgQUNUSVZJVFlfQUNUSU9OX0NBTkNFTF9ORlRfT0ZGRVIgPSBcIndhbGxldEFjdGl2aXR5LmNhbmNlbE5mdE9mZmVyXCI7XG5jb25zdCBBQ1RJVklUWV9QRVJJT0RfQUxMID0gXCJ3YWxsZXRBY3Rpdml0eS5hbGxcIjtcbmNvbnN0IEFDVElWSVRZX1BFUklPRF9XRUVLX09ORSA9IFwid2FsbGV0QWN0aXZpdHkubGFzdE9uZVdlZWtcIjtcbmNvbnN0IEFDVElWSVRZX1BFUklPRF9NT05USF9PTkUgPSBcIndhbGxldEFjdGl2aXR5Lmxhc3RPbmVNb250aFwiO1xuY29uc3QgQUNUSVZJVFlfUEVSSU9EX01PTlRIX1NJWCA9IFwid2FsbGV0QWN0aXZpdHkubGFzdFNpeE1vbnRzXCI7XG5jb25zdCBBQ1RJVklUWV9TVEFUVVNfU1VDQ0VTU0ZVTCA9IFwid2FsbGV0QWN0aXZpdHkuc3VjY2Vzc2Z1bFwiO1xuY29uc3QgQUNUSVZJVFlfU1RBVFVTX1VOU1VDQ0VTU0ZVTCA9IFwid2FsbGV0QWN0aXZpdHkudW5zdWNjZXNzZnVsXCI7XG5jb25zdCBBQ1RJVklUWV9TVEFUVVNfUEVORElORyA9IFwid2FsbGV0QWN0aXZpdHkucGVuZGluZ1wiO1xuY29uc3QgQUNUSVZJVFlfU1RBVFVTX0NBTkNFTExFRCA9IFwid2FsbGV0QWN0aXZpdHkuY2FuY2VsbGVkXCI7XG5jb25zdCBBQ1RJVklUWV9TVEFUVVNfQ0FOQ0VMTElORyA9IFwid2FsbGV0QWN0aXZpdHkuY2FuY2VsbGluZ1wiO1xuY29uc3QgQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TID0ge1xuICBJRlJBTUVfU1RBVFVTOiBcImlmcmFtZV9zdGF0dXNcIixcbiAgLy8gVGVsbCBlbWJlZCB0byBjbG9zZSB0aGUgd2luZG93XG4gIENMT1NFX1dJTkRPVzogXCJjbG9zZV93aW5kb3dcIixcbiAgVVNFUl9MT0dHRURfSU46IFwidXNlcl9sb2dnZWRfaW5cIixcbiAgVVNFUl9MT0dHRURfT1VUOiBcInVzZXJfbG9nZ2VkX291dFwiXG59O1xuY29uc3QgQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMgPSB7XG4gIExPR09VVDogXCJsb2dvdXRcIixcbiAgV0FMTEVUX0lOU1RBTkNFX0lEOiBcIndhbGxldF9pbnN0YW5jZV9pZFwiLFxuICBVU0VSX0lORk86IFwidXNlcl9pbmZvXCIsXG4gIFNFVF9QUk9WSURFUjogXCJzZXRfcHJvdmlkZXJcIixcbiAgVE9QVVA6IFwidG9wdXBcIixcbiAgSUZSQU1FX1NUQVRVUzogXCJpZnJhbWVfc3RhdHVzXCIsXG4gIC8vIHVzZXIgaGFzIGNsb3NlZCB0aGUgd2luZG93IGZyb20gZW1iZWQncyBzaWRlXG4gIENMT1NFRF9XSU5ET1c6IFwiY2xvc2VkX3dpbmRvd1wiLFxuICBXSU5ET1dfQkxPQ0tFRDogXCJ3aW5kb3dfYmxvY2tlZFwiLFxuICBHRVRfUFJPVklERVJfU1RBVEU6IFwiZ2V0X3Byb3ZpZGVyX3N0YXRlXCIsXG4gIExPR0lOX1dJVEhfUFJJVkFURV9LRVk6IFwibG9naW5fd2l0aF9wcml2YXRlX2tleVwiLFxuICBTSE9XX1dBTExFVF9DT05ORUNUOiBcInNob3dfd2FsbGV0X2Nvbm5lY3RcIixcbiAgU0hPV19DSEVDS09VVDogXCJzaG93X2NoZWNrb3V0XCIsXG4gIFNIT1dfV0FMTEVUX1VJOiBcInNob3dfd2FsbGV0X3VpXCIsXG4gIExPR0lOX1dJVEhfU0VTU0lPTl9JRDogXCJsb2dpbl93aXRoX3Nlc3Npb25faWRcIlxufTtcbmNvbnN0IFBST1ZJREVSX0pSUENfTUVUSE9EUyA9IHtcbiAgR0VUX1BST1ZJREVSX1NUQVRFOiBcIndhbGxldF9nZXRfcHJvdmlkZXJfc3RhdGVcIlxufTtcbmNvbnN0IFBST1ZJREVSX05PVElGSUNBVElPTlMgPSB7XG4gIEFDQ09VTlRTX0NIQU5HRUQ6IFwid2FsbGV0X2FjY291bnRzX2NoYW5nZWRcIixcbiAgQ0hBSU5fQ0hBTkdFRDogXCJ3YWxsZXRfY2hhaW5fY2hhbmdlZFwiLFxuICBVTkxPQ0tfU1RBVEVfQ0hBTkdFRDogXCJ3YWxsZXRfdW5sb2NrX3N0YXRlX2NoYW5nZWRcIlxufTtcbmNvbnN0IEJST0FEQ0FTVF9DSEFOTkVMUyA9IHtcbiAgUkVESVJFQ1RfQ0hBTk5FTDogXCJyZWRpcmVjdF9jaGFubmVsXCIsXG4gIFBST1ZJREVSX0NIQU5HRV9DSEFOTkVMOiBcInRvcnVzX3Byb3ZpZGVyX2NoYW5nZV9jaGFubmVsXCIsXG4gIFRSQU5TQUNUSU9OX0NIQU5ORUw6IFwidG9ydXNfY2hhbm5lbFwiLFxuICBNRVNTQUdFX0NIQU5ORUw6IFwidG9ydXNfbWVzc2FnZV9jaGFubmVsXCIsXG4gIFdBTExFVF9MT0dPVVRfQ0hBTk5FTDogXCJ3YWxsZXRfbG9nb3V0X2NoYW5uZWxcIixcbiAgV0FMTEVUX1NFTEVDVEVEX0FERFJFU1NfQ0hBTk5FTDogXCJ3YWxsZXRfc2VsZWN0ZWRfYWRkcmVzc19jaGFubmVsXCIsXG4gIFdBTExFVF9ORVRXT1JLX0NIQU5HRV9DSEFOTkVMOiBcIndhbGxldF9uZXR3b3JrX2NoYW5nZV9jaGFubmVsXCIsXG4gIFdBTExFVF9BQ0NPVU5UX0lNUE9SVF9DSEFOTkVMOiBcIndhbGxldF9hY2NvdW50X2ltcG9ydF9jaGFubmVsXCIsXG4gIFRIRU1FX0NIQU5HRTogXCJ0aGVtZV9jaGFuZ2VfY2hhbm5lbFwiLFxuICBUT1BfVVBfQ0hBTk5FTDogXCJ0b3BfdXBfY2hhbm5lbFwiXG59O1xuY29uc3QgQlJPQURDQVNUX0NIQU5ORUxTX01TR1MgPSB7XG4gIExPR09VVDogXCJsb2dvdXRcIixcbiAgQUNDT1VOVF9JTVBPUlRFRDogXCJhY2NvdW50X2ltcG9ydGVkXCIsXG4gIFNFTEVDVEVEX0FERFJFU1NfQ0hBTkdFOiBcInNlbGVjdGVkX2FkZHJlc3NfY2hhbmdlXCIsXG4gIE5FVFdPUktfQ0hBTkdFOiBcIm5ldHdvcmtfY2hhbmdlXCIsXG4gIFNFVF9USEVNRTogXCJzZXRfdGhlbWVcIlxufTtcbmxldCBDb250cm9sbGVyRXZlbnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChDb250cm9sbGVyRXZlbnRzKSB7XG4gIENvbnRyb2xsZXJFdmVudHNbXCJVc2VyVW5hdXRob3JpemVkXCJdID0gXCJ1c2VyLnVuYXV0aG9yaXplZFwiO1xuICByZXR1cm4gQ29udHJvbGxlckV2ZW50cztcbn0oe30pO1xuXG5mdW5jdGlvbiBjcmVhdGVDaGFuZ2VQcm92aWRlck1pZGRsZXdhcmVNaWRkbGV3YXJlKHtcbiAgY2hhbmdlUHJvdmlkZXJcbn0pIHtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxdWVzdCwgcmVzcG9uc2UsIG5leHQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBtZXRob2RcbiAgICB9ID0gcmVxdWVzdDtcbiAgICBpZiAobWV0aG9kICE9PSBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5TRVRfUFJPVklERVIpIHJldHVybiBuZXh0KCk7XG4gICAgaWYgKCFjaGFuZ2VQcm92aWRlcikgdGhyb3cgbmV3IEVycm9yKFwiQ29tbXVuaWNhdGlvbk1pZGRsZXdhcmUgLSBvcHRzLmNoYW5nZVByb3ZpZGVyIG5vdCBwcm92aWRlZFwiKTtcbiAgICByZXNwb25zZS5yZXN1bHQgPSBhd2FpdCBjaGFuZ2VQcm92aWRlcihyZXF1ZXN0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb3B1cE1pZGRsZXdhcmUoe1xuICB0b3B1cFxufSkge1xuICByZXR1cm4gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgbmV4dCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG1ldGhvZFxuICAgIH0gPSByZXF1ZXN0O1xuICAgIGlmIChtZXRob2QgIT09IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlRPUFVQKSByZXR1cm4gbmV4dCgpO1xuICAgIGlmICghdG9wdXApIHRocm93IG5ldyBFcnJvcihcIkNvbW11bmljYXRpb25NaWRkbGV3YXJlIC0gb3B0cy50b3B1cCBub3QgcHJvdmlkZWRcIik7XG4gICAgcmVzcG9uc2UucmVzdWx0ID0gYXdhaXQgdG9wdXAocmVxdWVzdCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlR2VuZXJpY0pSUENNaWRkbGV3YXJlKHRhcmdldE1ldGhvZCwgaGFuZGxlcikge1xuICByZXR1cm4gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXF1ZXN0LCByZXNwb25zZSwgbmV4dCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG1ldGhvZFxuICAgIH0gPSByZXF1ZXN0O1xuICAgIGlmIChtZXRob2QgIT09IHRhcmdldE1ldGhvZCkgcmV0dXJuIG5leHQoKTtcbiAgICBpZiAoIWhhbmRsZXIpIHRocm93IG5ldyBFcnJvcihgQ29tbXVuaWNhdGlvbk1pZGRsZXdhcmUgLSAke3RhcmdldE1ldGhvZH0gbm90IHByb3ZpZGVkYCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlcihyZXF1ZXN0KTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9XG4gICAgcmVzcG9uc2UucmVzdWx0ID0gcmVzdWx0O1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbXVuaWNhdGlvbk1pZGRsZXdhcmUocHJvdmlkZXJIYW5kbGVycykge1xuICBjb25zdCB7XG4gICAgZ2V0VXNlckluZm8sXG4gICAgZ2V0V2FsbGV0SW5zdGFuY2VJZCxcbiAgICB0b3B1cCxcbiAgICBsb2dvdXQsXG4gICAgY2hhbmdlUHJvdmlkZXIsXG4gICAgc2V0SUZyYW1lU3RhdHVzLFxuICAgIGhhbmRsZVdpbmRvd1JwYyxcbiAgICBnZXRQcm92aWRlclN0YXRlLFxuICAgIGxvZ2luV2l0aFByaXZhdGVLZXksXG4gICAgc2hvd1dhbGxldENvbm5lY3QsXG4gICAgc2hvd0NoZWNrb3V0LFxuICAgIHNob3dXYWxsZXRVaSxcbiAgICBzaG93V2luZG93QmxvY2tBbGVydCxcbiAgICBsb2dpbldpdGhTZXNzaW9uSWRcbiAgfSA9IHByb3ZpZGVySGFuZGxlcnM7XG4gIHJldHVybiBtZXJnZU1pZGRsZXdhcmUoW2NyZWF0ZUNoYW5nZVByb3ZpZGVyTWlkZGxld2FyZU1pZGRsZXdhcmUoe1xuICAgIGNoYW5nZVByb3ZpZGVyXG4gIH0pLCBjcmVhdGVUb3B1cE1pZGRsZXdhcmUoe1xuICAgIHRvcHVwXG4gIH0pLCBjcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUoe1xuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5MT0dPVVRdOiBsb2dvdXQsXG4gICAgW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLldBTExFVF9JTlNUQU5DRV9JRF06IGdldFdhbGxldEluc3RhbmNlSWQsXG4gICAgW0NPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlVTRVJfSU5GT106IGdldFVzZXJJbmZvLFxuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5JRlJBTUVfU1RBVFVTXTogc2V0SUZyYW1lU3RhdHVzLFxuICAgIC8vIERvIHRoaXMgaW4gdGhlIG9yY2hlc3RyYXRvciBiZWNhdXNlIGNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyIG5lZWRzIHRvIGJlIHBhc3NlZCBpbnRvIFBvcHVwSGFuZGxlcnNcbiAgICBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuQ0xPU0VEX1dJTkRPV106IGhhbmRsZVdpbmRvd1JwYyxcbiAgICBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuR0VUX1BST1ZJREVSX1NUQVRFXTogZ2V0UHJvdmlkZXJTdGF0ZSxcbiAgICBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuU0hPV19XQUxMRVRfQ09OTkVDVF06IHNob3dXYWxsZXRDb25uZWN0LFxuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5TSE9XX0NIRUNLT1VUXTogc2hvd0NoZWNrb3V0LFxuICAgIFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5TSE9XX1dBTExFVF9VSV06IHNob3dXYWxsZXRVaSxcbiAgICBbQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuV0lORE9XX0JMT0NLRURdOiBzaG93V2luZG93QmxvY2tBbGVydFxuICB9KSwgY3JlYXRlR2VuZXJpY0pSUENNaWRkbGV3YXJlKENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLkxPR0lOX1dJVEhfUFJJVkFURV9LRVksIGxvZ2luV2l0aFByaXZhdGVLZXkpLCBjcmVhdGVHZW5lcmljSlJQQ01pZGRsZXdhcmUoQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuTE9HSU5fV0lUSF9TRVNTSU9OX0lELCBsb2dpbldpdGhTZXNzaW9uSWQpXSk7XG59XG5cbmNsYXNzIEJhc2VFbWJlZENvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb25maWcgPSB7fSxcbiAgICBzdGF0ZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfY29tbXVuaWNhdGlvblByb3ZpZGVyUHJveHlcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgIGlzSUZyYW1lRnVsbFNjcmVlbjogdHJ1ZSxcbiAgICAgIG9hdXRoTW9kYWxWaXNpYmlsaXR5OiBmYWxzZSxcbiAgICAgIGxvZ2luSW5Qcm9ncmVzczogZmFsc2UsXG4gICAgICBkYXBwTWV0YWRhdGE6IHtcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgaWNvbjogXCJcIlxuICAgICAgfSxcbiAgICAgIHdlYjNBdXRoQ2xpZW50SWQ6IFwiXCIsXG4gICAgICB3ZWIzQXV0aE5ldHdvcms6IFwibWFpbm5ldFwiLFxuICAgICAgd2hpdGVMYWJlbDogbnVsbCxcbiAgICAgIGNvbmZpcm1hdGlvblN0cmF0ZWd5OiBcInBvcHVwXCJcbiAgICB9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBieSBvcmNoZXN0cmF0b3Igb25jZSB3aGlsZSBpbml0aWFsaXppbmcgdGhlIGNsYXNzXG4gICAqIEBwYXJhbSBoYW5kbGVycyAtIEpSUEMgaGFuZGxlcnMgZm9yIHByb3ZpZGVyXG4gICAqIEByZXR1cm5zIC0gcHJvdmlkZXIgLSBSZXR1cm5zIHRoZSBwcm92aWRlclByb3h5XG4gICAqL1xuICBpbml0aWFsaXplUHJvdmlkZXIoaGFuZGxlcnMpIHtcbiAgICBjb25zdCBlbmdpbmUgPSBuZXcgSlJQQ0VuZ2luZSgpO1xuICAgIGNvbnN0IGNvbW11bmljYXRpb25NaWRkbGV3YXJlID0gY3JlYXRlQ29tbXVuaWNhdGlvbk1pZGRsZXdhcmUoaGFuZGxlcnMpO1xuICAgIGVuZ2luZS5wdXNoKGNvbW11bmljYXRpb25NaWRkbGV3YXJlKTtcbiAgICBjb25zdCBjb21tdW5pY2F0aW9uUHJvdmlkZXIgPSBwcm92aWRlckZyb21FbmdpbmUoZW5naW5lKTtcbiAgICB0aGlzLnNldENvbW11bmljYXRpb25Qcm92aWRlcihjb21tdW5pY2F0aW9uUHJvdmlkZXIpO1xuICB9XG4gIHNldENvbW11bmljYXRpb25Qcm92aWRlcihjb21tdW5pY2F0aW9uUHJvdmlkZXIpIHtcbiAgICBpZiAodGhpcy5fY29tbXVuaWNhdGlvblByb3ZpZGVyUHJveHkpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuX2NvbW11bmljYXRpb25Qcm92aWRlclByb3h5LnNldFRhcmdldChjb21tdW5pY2F0aW9uUHJvdmlkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb21tdW5pY2F0aW9uUHJvdmlkZXJQcm94eSA9IGNyZWF0ZVN3YXBwYWJsZVByb3h5KGNvbW11bmljYXRpb25Qcm92aWRlcik7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIENvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyIGV4dGVuZHMgU2FmZUV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVXaW5kb3dScGNcIiwgKHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0LCBlbmQpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH0gPSByZXF1ZXN0O1xuICAgICAgaWYgKG1ldGhvZCA9PT0gQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuQ0xPU0VEX1dJTkRPVykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2luZG93SWRcbiAgICAgICAgfSA9IHBhcmFtcztcbiAgICAgICAgLy8gSSd2ZSBiZWVuIGluZm9ybWVkIHRoYXQgYSB3aW5kb3cgaGFzIGJlZW4gY2xvc2VkXG4gICAgICAgIHRoaXMuZW1pdChgJHt3aW5kb3dJZH06Y2xvc2VkYCk7XG4gICAgICAgIHJlc3BvbnNlLnJlc3VsdCA9IHRydWU7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IEJVVFRPTl9QT1NJVElPTiA9IHtcbiAgQk9UVE9NX0xFRlQ6IFwiYm90dG9tLWxlZnRcIixcbiAgVE9QX0xFRlQ6IFwidG9wLWxlZnRcIixcbiAgQk9UVE9NX1JJR0hUOiBcImJvdHRvbS1yaWdodFwiLFxuICBUT1BfUklHSFQ6IFwidG9wLXJpZ2h0XCJcbn07XG5jb25zdCBDT05GSVJNQVRJT05fU1RSQVRFR1kgPSB7XG4gIFBPUFVQOiBcInBvcHVwXCIsXG4gIE1PREFMOiBcIm1vZGFsXCIsXG4gIEFVVE9fQVBQUk9WRTogXCJhdXRvLWFwcHJvdmVcIixcbiAgREVGQVVMVDogXCJkZWZhdWx0XCJcbn07XG5cbi8qKlxuICogU3RhdGUgY2hhbmdlIGNhbGxiYWNrc1xuICovXG5cbi8qKlxuICogQmFzZSBjb250cm9sbGVyIGNvbmZpZ3VyYXRpb25cbiAqL1xuXG4vKipcbiAqIEJhc2Ugc3RhdGUgcmVwcmVzZW50YXRpb25cbiAqL1xuXG5jb25zdCBMT0dJTl9QUk9WSURFUiA9IHtcbiAgR09PR0xFOiBcImdvb2dsZVwiLFxuICBGQUNFQk9PSzogXCJmYWNlYm9va1wiLFxuICBSRURESVQ6IFwicmVkZGl0XCIsXG4gIERJU0NPUkQ6IFwiZGlzY29yZFwiLFxuICBUV0lUQ0g6IFwidHdpdGNoXCIsXG4gIEFQUExFOiBcImFwcGxlXCIsXG4gIExJTkU6IFwibGluZVwiLFxuICBHSVRIVUI6IFwiZ2l0aHViXCIsXG4gIEtBS0FPOiBcImtha2FvXCIsXG4gIExJTktFRElOOiBcImxpbmtlZGluXCIsXG4gIFRXSVRURVI6IFwidHdpdHRlclwiLFxuICBXRUlCTzogXCJ3ZWlib1wiLFxuICBXRUNIQVQ6IFwid2VjaGF0XCIsXG4gIEVNQUlMX1BBU1NXT1JETEVTUzogXCJlbWFpbF9wYXNzd29yZGxlc3NcIixcbiAgU01TX1BBU1NXT1JETEVTUzogXCJzbXNfcGFzc3dvcmRsZXNzXCJcbn07XG4vKipcbiAqIHtAbGFiZWwgbG9naW5Qcm92aWRlclR5cGV9XG4gKi9cblxuY29uc3QgUEFZTUVOVF9QUk9WSURFUiA9IHtcbiAgTU9PTlBBWTogXCJtb29ucGF5XCIsXG4gIFdZUkU6IFwid3lyZVwiLFxuICBSQU1QTkVUV09SSzogXCJyYW1wbmV0d29ya1wiLFxuICBYQU5QT09MOiBcInhhbnBvb2xcIixcbiAgTUVSQ1VSWU86IFwibWVyY3VyeW9cIixcbiAgVFJBTlNBSzogXCJ0cmFuc2FrXCJcbn07XG5cbmZ1bmN0aW9uIG9taXRCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0IHRvIHN0b3JlIHRoZSByZXN1bHRzXG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciBhbGwgb3duIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdFxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvYmplY3QpKSB7XG4gICAgaWYgKCFwcmVkaWNhdGUodmFsdWUsIGtleSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwaWNrQnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCB0byBzdG9yZSB0aGUgcmVzdWx0c1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqZWN0KSkge1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjbG9uZURlZXAob2JqZWN0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZShvYmplY3QpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iamVjdCkpO1xuICB9XG59XG5cbmNvbnN0IGF1dGhTZXJ2ZXIgPSBcImh0dHBzOi8vYXV0aGpzLndlYjNhdXRoLmlvXCI7XG5jb25zdCBzaWduQ2hhbGxlbmdlID0gYXN5bmMgKHBheWxvYWQsIGNoYWluTmFtZXNwYWNlKSA9PiB7XG4gIGNvbnN0IHQgPSBjaGFpbk5hbWVzcGFjZSA9PT0gXCJzb2xhbmFcIiA/IFwic2lwOTlcIiA6IFwiZWlwMTkxXCI7XG4gIGNvbnN0IGhlYWRlciA9IHtcbiAgICB0XG4gIH07XG4gIGNvbnN0IG5ldHdvcmsgPSBjaGFpbk5hbWVzcGFjZSA9PT0gXCJzb2xhbmFcIiA/IFwic29sYW5hXCIgOiBcImV0aGVyZXVtXCI7XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgcGF5bG9hZCxcbiAgICBoZWFkZXIsXG4gICAgbmV0d29ya1xuICB9O1xuICBjb25zdCByZXMgPSBhd2FpdCBwb3N0KGAke2F1dGhTZXJ2ZXJ9L3Npd3cvZ2V0YCwgZGF0YSk7XG4gIGlmICghcmVzLnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gYXV0aGVudGljYXRlIHVzZXIsIFBsZWFzZSByZWFjaCBvdXQgdG8gV2ViM0F1dGggU3VwcG9ydCB0ZWFtXCIpO1xuICB9XG4gIHJldHVybiByZXMuY2hhbGxlbmdlO1xufTtcbmNvbnN0IHZlcmlmeVNpZ25lZENoYWxsZW5nZSA9IGFzeW5jIChjaGFpbk5hbWVzcGFjZSwgc2lnbmVkTWVzc2FnZSwgY2hhbGxlbmdlLCBpc3N1ZXIsIHNlc3Npb25UaW1lLCBjbGllbnRJZCwgd2ViM0F1dGhOZXR3b3JrLCBhdWRpZW5jZSwgYWRkaXRpb25hbE1ldGFkYXRhKSA9PiB7XG4gIHZhciBfd2luZG93JGxvY2F0aW9uO1xuICBjb25zdCB0ID0gY2hhaW5OYW1lc3BhY2UgPT09IFwic29sYW5hXCIgPyBcInNpcDk5XCIgOiBcImVpcDE5MVwiO1xuICBjb25zdCBzaWdEYXRhID0gX29iamVjdFNwcmVhZCh7XG4gICAgc2lnbmF0dXJlOiB7XG4gICAgICBzOiBzaWduZWRNZXNzYWdlLFxuICAgICAgdFxuICAgIH0sXG4gICAgbWVzc2FnZTogY2hhbGxlbmdlLFxuICAgIGlzc3VlcixcbiAgICBhdWRpZW5jZTogYXVkaWVuY2UgfHwgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyAoKF93aW5kb3ckbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24pID09PSBudWxsIHx8IF93aW5kb3ckbG9jYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3ckbG9jYXRpb24uaG9zdG5hbWUpIHx8IFwiY29tOi8vcmVhY3RuYXRpdmVcIiA6IFwiY29tOi8vcmVhY3RuYXRpdmVcIiksXG4gICAgdGltZW91dDogc2Vzc2lvblRpbWVcbiAgfSwgYWRkaXRpb25hbE1ldGFkYXRhIHx8IHt9KTtcbiAgY29uc3QgaWRUb2tlblJlcyA9IGF3YWl0IHBvc3QoYCR7YXV0aFNlcnZlcn0vc2l3dy92ZXJpZnlgLCBzaWdEYXRhLCB7XG4gICAgaGVhZGVyczoge1xuICAgICAgY2xpZW50X2lkOiBjbGllbnRJZCxcbiAgICAgIHdhbGxldF9wcm92aWRlcjogaXNzdWVyLFxuICAgICAgd2ViM2F1dGhfbmV0d29yazogd2ViM0F1dGhOZXR3b3JrXG4gICAgfVxuICB9KTtcbiAgaWYgKCFpZFRva2VuUmVzLnN1Y2Nlc3MpIHtcbiAgICBsb2cuZXJyb3IoXCJGYWlsZWQgdG8gYXV0aGVudGljYXRlIHVzZXIsICxtZXNzYWdlIHZlcmlmaWNhdGlvbiBmYWlsZWRcIiwgaWRUb2tlblJlcy5lcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZSB1c2VyLCAsbWVzc2FnZSB2ZXJpZmljYXRpb24gZmFpbGVkXCIpO1xuICB9XG4gIHJldHVybiBpZFRva2VuUmVzLnRva2VuO1xufTtcblxuY29uc3QgZ2V0VHhTdGF0dXNUZXh0ID0gdHhTdGF0dXMgPT4ge1xuICBzd2l0Y2ggKHR4U3RhdHVzKSB7XG4gICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgY2FzZSBcInVuYXBwcm92ZWRcIjpcbiAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICByZXR1cm4gQUNUSVZJVFlfU1RBVFVTX1VOU1VDQ0VTU0ZVTDtcbiAgICBjYXNlIFwiY29uZmlybWVkXCI6XG4gICAgICByZXR1cm4gQUNUSVZJVFlfU1RBVFVTX1NVQ0NFU1NGVUw7XG4gICAgY2FzZSBcInN1Ym1pdHRlZFwiOlxuICAgICAgcmV0dXJuIEFDVElWSVRZX1NUQVRVU19QRU5ESU5HO1xuICAgIGNhc2UgXCJjYW5jZWxsZWRcIjpcbiAgICAgIHJldHVybiBBQ1RJVklUWV9TVEFUVVNfQ0FOQ0VMTEVEO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJcIjtcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdHkgZnVuY3Rpb25zXG4gKi9cblxuZnVuY3Rpb24gaW50VG9IZXgoaSkge1xuICBjb25zdCBoZXggPSBpLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGAweCR7aGV4fWA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBudW1iZXIuIERvbid0IHVzZSBmb3IgY3J5cHRvZ3JhcGhpYyBwdXJwb3Nlcy5cbiAqIEByZXR1cm5zIGEgcmFuZG9tIG51bWJlclxuICovXG5jb25zdCByYW5kb21JZCA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4vKipcbiAqIFBhZHMgdGhlIGZyb250IG9mIHRoZSBnaXZlbiBoZXggc3RyaW5nIHdpdGggemVyb2VzIHVudGlsIGl0IHJlYWNoZXMgdGhlXG4gKiB0YXJnZXQgbGVuZ3RoLiBJZiB0aGUgaW5wdXQgc3RyaW5nIGlzIGFscmVhZHkgbG9uZ2VyIHRoYW4gb3IgZXF1YWwgdG8gdGhlXG4gKiB0YXJnZXQgbGVuZ3RoLCBpdCBpcyByZXR1cm5lZCB1bm1vZGlmaWVkLlxuICpcbiAqIElmIHRoZSBpbnB1dCBzdHJpbmcgaXMgXCIweFwiLXByZWZpeGVkIG9yIG5vdCBhIGhleCBzdHJpbmcsIGFuIGVycm9yIHdpbGwgYmVcbiAqIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gaGV4U3RyaW5nIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBwYWQgd2l0aCB6ZXJvZXMuXG4gKiBAcGFyYW0gdGFyZ2V0TGVuZ3RoIC0gVGhlIHRhcmdldCBsZW5ndGggb2YgdGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBpbnB1dCBzdHJpbmcgZnJvbnQtcGFkZGVkIHdpdGggemVyb2VzLCBvciB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gKiBpZiBpdCB3YXMgYWxyZWFkeSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdG8gdGhlIHRhcmdldCBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHBhZFdpdGhaZXJvZXMoaGV4U3RyaW5nLCB0YXJnZXRMZW5ndGgpIHtcbiAgaWYgKGhleFN0cmluZyAhPT0gXCJcIiAmJiAhL15bYS1mMC05XSskL2l1LnRlc3QoaGV4U3RyaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYW4gdW5wcmVmaXhlZCBoZXggc3RyaW5nLiBSZWNlaXZlZDogJHtoZXhTdHJpbmd9YCk7XG4gIH1cbiAgaWYgKHRhcmdldExlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgdGFyZ2V0IGxlbmd0aC4gUmVjZWl2ZWQ6ICR7dGFyZ2V0TGVuZ3RofWApO1xuICB9XG4gIHJldHVybiBTdHJpbmcucHJvdG90eXBlLnBhZFN0YXJ0LmNhbGwoaGV4U3RyaW5nLCB0YXJnZXRMZW5ndGgsIFwiMFwiKTtcbn1cbi8qKlxuICogQ29uY2F0ZW5hdGUgYW4gZXh0ZW5kZWQgRUNEU0Egc2lnbmF0dXJlIGludG8gYSBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2IC0gVGhlICd2JyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gciAtIFRoZSAncicgcG9ydGlvbiBvZiB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIHMgLSBUaGUgJ3MnIHBvcnRpb24gb2YgdGhlIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQgRUNEU0Egc2lnbmF0dXJlLlxuICovXG5mdW5jdGlvbiBjb25jYXRTaWcodiwgciwgcykge1xuICBjb25zdCByU2lnID0gZnJvbVNpZ25lZChyKTtcbiAgY29uc3Qgc1NpZyA9IGZyb21TaWduZWQocyk7XG4gIGNvbnN0IHZTaWcgPSBieXRlc1RvQmlnSW50KHYpO1xuICBjb25zdCByU3RyID0gcGFkV2l0aFplcm9lcyhCdWZmZXIuZnJvbSh0b1Vuc2lnbmVkKHJTaWcpKS50b1N0cmluZyhcImhleFwiKSwgNjQpO1xuICBjb25zdCBzU3RyID0gcGFkV2l0aFplcm9lcyhCdWZmZXIuZnJvbSh0b1Vuc2lnbmVkKHNTaWcpKS50b1N0cmluZyhcImhleFwiKSwgNjQpO1xuICBjb25zdCB2U3RyID0gc3RyaXBIZXhQcmVmaXgoYmlnSW50VG9IZXgodlNpZykpO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KHJTdHIuY29uY2F0KHNTdHIsIHZTdHIpKTtcbn1cbmZ1bmN0aW9uIHRpbWVvdXQkMShkdXJhdGlvbikge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgY29uc3QgdGltZW91dFJlZiA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dFJlZik7XG4gICAgfSwgZHVyYXRpb24pO1xuICB9KTtcbn1cbmNvbnN0IGdldEhlYWRlcnMgPSAoand0LCBwdWJsaWNBZGRyZXNzKSA9PiB7XG4gIHJldHVybiB7XG4gICAgaGVhZGVyczoge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2p3dH1gLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICBcInB1YmxpYy1hZGRyZXNzXCI6IHB1YmxpY0FkZHJlc3NcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFRleHQvbnVtYmVyIGZvcm1hdHRpbmcgdXRpbGl0aWVzXG4gKi9cbmNvbnN0IGZvcm1hdFNtYWxsTnVtYmVycyA9IChudW1iZXIsIGN1cnJlbmN5ID0gXCJ1c2RcIiwgbm9UaWxkZSA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IGZpbmFsTnVtYmVyID0gQmlnTnVtYmVyLmlzQmlnTnVtYmVyKG51bWJlcikgPyBudW1iZXIudG9OdW1iZXIoKSA6IG51bWJlcjtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZmluYWxOdW1iZXIpKSByZXR1cm4gXCJcIjtcbiAgY29uc3QgdmFsdWUgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSgpID09PSBcInVzZFwiID8gcGFyc2VGbG9hdChOdW1iZXIoZmluYWxOdW1iZXIpLnRvRml4ZWQoMikpIDogcGFyc2VGbG9hdChOdW1iZXIoZmluYWxOdW1iZXIpLnRvRml4ZWQoNSkpO1xuICBjb25zdCB0aWxkZSA9IHZhbHVlID4gMCA/IFwifiBcIiA6IFwiXCI7XG4gIHJldHVybiBgJHtjdXJyZW5jeS50b0xvd2VyQ2FzZSgpID09PSBcInVzZFwiIHx8IG5vVGlsZGUgPyBcIlwiIDogdGlsZGV9JHtOdW1iZXIodmFsdWUpfSAke2N1cnJlbmN5LnRvVXBwZXJDYXNlKCl9YDtcbn07XG5jb25zdCBhZGRyZXNzU2xpY2VyID0gKGFkZHJlc3MsIHNsaWNlTGVuZ3RoID0gNSkgPT4ge1xuICBpZiAoIWFkZHJlc3MpIHJldHVybiBcIlwiO1xuICBpZiAoYWRkcmVzcy5sZW5ndGggPCAxMSkge1xuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG4gIGlmICh0eXBlb2YgYWRkcmVzcyAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIFwiXCI7XG4gIHJldHVybiBgJHthZGRyZXNzLnNsaWNlKDAsIHNsaWNlTGVuZ3RoKX0uLi4ke2FkZHJlc3Muc2xpY2UoLXNsaWNlTGVuZ3RoKX1gO1xufTtcbmNvbnN0IHNpZ25pZmljYW50RGlnaXRzID0gKG51bWJlciwgcGVyYyA9IGZhbHNlLCBsZW5ndGhfID0gMikgPT4ge1xuICBsZXQgaW5wdXQgPSAhQmlnTnVtYmVyLmlzQmlnTnVtYmVyKG51bWJlcikgPyBuZXcgQmlnTnVtYmVyKG51bWJlcikgOiBudW1iZXI7XG4gIGlmIChpbnB1dC5pc1plcm8oKSkgcmV0dXJuIGlucHV0O1xuICBpZiAocGVyYykge1xuICAgIGlucHV0ID0gaW5wdXQudGltZXMobmV3IEJpZ051bWJlcigxMDApKTtcbiAgfVxuICBsZXQgZGVwdGg7XG4gIGlmIChpbnB1dC5ndGUobmV3IEJpZ051bWJlcigxKSkpIHtcbiAgICBkZXB0aCA9IGxlbmd0aF87XG4gIH0gZWxzZSB7XG4gICAgZGVwdGggPSBsZW5ndGhfIC0gMSArIE1hdGguY2VpbChNYXRoLmxvZzEwKG5ldyBCaWdOdW1iZXIoXCIxXCIpLmRpdihpbnB1dCkudG9OdW1iZXIoKSkpO1xuICB9XG4gIGNvbnN0IHNoaWZ0ID0gbmV3IEJpZ051bWJlcigxMCkucG93KG5ldyBCaWdOdW1iZXIoZGVwdGgpKTtcbiAgY29uc3Qgcm91bmRlZE51bWJlciA9IE1hdGgucm91bmQoc2hpZnQudGltZXMoaW5wdXQpLnRvTnVtYmVyKCkpIC8gc2hpZnQudG9OdW1iZXIoKTtcbiAgcmV0dXJuIHJvdW5kZWROdW1iZXI7XG59O1xuY29uc3QgZm9ybWF0RGF0ZSA9IGlucHV0RGF0ZSA9PiB7XG4gIGNvbnN0IG1vbnRoTGlzdCA9IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXTtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGlucHV0RGF0ZSk7XG4gIGNvbnN0IGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICBjb25zdCBtb250aCA9IG1vbnRoTGlzdFtkYXRlLmdldE1vbnRoKCldO1xuICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICByZXR1cm4gYCR7ZGF5fSAke21vbnRofSAke3llYXJ9YDtcbn07XG5jb25zdCBmb3JtYXRUaW1lID0gdGltZSA9PiB7XG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lKS50b1RpbWVTdHJpbmcoKS5zbGljZSgwLCA4KTtcbn07XG5cbi8qKlxuICogTmV0d29yayB1dGlsaXRpZXNcbiAqL1xuY29uc3QgdHJhbnNhY3Rpb25NYXRjaGVzTmV0d29yayA9ICh0cmFuc2FjdGlvbiwgY2hhaW5JZCkgPT4ge1xuICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLmNoYWluSWQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uY2hhaW5JZCA9PT0gY2hhaW5JZDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFNpZ25pbmcgdXRpbHNcbiAqL1xuY29uc3QgaGFzaE1lc3NhZ2UgPSBtZXNzYWdlID0+IHtcbiAgY29uc3QgYnVmZmVyZWRNZXNzYWdlID0gQnVmZmVyLmZyb20obWVzc2FnZSwgXCJ1dGY4XCIpO1xuICBjb25zdCBlbCA9IGhhc2hQZXJzb25hbE1lc3NhZ2UoYnVmZmVyZWRNZXNzYWdlKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVsKTtcbn07XG5jb25zdCBzaWduTWVzc2FnZSA9IGFzeW5jIChwcml2YXRlS2V5LCBkYXRhKSA9PiB7XG4gIGNvbnN0IHByaXZLZXkgPSBCdWZmZXIuZnJvbShwcml2YXRlS2V5LCBcImhleFwiKTtcbiAgY29uc3QgbWVzc2FnZSA9IHN0cmlwSGV4UHJlZml4KGRhdGEpO1xuICBjb25zdCBtc2dTaWcgPSBlY3NpZ24oQnVmZmVyLmZyb20obWVzc2FnZSwgXCJoZXhcIiksIHByaXZLZXkpO1xuICBjb25zdCByYXdNc2dTaWcgPSBjb25jYXRTaWcoQnVmZmVyLmZyb20oYmlnSW50VG9CeXRlcyhtc2dTaWcudikpLCBCdWZmZXIuZnJvbShtc2dTaWcuciksIEJ1ZmZlci5mcm9tKG1zZ1NpZy5zKSk7XG4gIHJldHVybiByYXdNc2dTaWc7XG59O1xuXG4vKipcbiAqIHBvcHVwIGhhbmRsZXIgdXRpbHNcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wdXBGZWF0dXJlcyh7XG4gIHdpZHRoOiB3LFxuICBoZWlnaHQ6IGhcbn0pIHtcbiAgLy8gRml4ZXMgZHVhbC1zY3JlZW4gcG9zaXRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vc3QgYnJvd3NlcnMgICAgICBGaXJlZm94XG4gIGNvbnN0IGR1YWxTY3JlZW5MZWZ0ID0gd2luZG93LnNjcmVlbkxlZnQgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5MZWZ0IDogd2luZG93LnNjcmVlblg7XG4gIGNvbnN0IGR1YWxTY3JlZW5Ub3AgPSB3aW5kb3cuc2NyZWVuVG9wICE9PSB1bmRlZmluZWQgPyB3aW5kb3cuc2NyZWVuVG9wIDogd2luZG93LnNjcmVlblk7XG4gIGNvbnN0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGggPyB3aW5kb3cuaW5uZXJXaWR0aCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA6IHdpbmRvdy5zY3JlZW4ud2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCA/IHdpbmRvdy5pbm5lckhlaWdodCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IDogd2luZG93LnNjcmVlbi5oZWlnaHQ7XG4gIGNvbnN0IHN5c3RlbVpvb20gPSAxOyAvLyBObyByZWxpYWJsZSBlc3RpbWF0ZVxuXG4gIGNvbnN0IGxlZnQgPSBNYXRoLmFicygod2lkdGggLSB3KSAvIDIgLyBzeXN0ZW1ab29tICsgZHVhbFNjcmVlbkxlZnQpO1xuICBjb25zdCB0b3AgPSBNYXRoLmFicygoaGVpZ2h0IC0gaCkgLyAyIC8gc3lzdGVtWm9vbSArIGR1YWxTY3JlZW5Ub3ApO1xuICBjb25zdCBmZWF0dXJlcyA9IGB0aXRsZWJhcj0wLHRvb2xiYXI9MCxzdGF0dXM9MCxsb2NhdGlvbj0wLG1lbnViYXI9MCxoZWlnaHQ9JHtoIC8gc3lzdGVtWm9vbX0sd2lkdGg9JHt3IC8gc3lzdGVtWm9vbX0sdG9wPSR7dG9wfSxsZWZ0PSR7bGVmdH1gO1xuICByZXR1cm4gZmVhdHVyZXM7XG59XG5jb25zdCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyA9IHtcbiAgdHlwZTogXCJzZXJ2ZXJcIixcbiAgLy8gdHlwZTogJ2xvY2Fsc3RvcmFnZScsIC8vIChvcHRpb25hbCkgZW5mb3JjZSBhIHR5cGUsIG9uZU9mWyduYXRpdmUnLCAnaWRiJywgJ2xvY2Fsc3RvcmFnZScsICdub2RlJ11cbiAgd2ViV29ya2VyU3VwcG9ydDogZmFsc2UgLy8gKG9wdGlvbmFsKSBzZXQgdGhpcyB0byBmYWxzZSBpZiB5b3Uga25vdyB0aGF0IHlvdXIgY2hhbm5lbCB3aWxsIG5ldmVyIGJlIHVzZWQgaW4gYSBXZWJXb3JrZXIgKGluY3JlYXNlcyBwZXJmb3JtYW5jZSlcbn07XG5mdW5jdGlvbiBnZXRDdXN0b21EZXZpY2VJbmZvKCkge1xuICB2YXIgX25hdmlnYXRvcjtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgaWYgKChfbmF2aWdhdG9yID0gbmF2aWdhdG9yKSAhPT0gbnVsbCAmJiBfbmF2aWdhdG9yICE9PSB2b2lkIDAgJiYgX25hdmlnYXRvci5icmF2ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBicm93c2VyOiBcIkJyYXZlXCJcbiAgICB9O1xuICB9XG59XG5jbGFzcyBVc2VyRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuY29uc3QgaGFuZGxlUmVkaXJlY3RQYXJhbWV0ZXJzID0gKGhhc2gsIHF1ZXJ5UGFyYW1ldGVycykgPT4ge1xuICBjb25zdCBoYXNoUGFyYW1ldGVycyA9IHt9O1xuICBjb25zdCBoYXNoVXJsID0gbmV3IFVSTChgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS8/JHtoYXNoLnNsaWNlKDEpfWApO1xuICBoYXNoVXJsLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaGFzaFBhcmFtZXRlcnNba2V5XSA9IHZhbHVlO1xuICB9KTtcbiAgbGV0IGluc3RhbmNlUGFyYW1ldGVycyA9IHt9O1xuICBsZXQgZXJyb3IgPSBcIlwiO1xuICBpZiAoIXF1ZXJ5UGFyYW1ldGVycy53aW5kb3dJZCkge1xuICAgIGlmIChPYmplY3Qua2V5cyhoYXNoUGFyYW1ldGVycykubGVuZ3RoID4gMCAmJiBoYXNoUGFyYW1ldGVycy5zdGF0ZSkge1xuICAgICAgaW5zdGFuY2VQYXJhbWV0ZXJzID0gSlNPTi5wYXJzZShzYWZlYXRvYihkZWNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KGhhc2hQYXJhbWV0ZXJzLnN0YXRlKSkpKSB8fCB7fTtcbiAgICAgIGVycm9yID0gaGFzaFBhcmFtZXRlcnMuZXJyb3JfZGVzY3JpcHRpb24gfHwgaGFzaFBhcmFtZXRlcnMuZXJyb3IgfHwgZXJyb3I7XG4gICAgfSBlbHNlIGlmIChPYmplY3Qua2V5cyhxdWVyeVBhcmFtZXRlcnMpLmxlbmd0aCA+IDAgJiYgcXVlcnlQYXJhbWV0ZXJzLnN0YXRlKSB7XG4gICAgICBpbnN0YW5jZVBhcmFtZXRlcnMgPSBKU09OLnBhcnNlKHNhZmVhdG9iKGRlY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQocXVlcnlQYXJhbWV0ZXJzLnN0YXRlKSkpKSB8fCB7fTtcbiAgICAgIGlmIChxdWVyeVBhcmFtZXRlcnMuZXJyb3IpIGVycm9yID0gcXVlcnlQYXJhbWV0ZXJzLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGVycm9yLFxuICAgIGluc3RhbmNlUGFyYW1ldGVycyxcbiAgICBoYXNoUGFyYW1ldGVyc1xuICB9O1xufTtcbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTtcbiAgfSk7XG59XG5jb25zdCBpc1VuYXV0aG9yaXplZEVycm9yID0gZXJyb3IgPT4ge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBSZXNwb25zZSAmJiBlcnJvci5zdGF0dXMgPT09IDQwMTtcbn07XG5cbmNsYXNzIEJhc2VLZXlyaW5nQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbmZpZyA9IHt9LFxuICAgIHN0YXRlXG4gIH0pIHtcbiAgICB2YXIgX3N0YXRlJHdhbGxldHM7XG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlnLFxuICAgICAgc3RhdGVcbiAgICB9KTtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgIHdhbGxldHM6IChfc3RhdGUkd2FsbGV0cyA9IHN0YXRlLndhbGxldHMpICE9PSBudWxsICYmIF9zdGF0ZSR3YWxsZXRzICE9PSB2b2lkIDAgPyBfc3RhdGUkd2FsbGV0cyA6IFtdXG4gICAgfTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIC8vIGZvciBzaWduaW5nIGF1dGggbWVzc2FnZVxuICBhc3luYyBzaWduQXV0aE1lc3NhZ2UoYWRkcmVzcywgbWVzc2FnZSkge1xuICAgIGNvbnN0IGtleXJpbmcgPSB0aGlzLnN0YXRlLndhbGxldHMuZmluZCh4ID0+IHguYWRkcmVzcyA9PT0gYWRkcmVzcyk7XG4gICAgaWYgKCFrZXlyaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXkgZG9lcyBub3QgZXhpc3RcIik7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZE1lc3NhZ2UgPSBoYXNoTWVzc2FnZShtZXNzYWdlKS50b1N0cmluZyhcImhleFwiKTtcbiAgICBjb25zdCByYXdNZXNzYWdlU2lnID0gYXdhaXQgc2lnbk1lc3NhZ2Uoa2V5cmluZy5wcml2YXRlS2V5LCBoYXNoZWRNZXNzYWdlKTtcbiAgICByZXR1cm4gcmF3TWVzc2FnZVNpZztcbiAgfVxufVxuXG5jb25zdCBSRVRSSUFCTEVfRVJST1JTID0gW1xuLy8gaWdub3JlIHNlcnZlciBvdmVybG9hZCBlcnJvcnNcblwiR2F0ZXdheSB0aW1lb3V0XCIsIFwiRVRJTUVET1VUXCIsXG4vLyBpZ25vcmUgc2VydmVyIHNlbnQgaHRtbCBlcnJvciBwYWdlc1xuLy8gb3IgdHJ1bmNhdGVkIGpzb24gcmVzcG9uc2VzXG5cImZhaWxlZCB0byBwYXJzZSByZXNwb25zZSBib2R5XCIsXG4vLyBpZ25vcmUgZXJyb3JzIHdoZXJlIGh0dHAgcmVxIGZhaWxlZCB0byBlc3RhYmxpc2hcblwiRmFpbGVkIHRvIGZldGNoXCJdO1xuZnVuY3Rpb24gY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKSB7XG4gIC8vIGNoZWNrIGZvciBlcnJvcnNcbiAgc3dpdGNoIChmZXRjaFJlcy5zdGF0dXMpIHtcbiAgICBjYXNlIDQwNTpcbiAgICAgIHRocm93IHJwY0Vycm9ycy5tZXRob2ROb3RGb3VuZCgpO1xuICAgIGNhc2UgNDE4OlxuICAgICAgdGhyb3cgcnBjRXJyb3JzLmludGVybmFsKHtcbiAgICAgICAgbWVzc2FnZTogYFJlcXVlc3QgaXMgYmVpbmcgcmF0ZSBsaW1pdGVkLmAsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBjYXVzZTogZmV0Y2hSZXNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgY2FzZSA1MDM6XG4gICAgY2FzZSA1MDQ6XG4gICAgICB0aHJvdyBycGNFcnJvcnMuaW50ZXJuYWwoe1xuICAgICAgICBtZXNzYWdlOiBgR2F0ZXdheSB0aW1lb3V0LiBUaGUgcmVxdWVzdCB0b29rIHRvbyBsb25nIHRvIHByb2Nlc3MuYCArIGBUaGlzIGNhbiBoYXBwZW4gd2hlbiBxdWVyeWluZyBvdmVyIHRvbyB3aWRlIGEgYmxvY2sgcmFuZ2UuYFxuICAgICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRpbWVvdXQoZHVyYXRpb24pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVzcG9uc2UoZmV0Y2hSZXMsIGJvZHkpIHtcbiAgLy8gY2hlY2sgZm9yIGVycm9yIGNvZGVcbiAgaWYgKGZldGNoUmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgdGhyb3cgcnBjRXJyb3JzLmludGVybmFsKHtcbiAgICAgIG1lc3NhZ2U6IGBOb24tMjAwIHN0YXR1cyBjb2RlOiAnJHtmZXRjaFJlcy5zdGF0dXN9J2AsXG4gICAgICBkYXRhOiBib2R5XG4gICAgfSk7XG4gIH1cbiAgLy8gY2hlY2sgZm9yIHJwYyBlcnJvclxuICBpZiAoYm9keS5lcnJvcikge1xuICAgIHRocm93IHJwY0Vycm9ycy5pbnRlcm5hbCh7XG4gICAgICBkYXRhOiBib2R5LmVycm9yXG4gICAgfSk7XG4gIH1cbiAgLy8gcmV0dXJuIHN1Y2Nlc3NmdWwgcmVzdWx0XG4gIHJldHVybiBib2R5LnJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSh7XG4gIHJlcSxcbiAgcnBjVGFyZ2V0LFxuICBvcmlnaW5IdHRwSGVhZGVyS2V5XG59KSB7XG4gIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwocnBjVGFyZ2V0KTtcblxuICAvLyBwcmVwYXJlIHBheWxvYWRcbiAgLy8gY29weSBvbmx5IGNhbm9uaWNhbCBqc29uIHJwYyBwcm9wZXJ0aWVzXG4gIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgaWQ6IHJlcS5pZCxcbiAgICBqc29ucnBjOiByZXEuanNvbnJwYyxcbiAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgcGFyYW1zOiByZXEucGFyYW1zXG4gIH07XG5cbiAgLy8gZXh0cmFjdCAnb3JpZ2luJyBwYXJhbWV0ZXIgZnJvbSByZXF1ZXN0XG4gIGNvbnN0IG9yaWdpbkRvbWFpbiA9IHJlcS5vcmlnaW47XG5cbiAgLy8gc2VyaWFsaXplIHJlcXVlc3QgYm9keVxuICBjb25zdCBzZXJpYWxpemVkUGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuXG4gIC8vIGNvbmZpZ3VyZSBmZXRjaCBwYXJhbXNcbiAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9LFxuICAgIGJvZHk6IHNlcmlhbGl6ZWRQYXlsb2FkXG4gIH07XG5cbiAgLy8gb3B0aW9uYWw6IGFkZCByZXF1ZXN0IG9yaWdpbiBhcyBoZWFkZXJcbiAgaWYgKG9yaWdpbkh0dHBIZWFkZXJLZXkgJiYgb3JpZ2luRG9tYWluKSB7XG4gICAgZmV0Y2hQYXJhbXMuaGVhZGVyc1tvcmlnaW5IdHRwSGVhZGVyS2V5XSA9IG9yaWdpbkRvbWFpbjtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZldGNoVXJsOiBwYXJzZWRVcmwuaHJlZixcbiAgICBmZXRjaFBhcmFtc1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlKHtcbiAgcnBjVGFyZ2V0LFxuICBvcmlnaW5IdHRwSGVhZGVyS2V5XG59KSB7XG4gIHJldHVybiBjcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBfbmV4dCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGZldGNoVXJsLFxuICAgICAgZmV0Y2hQYXJhbXNcbiAgICB9ID0gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxKHtcbiAgICAgIHJlcSxcbiAgICAgIHJwY1RhcmdldCxcbiAgICAgIG9yaWdpbkh0dHBIZWFkZXJLZXlcbiAgICB9KTtcblxuICAgIC8vIGF0dGVtcHQgcmVxdWVzdCBtdWx0aXBsZSB0aW1lc1xuICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNTtcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gMTAwMDtcbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IG1heEF0dGVtcHRzOyBhdHRlbXB0KyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZldGNoUmVzID0gYXdhaXQgZmV0Y2goZmV0Y2hVcmwsIGZldGNoUGFyYW1zKTtcbiAgICAgICAgLy8gY2hlY2sgZm9yIGh0dHAgZXJycm9yc1xuICAgICAgICBjaGVja0Zvckh0dHBFcnJvcnMoZmV0Y2hSZXMpO1xuICAgICAgICAvLyBwYXJzZSByZXNwb25zZSBib2R5XG4gICAgICAgIGNvbnN0IGZldGNoQm9keSA9IGF3YWl0IGZldGNoUmVzLmpzb24oKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VSZXNwb25zZShmZXRjaFJlcywgZmV0Y2hCb2R5KTtcbiAgICAgICAgLy8gc2V0IHJlc3VsdCBhbmQgZXhpdCByZXRyeSBsb29wXG4gICAgICAgIHJlcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJNc2cgPSAoZXJyLm1lc3NhZ2UgfHwgZXJyKS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBpc1JldHJpYWJsZSA9IFJFVFJJQUJMRV9FUlJPUlMuc29tZShwaHJhc2UgPT4gZXJyTXNnLmluY2x1ZGVzKHBocmFzZSkpO1xuICAgICAgICAvLyByZS10aHJvdyBlcnJvciBpZiBub3QgcmV0cmlhYmxlXG4gICAgICAgIGlmICghaXNSZXRyaWFibGUpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGRlbGF5IGJlZm9yZSByZXRyeWluZ1xuICAgICAgYXdhaXQgdGltZW91dChyZXRyeUludGVydmFsKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZlcnJlZFByb21pc2UoKSB7XG4gIGxldCByZXNvbHZlO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoX3Jlc29sdmUgPT4ge1xuICAgIHJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcmVzb2x2ZSxcbiAgICBwcm9taXNlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSh7XG4gIGNhY2hlSWRlbnRpZmllckZvclJlcXVlc3Rcbn0pIHtcbiAgY29uc3QgaW5mbGlnaHRSZXF1ZXN0cyA9IHt9O1xuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVBY3RpdmVSZXF1ZXN0SGFuZGxlcihyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc29sdmUsXG4gICAgICBwcm9taXNlXG4gICAgfSA9IGRlZmVycmVkUHJvbWlzZSgpO1xuICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5wdXNoKGhhbmRsZWRSZXMgPT4ge1xuICAgICAgLy8gYXBwZW5kIGEgY29weSBvZiB0aGUgcmVzdWx0IGFuZCBlcnJvciB0byB0aGUgcmVzcG9uc2VcbiAgICAgIHJlcy5yZXN1bHQgPSBjbG9uZURlZXAoaGFuZGxlZFJlcy5yZXN1bHQpO1xuICAgICAgcmVzLmVycm9yID0gY2xvbmVEZWVwKGhhbmRsZWRSZXMuZXJyb3IpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUFjdGl2ZVJlcXVlc3QocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAvLyB1c2Ugc2V0VGltZW91dCBzbyB3ZSBjYW4gcmVzb2x2ZSBvdXIgb3JpZ2luYWwgcmVxdWVzdCBmaXJzdFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGFuZGxlcihyZXMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBjYXRjaCBlcnJvciBzbyBhbGwgcmVxdWVzdHMgYXJlIGhhbmRsZWQgY29ycmVjdGx5XG4gICAgICAgICAgbG9nLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgLy8gYWxsb3cgY2FjaCB0byBiZSBza2lwcGVkIGlmIHNvIHNwZWNpZmllZFxuICAgIGlmIChyZXEuc2tpcENhY2hlKSB7XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cbiAgICAvLyBnZXQgY2FjaGVJZCwgaWYgY2FjaGVhYmxlXG4gICAgY29uc3QgY2FjaGVJZCA9IGNhY2hlSWRlbnRpZmllckZvclJlcXVlc3QocmVxKTtcbiAgICAvLyBpZiBub3QgY2FjaGVhYmxlLCBza2lwXG4gICAgaWYgKCFjYWNoZUlkKSB7XG4gICAgICBsb2cuaW5mbyhcIlJlcXVlc3QgaXMgbm90IGNhY2hlYWJsZSwgcHJvY2VlZGluZy4gcmVxID0gJW9cIiwgcmVxKTtcbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBtYXRjaGluZyByZXF1ZXN0c1xuICAgIGxldCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMgPSBpbmZsaWdodFJlcXVlc3RzW2NhY2hlSWRdO1xuICAgIC8vIGlmIGZvdW5kLCB3YWl0IGZvciB0aGUgYWN0aXZlIHJlcXVlc3QgdG8gYmUgaGFuZGxlZFxuICAgIGlmIChhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgIC8vIHNldHVwIHRoZSByZXNwb25zZSBsaXN0ZW5lciBhbmQgd2FpdCBmb3IgaXQgdG8gYmUgY2FsbGVkXG4gICAgICAvLyBpdCB3aWxsIGhhbmRsZSBjb3B5aW5nIHRoZSByZXN1bHQgYW5kIHJlcXVlc3QgZmllbGRzXG4gICAgICBsb2cuaW5mbyhcIlJ1bm5pbmcgJWkgaGFuZGxlcihzKSBmb3IgcmVxdWVzdCAlb1wiLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMubGVuZ3RoLCByZXEpO1xuICAgICAgYXdhaXQgY3JlYXRlQWN0aXZlUmVxdWVzdEhhbmRsZXIocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gc2V0dXAgcmVzcG9uc2UgaGFuZGxlciBhcnJheSBmb3Igc3Vic2VxdWVudCByZXF1ZXN0c1xuICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyA9IFtdO1xuICAgIGluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF0gPSBhY3RpdmVSZXF1ZXN0SGFuZGxlcnM7XG4gICAgLy8gYWxsb3cgcmVxdWVzdCB0byBiZSBoYW5kbGVkIG5vcm1hbGx5XG4gICAgbG9nLmluZm8oXCJDYXJyeWluZyBvcmlnaW5hbCByZXF1ZXN0IGZvcndhcmQgJW9cIiwgcmVxKTtcbiAgICBhd2FpdCBuZXh0KCk7XG4gICAgLy8gY2xlYXIgaW5mbGlnaHQgcmVxdWVzdHNcbiAgICBkZWxldGUgaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXTtcbiAgICAvLyBzY2hlZHVsZSBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMgdG8gYmUgaGFuZGxlZFxuICAgIGxvZy5pbmZvKFwiUnVubmluZyAlaSBjb2xsZWN0ZWQgaGFuZGxlcihzKSBmb3IgcmVxdWVzdCAlb1wiLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMubGVuZ3RoLCByZXEpO1xuICAgIGhhbmRsZUFjdGl2ZVJlcXVlc3QocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpO1xuICAgIC8vIGNvbXBsZXRlXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUob3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gbG9nZ2VyTWlkZGxld2FyZShyZXF1ZXN0LCByZXNwb25zZSwgbmV4dCkge1xuICAgIG5leHQoY2FsbGJhY2sgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgIGxvZy53YXJuKFwiRXJyb3IgaW4gUlBDIHJlc3BvbnNlOlxcblwiLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdC5pc1RvcnVzSW50ZXJuYWwpIHJldHVybjtcbiAgICAgIGxvZy5pbmZvKGBSUEMgKCR7b3B0aW9ucy5vcmlnaW59KTpgLCByZXF1ZXN0LCBcIi0+XCIsIHJlc3BvbnNlKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9yaWdpbk1pZGRsZXdhcmUob3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gb3JpZ2luTWlkZGxld2FyZShyZXF1ZXN0LCBfLCBuZXh0KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXF1ZXN0Lm9yaWdpbiA9IG9wdGlvbnMub3JpZ2luO1xuICAgIG5leHQoKTtcbiAgfTtcbn1cblxuY29uc3QgY3JlYXRlUmFuZG9tSWQgPSAoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG5jb25zdCBDSEFJTl9OQU1FU1BBQ0VTID0ge1xuICBFSVAxNTU6IFwiZWlwMTU1XCIsXG4gIFNPTEFOQTogXCJzb2xhbmFcIixcbiAgQ0FTUEVSOiBcImNhc3BlclwiLFxuICBYUlBMOiBcInhycGxcIixcbiAgT1RIRVI6IFwib3RoZXJcIlxufTtcbi8vIGVpcDE1NSBmb3IgYWxsIGV2bSBjaGFpbnNcblxuLyoqXG4gKiBDdXN0b20gbmV0d29yayBwcm9wZXJ0aWVzXG4gKiBAZXhhbXBsZSBpc0VJUDE1NTlDb21wYXRpYmxlOiB0cnVlIGV0Yy5cbiAqL1xuXG4vKipcbiAqXG4gKi9cblxuY2xhc3MgQnJvYWRjYXN0Q2hhbm5lbEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsUHJlZml4LCBpbnN0YW5jZUlkKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYmNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGFubmVsXCIsIHZvaWQgMCk7XG4gICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICBjb25zdCB3aW5kb3dJZCA9IHF1ZXJ5UGFyYW1ldGVycy5nZXQoXCJ3aW5kb3dJZFwiKTtcbiAgICB0aGlzLmNoYW5uZWwgPSBgJHtjaGFubmVsUHJlZml4fV8ke2luc3RhbmNlSWR9XyR7d2luZG93SWR9YDtcbiAgICB0aGlzLmJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwodGhpcy5jaGFubmVsLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gIH1cbiAgZ2V0TWVzc2FnZUZyb21DaGFubmVsKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmJjLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGFzeW5jIGV2ID0+IHtcbiAgICAgICAgdGhpcy5iYy5jbG9zZSgpO1xuICAgICAgICBpZiAoZXYuZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXYuZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZXYuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5iYy5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB0eXBlOiBQT1BVUF9MT0FERURcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgU3RyZWFtV2luZG93IGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29uZmlnLFxuICAgIHN0YXRlID0ge31cbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gICAgLy8gaWYgd2luZG93IGhhcyBiZWVuIGNsb3NlZCBieSB1c2Vyc1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsb3NlZFwiLCBmYWxzZSk7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgYXN5bmMgb3BlbigpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb21tdW5pY2F0aW9uRW5naW5lLFxuICAgICAgICBjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlclxuICAgICAgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgbGV0IHBvcHVwU3VjY2VzcyA9IGZhbHNlO1xuICAgICAgY29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXIub25jZShgJHt0aGlzLnN0YXRlLndpbmRvd0lkfTpjbG9zZWRgLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBXaW5kb3cgaXMgbm90IG9wZW4geWV0XG4gICAgICBpZiAoIXRoaXMuc3RhdGUud2luZG93SWQpIHtcbiAgICAgICAgLy8gc2luY2UsIHdlJ3JlIG9wZW5pbmcgd2luZG93IG5vdywgbm8gbmVlZCB0byB0ZWxsIHdpbmRvdyBhbnl0aGluZ1xuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgd2luZG93SWQ6IHJhbmRvbUlkKClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb25maWcuaGFuZGxlV2luZG93QmxvY2tBbGVydCAhPT0gXCJmdW5jdGlvblwiKSByZWplY3QobmV3IEVycm9yKFwiaGFuZGxlV2luZG93QmxvY2tBbGVydCBpcyBub3QgYSBmdW5jdGlvblwiKSk7XG4gICAgICAgIGNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyLm9uY2UoYCR7dGhpcy5zdGF0ZS53aW5kb3dJZH06aWZyYW1lLW9wZW5lZGAsICgpID0+IHtcbiAgICAgICAgICAvLyB0aGlzIG1lYW5zIGlmcmFtZSBpcyBmdWxsIHNjcmVlbiBub3dcbiAgICAgICAgICAvLyB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZSBibG9jayBhbGVydHMgYXQgYSB0aW1lLiBzbywgd2UgZG9uJ3Qgc2V0IGlmcmFtZSB0byBjbG9zZSBhZnRlciBoYW5kbGluZyB0aGlzIGhlcmVcbiAgICAgICAgICB0aGlzLmNvbmZpZy5oYW5kbGVXaW5kb3dCbG9ja0FsZXJ0KHtcbiAgICAgICAgICAgIHdpbmRvd0lkOiB0aGlzLnN0YXRlLndpbmRvd0lkLFxuICAgICAgICAgICAgZmluYWxVcmw6IHRoaXMuc3RhdGUudXJsLmhyZWZcbiAgICAgICAgICB9KS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRlbGwgdGhlIG90aGVyIHBhcnR5IHRvIG1heGltaXplIHRoZSBpZnJhbWVcbiAgICAgICAgY29tbXVuaWNhdGlvbkVuZ2luZS5lbWl0KFwibm90aWZpY2F0aW9uXCIsIHtcbiAgICAgICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fTk9USUZJQ0FUSU9OUy5JRlJBTUVfU1RBVFVTLFxuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgaXNGdWxsU2NyZWVuOiB0cnVlLFxuICAgICAgICAgICAgcmlkOiB0aGlzLnN0YXRlLndpbmRvd0lkXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBwcmUtb3BlbmVkIHdpbmRvdy4gc28sIHdlIG5lZWQgdG8gdGVsbCBpdCB0byByZWRpcmVjdCB0byBjb3JyZWN0IHVybC4gaXQncyBjdXJyZW50bHkgd2FpdGluZyBvbiAvcmVkaXJlY3QgYW5kIHVzZXMgYFJlZGlyZWN0SGFuZGxlcmAgY29kZVxuICAgICAgICAvLyBTZW5kIHRoaXMgd2luZG93IHdpdGggYHdpbmRvd0lkYCB0aGUgdXJsIHRvIG9wZW4gdmlhIGJjXG4gICAgICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gYCR7QlJPQURDQVNUX0NIQU5ORUxTLlJFRElSRUNUX0NIQU5ORUx9XyR7dGhpcy5jb25maWcuaW5zdGFuY2VJZH1fJHt0aGlzLnN0YXRlLndpbmRvd0lkfWA7XG4gICAgICAgIGNvbnN0IGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoY2hhbm5lbE5hbWUsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgYmMuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgYXN5bmMgZXYgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2cuaW5mbyhldiwgYHJlY2VpdmluZyBkYXRhIG9uIGNoYW5uZWw6ICR7YmMubmFtZX1gKTtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIH0gPSBldjtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAvLyBQb3B1cCBzYXlzIHNvbWUgZXJyb3IuIHNvLCB3ZSBzYXkgaXQncyBub3QgcmVhbGx5IG9wZW5lZFxuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICAgfSA9IGV2LmRhdGE7XG4gICAgICAgICAgICBpZiAobWVzc2FnZSA9PT0gUE9QVVBfTE9BREVEKSB7XG4gICAgICAgICAgICAgIHBvcHVwU3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICAgIGF3YWl0IGJjLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICB1cmw6IHRoaXMuc3RhdGUudXJsLmhyZWYsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlwiIC8vIE5vIG5lZWQgb2YgYSBtc2dcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgICBiYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgYmMuY2xvc2UoKTtcbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nLiBzbywgd2UgY2xvc2UgdGhhdCB3aW5kb3dcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFdlIGRvbid0IGtub3cgaWYgdGhlIG90aGVyIGVuZCBpcyByZWFkeSB0byByZWNlaXZlIHRoaXMgbXNnLiBTbywgd2Uga2VlcCB3cml0aW5nIHVudGlsIGl0IHJlY2VpdmVzIGFuZCBzZW5kcyBiYWNrIHNvbWV0aGluZ1xuICAgICAgICAvLyB3ZSBuZWVkIGJhY2tvZmYgc3RyYXRlZ3lcbiAgICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGZvciBmaXJzdCBhdHRlbXB0IHRvIHN1Y2NlZWQvZmFpbCB1bnRpbCB0aGUgc2Vjb25kIGF0dGVtcHRcbiAgICAgICAgLy8gSWYgd2UgZ2V0IDQyOSwgd2UgbmVlZCB0byB3YWl0IGZvciBhIHdoaWxlIGFuZCB0aGVuIHRyeSBhZ2FpblxuXG4gICAgICAgIGNvbnN0IHBvc3RNc2cgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgLy8gdGhpcyBuZXZlciB0aHJvd3NcbiAgICAgICAgICBjb25zdCBsb2NhbFJlc3BvbnNlID0gYXdhaXQgYmMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBtZXNzYWdlOiBTRVRVUF9DT01QTEVURVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBsb2NhbFJlc3BvbnNlO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgY3VycmVudERlbGF5ID0gYmMudHlwZSA9PT0gXCJzZXJ2ZXJcIiA/IDEwMDAgOiAyMDA7XG4gICAgICAgIGNvbnN0IHJlY3Vyc2l2ZUZuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmICghcG9wdXBTdWNjZXNzICYmICF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxSZXNwb25zZSA9IGF3YWl0IHBvc3RNc2coKTtcbiAgICAgICAgICAgIGlmIChiYy50eXBlID09PSBcInNlcnZlclwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNlcnZlclJlc3BvbnNlID0gbG9jYWxSZXNwb25zZTtcbiAgICAgICAgICAgICAgaWYgKHNlcnZlclJlc3BvbnNlLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHdhaXQgZm9yIGEgd2hpbGUgYW5kIHRoZW4gdHJ5IGFnYWluXG4gICAgICAgICAgICAgICAgY3VycmVudERlbGF5ID0gTWF0aC5yb3VuZChjdXJyZW50RGVsYXkgKiAxLjUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBzbGVlcChjdXJyZW50RGVsYXkpO1xuICAgICAgICAgICAgYXdhaXQgcmVjdXJzaXZlRm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlY3Vyc2l2ZUZuKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbXVuaWNhdGlvbkVuZ2luZVxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb21tdW5pY2F0aW9uRW5naW5lLmVtaXQoXCJub3RpZmljYXRpb25cIiwge1xuICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMuQ0xPU0VfV0lORE9XLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHdpbmRvd0lkOiB0aGlzLnN0YXRlLndpbmRvd0lkXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLypcblNjZW5hcmlvczpcbjEuIE9wZW4gYSBub3JtYWwgcG9wdXAgd2luZG93IGFuZCBubyBjb21tdW5pY2F0aW9uIHdpdGggaXQgLSBVc2UgUG9wdXBIYW5kbGVyXG4yLiBPcGVuIGEgcG9wdXAgd2luZG93IGFuZCBjb21tdW5pY2F0ZSB3aXRoIGl0IC0gVXNlIFBvcHVwV2l0aEJjSGFuZGxlciAoY2FuIGluaXRpYXRlIGNvbW11bmljYXRpb24gYnkgd2FpdGluZyBmb3Igd2luZG93IHRvIG9wZW4gb3Igbm90KVxuXG4zLiBJZiB3aW5kb3cgaXMgYWxyZWFkeSBvcGVuZWQsIHBhc3MgaW4gd2luZG93SWQgdG8gdGhlIHBvcHVwIGhhbmRsZXIuIFxuICAgVGhpcyB3aWxsIGVzdGFibGlzaCBjb21tdW5pY2F0aW9uIHdpdGggdGhlIHBvcHVwIHdpbmRvdyBhbmQgc2VuZHMgaXQgYSBuZXcgdXJsIHRvIHJlZGlyZWN0IHRvXG5cblxuSWYgeW91J3JlIHRyeWluZyB0byBvcGVuIGEgd2luZG93IGFuZCBpdCBnZXRzIGJsb2NrZWQgKGhhcHBlbnMgaWYgeW91J3JlIGluIGlmcmFtZSBvciBkZWxheSBiL3cgY2xpY2sgYW5kIG9wZW5pbmcgd2luZG93KSxcbiAgU3RyZWFtV2luZG93IGlzIGludm9rZWQgYW5kIGl0IHdyaXRlcyBpbiBhIGNoYW5uZWwgdG8gZGlzcGxheSBhIG1lc3NhZ2UgdG8gdGhlIHVzZXJcblxuT25jZSB1c2VyIGNsaWNrcyBvbiB0aGF0IG1vZGFsL2RpYWxvZywgd2UgcHJlLW9wZW4gdGhlIHdpbmRvdyBhbmQgcGFzcyBpbiB0aGUgd2luZG93SWQgKGdvZXMgdG8gMylcbiovXG5cbi8qKlxuICogSGFuZGxlcyBwb3B1cCB3aW5kb3cgbWFuYWdlbWVudC5cbiAqIEZvciBicm9hZGNhc3QgY2hhbm5lbCBjb21tdW5pY2F0aW9uLCB1c2UgdXJsIHdpdGggYGluc3RhbmNlSWRgIGNvZGVkIGludG8gc3RhdGUgcGFyYW1ldGVyLlxuICogVGhpcyBzdGF0ZSBwYXJhbWV0ZXIgd2lsbCBiZSBwYXNzZWQgYWNyb3NzIHJlZGlyZWN0cyBhY2NvcmRpbmcgdG8gT0F1dGggc3BlYy5cbiAqL1xuY2xhc3MgUG9wdXBIYW5kbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29uZmlnLFxuICAgIHN0YXRlXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIC8vIHRoaXMuaWQgPSByYW5kb21JZCgpXG4gICAgLy8gQWRkIGluIGRhcHAgc3RvcmFnZSBrZXkgdG8gYWxsIHBvcHVwcyBhcyBhIGhhc2ggcGFyYW1ldGVyXG4gICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgZmVhdHVyZXM6IGdldFBvcHVwRmVhdHVyZXMoRkVBVFVSRVNfREVGQVVMVF9QT1BVUF9XSU5ET1cpLFxuICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgY29tbXVuaWNhdGlvbkVuZ2luZTogbnVsbCxcbiAgICAgIGNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyOiBudWxsLFxuICAgICAgdGltZW91dDogMzAwMDAsXG4gICAgICBpbnN0YW5jZUlkOiBcIlwiLFxuICAgICAgaGFuZGxlV2luZG93QmxvY2tBbGVydDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICB3aW5kb3dUaW1lcjogbnVsbCxcbiAgICAgIHdpbmRvdzogbnVsbCxcbiAgICAgIGlDbG9zZWRXaW5kb3c6IGZhbHNlLFxuICAgICAgd2luZG93SWQ6IFwiXCIsXG4gICAgICB1cmw6IHN0YXRlLnVybFxuICAgIH07XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgdGhpcy5fc2V0dXBUaW1lcigpO1xuICB9XG4gIGFzeW5jIG9wZW4oKSB7XG4gICAgLy8gaWYgd2luZG93IGlzIGFscmVhZHkgb3BlblxuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgY29tbXVuaWNhdGlvbkVuZ2luZSxcbiAgICAgIGNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpbmRvd0lkLFxuICAgICAgdXJsXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgLy8gTm8gd2luZG93IGhhcyBiZWVuIHByZS1vcGVuZWRcbiAgICBpZiAoIXdpbmRvd0lkKSB7XG4gICAgICAvLyB0cnkgdG8gb3BlbiBhIHdpbmRvdyBmaXJzdFxuICAgICAgbGV0IGxvY2FsV2luZG93ID0gd2luZG93Lm9wZW4odXJsLmhyZWYsIHRhcmdldCwgZmVhdHVyZXMpO1xuICAgICAgbGV0IGZpbmFsV2luZG93SWQgPSBcIlwiO1xuICAgICAgaWYgKCFsb2NhbFdpbmRvdykge1xuICAgICAgICAvLyBpZiBpdCdzIGJsb2NrZWQsIG9wZW4gU3RyZWFtV2luZG93XG4gICAgICAgIGNvbnN0IHN0cmVhbVdpbmRvdyA9IG5ldyBTdHJlYW1XaW5kb3coe1xuICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgY29tbXVuaWNhdGlvbkVuZ2luZSxcbiAgICAgICAgICAgIGNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyLFxuICAgICAgICAgICAgaW5zdGFuY2VJZDogdGhpcy5jb25maWcuaW5zdGFuY2VJZCxcbiAgICAgICAgICAgIGhhbmRsZVdpbmRvd0Jsb2NrQWxlcnQ6IHRoaXMuY29uZmlnLmhhbmRsZVdpbmRvd0Jsb2NrQWxlcnRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICB1cmxcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW1XaW5kb3cub3BlbigpO1xuICAgICAgICBmaW5hbFdpbmRvd0lkID0gc3RyZWFtV2luZG93LnN0YXRlLndpbmRvd0lkO1xuICAgICAgICBsb2NhbFdpbmRvdyA9IHN0cmVhbVdpbmRvdztcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgd2luZG93OiBsb2NhbFdpbmRvdyxcbiAgICAgICAgd2luZG93SWQ6IGZpbmFsV2luZG93SWQgfHwgcmFuZG9tSWQoKVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEEgd2luZG93IGhhcyBiZWVuIHByZS1vcGVuZWQgd2l0aCBhIHF1ZXJ5IHBhcmFtZXRlciBgd2luZG93SWRgXG4gICAgY29uc3QgbG9jYWxXaW5kb3cgPSBuZXcgU3RyZWFtV2luZG93KHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBjb21tdW5pY2F0aW9uRW5naW5lLFxuICAgICAgICBjb21tdW5pY2F0aW9uV2luZG93TWFuYWdlcixcbiAgICAgICAgaW5zdGFuY2VJZDogdGhpcy5jb25maWcuaW5zdGFuY2VJZCxcbiAgICAgICAgaGFuZGxlV2luZG93QmxvY2tBbGVydDogdGhpcy5jb25maWcuaGFuZGxlV2luZG93QmxvY2tBbGVydFxuICAgICAgfSxcbiAgICAgIHN0YXRlOiB7XG4gICAgICAgIHVybCxcbiAgICAgICAgd2luZG93SWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICB3aW5kb3c6IGxvY2FsV2luZG93LFxuICAgICAgd2luZG93SWQ6IGxvY2FsV2luZG93LnN0YXRlLndpbmRvd0lkXG4gICAgfSk7XG4gICAgYXdhaXQgbG9jYWxXaW5kb3cub3BlbigpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIGlDbG9zZWRXaW5kb3c6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICB3aW5kb3dcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAod2luZG93KSB3aW5kb3cuY2xvc2UoKTtcbiAgfVxuICBfc2V0dXBUaW1lcigpIHtcbiAgICBjb25zdCB0aW1lciA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgd2luZG93VGltZXIsXG4gICAgICAgIGlDbG9zZWRXaW5kb3dcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cuY2xvc2VkKSB7XG4gICAgICAgIGlmICh3aW5kb3dUaW1lcikgY2xlYXJJbnRlcnZhbCh3aW5kb3dUaW1lcik7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghaUNsb3NlZFdpbmRvdykge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIGlDbG9zZWRXaW5kb3c6IGZhbHNlLFxuICAgICAgICAgICAgd2luZG93OiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMuY29uZmlnLnRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgaWYgKHdpbmRvdyA9PT0gbnVsbCAmJiB3aW5kb3dUaW1lcikgY2xlYXJJbnRlcnZhbCh3aW5kb3dUaW1lcik7XG4gICAgfSwgNTAwKTtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICB3aW5kb3dUaW1lcjogdGltZXJcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBBbHdheXMgbGlzdGVuaW5nIGNoYW5uZWxzLiBIZW5jZSwgbm8gd2luZG93IGlkXG5jbGFzcyBQb3B1cFN0b3JlQ2hhbm5lbCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBpbnN0YW5jZUlkLFxuICAgIGhhbmRsZUxvZ291dCxcbiAgICBoYW5kbGVBY2NvdW50SW1wb3J0LFxuICAgIGhhbmRsZU5ldHdvcmtDaGFuZ2UsXG4gICAgaGFuZGxlU2VsZWN0ZWRBZGRyZXNzQ2hhbmdlLFxuICAgIGhhbmRsZVRoZW1lQ2hhbmdlXG4gIH0pIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVMb2dvdXRcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVBY2NvdW50SW1wb3J0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlTmV0d29ya0NoYW5nZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZVRoZW1lQ2hhbmdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlU2VsZWN0ZWRBZGRyZXNzQ2hhbmdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5zdGFuY2VJZFwiLCB2b2lkIDApO1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IGluc3RhbmNlSWQ7XG4gICAgdGhpcy5oYW5kbGVMb2dvdXQgPSBoYW5kbGVMb2dvdXQ7XG4gICAgdGhpcy5oYW5kbGVBY2NvdW50SW1wb3J0ID0gaGFuZGxlQWNjb3VudEltcG9ydDtcbiAgICB0aGlzLmhhbmRsZU5ldHdvcmtDaGFuZ2UgPSBoYW5kbGVOZXR3b3JrQ2hhbmdlO1xuICAgIHRoaXMuaGFuZGxlU2VsZWN0ZWRBZGRyZXNzQ2hhbmdlID0gaGFuZGxlU2VsZWN0ZWRBZGRyZXNzQ2hhbmdlO1xuICAgIHRoaXMuaGFuZGxlVGhlbWVDaGFuZ2UgPSBoYW5kbGVUaGVtZUNoYW5nZTtcbiAgfVxuICBzZXR1cFN0b3JlQ2hhbm5lbHMoKSB7XG4gICAgdGhpcy5sb2dvdXRDaGFubmVsKCk7XG4gICAgdGhpcy5pbXBvcnRBY2NvdW50Q2hhbm5lbCgpO1xuICAgIHRoaXMubmV0d29ya0NoYW5nZUNoYW5uZWwoKTtcbiAgICB0aGlzLnNlbGVjdGVkQWRkcmVzc0NoYW5nZUNoYW5uZWwoKTtcbiAgICB0aGlzLnRoZW1lQ2hhbmdlZENoYW5uZWwoKTtcbiAgfVxuICBsb2dvdXRDaGFubmVsKCkge1xuICAgIGNvbnN0IGxvZ291dENoYW5uZWwgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChgJHtCUk9BRENBU1RfQ0hBTk5FTFMuV0FMTEVUX0xPR09VVF9DSEFOTkVMfV8ke3RoaXMuaW5zdGFuY2VJZH1gLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gICAgbG9nb3V0Q2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBldiA9PiB7XG4gICAgICB2YXIgX2V2JGRhdGE7XG4gICAgICBsb2cuaW5mbyhcInJlY2VpdmVkIGxvZ291dCBtZXNzYWdlXCIsIGV2KTtcbiAgICAgIGlmICghZXYuZXJyb3IgJiYgKChfZXYkZGF0YSA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXYkZGF0YS50eXBlKSA9PT0gQlJPQURDQVNUX0NIQU5ORUxTX01TR1MuTE9HT1VUKSB7XG4gICAgICAgIGxvZy5pbmZvKFwiTG9nZ2luZyBPdXRcIik7XG4gICAgICAgIHRoaXMuaGFuZGxlTG9nb3V0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaW1wb3J0QWNjb3VudENoYW5uZWwoKSB7XG4gICAgY29uc3Qgd2FsbGV0QWNjb3VudEltcG9ydENoYW5uZWwgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChgJHtCUk9BRENBU1RfQ0hBTk5FTFMuV0FMTEVUX0FDQ09VTlRfSU1QT1JUX0NIQU5ORUx9XyR7dGhpcy5pbnN0YW5jZUlkfWAsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcbiAgICB3YWxsZXRBY2NvdW50SW1wb3J0Q2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBldiA9PiB7XG4gICAgICB2YXIgX2V2JGRhdGEyO1xuICAgICAgaWYgKCFldi5lcnJvciAmJiAoKF9ldiRkYXRhMiA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGEyLnR5cGUpID09PSBCUk9BRENBU1RfQ0hBTk5FTFNfTVNHUy5BQ0NPVU5UX0lNUE9SVEVEKSB7XG4gICAgICAgIHZhciBfZXYkZGF0YTM7XG4gICAgICAgIHRoaXMuaGFuZGxlQWNjb3VudEltcG9ydCgoX2V2JGRhdGEzID0gZXYuZGF0YSkgPT09IG51bGwgfHwgX2V2JGRhdGEzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXYkZGF0YTMucHJpdktleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbmV0d29ya0NoYW5nZUNoYW5uZWwoKSB7XG4gICAgY29uc3Qgd2FsbGV0QWNjb3VudEltcG9ydENoYW5uZWwgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChgJHtCUk9BRENBU1RfQ0hBTk5FTFMuV0FMTEVUX05FVFdPUktfQ0hBTkdFX0NIQU5ORUx9XyR7dGhpcy5pbnN0YW5jZUlkfWAsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcbiAgICB3YWxsZXRBY2NvdW50SW1wb3J0Q2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBldiA9PiB7XG4gICAgICB2YXIgX2V2JGRhdGE0O1xuICAgICAgaWYgKCFldi5lcnJvciAmJiAoKF9ldiRkYXRhNCA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGE0LnR5cGUpID09PSBCUk9BRENBU1RfQ0hBTk5FTFNfTVNHUy5ORVRXT1JLX0NIQU5HRSkge1xuICAgICAgICB2YXIgX2V2JGRhdGE1O1xuICAgICAgICB0aGlzLmhhbmRsZU5ldHdvcmtDaGFuZ2UoKF9ldiRkYXRhNSA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhNSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGE1Lm5ldHdvcmspO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRoZW1lQ2hhbmdlZENoYW5uZWwoKSB7XG4gICAgY29uc3Qgd2FsbGV0QWNjb3VudEltcG9ydENoYW5uZWwgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChgJHtCUk9BRENBU1RfQ0hBTk5FTFMuVEhFTUVfQ0hBTkdFfV8ke3RoaXMuaW5zdGFuY2VJZH1gLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gICAgd2FsbGV0QWNjb3VudEltcG9ydENoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZXYgPT4ge1xuICAgICAgdmFyIF9ldiRkYXRhNjtcbiAgICAgIGxvZy5pbmZvKHtcbiAgICAgICAgZXZcbiAgICAgIH0pO1xuICAgICAgaWYgKCFldi5lcnJvciAmJiAoKF9ldiRkYXRhNiA9IGV2LmRhdGEpID09PSBudWxsIHx8IF9ldiRkYXRhNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2JGRhdGE2LnR5cGUpID09PSBCUk9BRENBU1RfQ0hBTk5FTFNfTVNHUy5TRVRfVEhFTUUpIHtcbiAgICAgICAgdmFyIF9ldiRkYXRhNztcbiAgICAgICAgdGhpcy5oYW5kbGVUaGVtZUNoYW5nZSgoX2V2JGRhdGE3ID0gZXYuZGF0YSkgPT09IG51bGwgfHwgX2V2JGRhdGE3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXYkZGF0YTcudGhlbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNlbGVjdGVkQWRkcmVzc0NoYW5nZUNoYW5uZWwoKSB7XG4gICAgY29uc3Qgd2FsbGV0QWNjb3VudEltcG9ydENoYW5uZWwgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChgJHtCUk9BRENBU1RfQ0hBTk5FTFMuV0FMTEVUX1NFTEVDVEVEX0FERFJFU1NfQ0hBTk5FTH1fJHt0aGlzLmluc3RhbmNlSWR9YCwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xuICAgIHdhbGxldEFjY291bnRJbXBvcnRDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGV2ID0+IHtcbiAgICAgIHZhciBfZXYkZGF0YTg7XG4gICAgICBpZiAoIWV2LmVycm9yICYmICgoX2V2JGRhdGE4ID0gZXYuZGF0YSkgPT09IG51bGwgfHwgX2V2JGRhdGE4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXYkZGF0YTgudHlwZSkgPT09IEJST0FEQ0FTVF9DSEFOTkVMU19NU0dTLlNFTEVDVEVEX0FERFJFU1NfQ0hBTkdFKSB7XG4gICAgICAgIHZhciBfZXYkZGF0YTk7XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0ZWRBZGRyZXNzQ2hhbmdlKChfZXYkZGF0YTkgPSBldi5kYXRhKSA9PT0gbnVsbCB8fCBfZXYkZGF0YTkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldiRkYXRhOS5zZWxlY3RlZEFkZHJlc3MpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUG9wdXBXaXRoQmNIYW5kbGVyIGlzIGEgUG9wdXBIYW5kbGVyIHdoaWNoIHVzZXMgYnJvYWRjYXN0IGNoYW5uZWwgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgcG9wdXAgd2luZG93LlxuICovXG5jbGFzcyBQb3B1cFdpdGhCY0hhbmRsZXIgZXh0ZW5kcyBQb3B1cEhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29uZmlnLFxuICAgIHN0YXRlLFxuICAgIGNoYW5uZWxQcmVmaXhcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hhbm5lbFByZWZpeFwiLCB2b2lkIDApO1xuICAgIHRoaXMuY2hhbm5lbFByZWZpeCA9IGNoYW5uZWxQcmVmaXg7XG4gIH1cblxuICAvKipcbiAgICogUmVjZWl2ZXMgdGhlIGRhdGEgZnJvbSBwb3B1cCB3aW5kb3cgYW5kIGNsb3NlcyB0aGUgd2luZG93XG4gICAqIEBwYXJhbSBzdWNjZXNzRXh0cmFGbiAtIEV4dHJhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciB0aGUgZGF0YSBpcyByZWNlaXZlZFxuICAgKiBAcmV0dXJucyBUaGUgZGF0YSB0byBiZSByZWNlaXZlZFxuICAgKi9cbiAgaGFuZGxlKHN1Y2Nlc3NFeHRyYUZuKSB7XG4gICAgY29uc3QgY2hhbm5lbE5hbWUgPSBgJHt0aGlzLmNoYW5uZWxQcmVmaXh9XyR7dGhpcy5jb25maWcuaW5zdGFuY2VJZH1fJHt0aGlzLnN0YXRlLndpbmRvd0lkfWA7XG4gICAgY29uc3QgYmMgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChjaGFubmVsTmFtZSwgYnJvYWRjYXN0Q2hhbm5lbE9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjbG9zZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICBiYy5jbG9zZSgpO1xuICAgICAgICByZWplY3QobmV3IFVzZXJFcnJvcihcInVzZXIgY2xvc2VkIHBvcHVwXCIpKTtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIGNsb3NlTGlzdGVuZXIpO1xuICAgICAgfTtcbiAgICAgIHRoaXMub24oXCJjbG9zZVwiLCBjbG9zZUxpc3RlbmVyKTtcbiAgICAgIGJjLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGFzeW5jIGV2ID0+IHtcbiAgICAgICAgbG9nLmluZm8oZXYsIGByZWNlaXZpbmcgZGF0YSBvbiBjaGFubmVsOiAke2JjLm5hbWV9YCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgICAgfSA9IGV2O1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3VjY2Vzc0V4dHJhRm4pIGF3YWl0IHN1Y2Nlc3NFeHRyYUZuLmNhbGwodGhpcywgZGF0YSk7XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGJjLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMub3BlbigpLnRoZW4oKCkgPT4ge1xuICAgICAgICBsb2cuaW5mbyhgb3BlbmVkIHdpbmRvdyAke2JjLm5hbWV9YCk7XG4gICAgICAgIC8vIE9wZW5lZCB3aW5kb3cuIHlheS4gIGxldCB0aGUgYmMgZXZlbnRzIGRvIHRoZWlyIGpvYlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgbG9nLmVycm9yKGVyciwgXCJzb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBvcGVuaW5nIHdpbmRvd1wiKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyBpZiB3ZSBoYXZlIHRvIHNlbmQgbGFyZ2UgcGF5bG9hZHMgd2hpY2ggZG9uJ3QgZml0IGluIHF1ZXJ5L2hhc2ggcGFyYW1zLlxuICAgKiBXYWl0cyBmb3IgYWNrIHRoYXQgcG9wdXAgd2luZG93IGlzIHJlYWR5IHRvIHJlY2VpdmUgZGF0YS5cbiAgICogUmVjZWl2ZXMgdGhlIGRhdGEgZnJvbSBwb3B1cCB3aW5kb3cgYW5kIGNsb3NlcyB0aGUgd2luZG93XG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIGRhdGEgdG8gYmUgc2VudCB0byB0aGUgcG9wdXAgd2luZG93IG9uY2Ugd2UgaGF2ZSBhY2sgdGhhdCB3aW5kb3cgaXMgcmVhZHkgdG8gcmVjZWl2ZSBkYXRhXG4gICAqIEBwYXJhbSBzdWNjZXNzRXh0cmFGbiAtIEV4dHJhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciB0aGUgZGF0YSBpcyByZWNlaXZlZFxuICAgKiBAcmV0dXJucyBUaGUgZGF0YSB0byBiZSByZWNlaXZlZFxuICAgKi9cbiAgaGFuZGxlV2l0aEhhbmRzaGFrZShwYXlsb2FkLCBzdWNjZXNzRXh0cmFGbikge1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gYCR7dGhpcy5jaGFubmVsUHJlZml4fV8ke3RoaXMuY29uZmlnLmluc3RhbmNlSWR9XyR7dGhpcy5zdGF0ZS53aW5kb3dJZH1gO1xuICAgIGNvbnN0IGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoY2hhbm5lbE5hbWUsIGJyb2FkY2FzdENoYW5uZWxPcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY2xvc2VMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgYmMuY2xvc2UoKTtcbiAgICAgICAgcmVqZWN0KG5ldyBVc2VyRXJyb3IoXCJ1c2VyIGNsb3NlZCBwb3B1cFwiKSk7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBjbG9zZUxpc3RlbmVyKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uKFwiY2xvc2VcIiwgY2xvc2VMaXN0ZW5lcik7XG4gICAgICBiYy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBhc3luYyBldiA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbG9nLmluZm8oZXYsIGByZWNlaXZpbmcgZGF0YSBvbiBjaGFubmVsOiAke2JjLm5hbWV9YCk7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgICAgfSA9IGV2O1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEbyBoYW5kc2hha2VcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0eXBlID0gXCJcIlxuICAgICAgICAgIH0gPSBkYXRhO1xuICAgICAgICAgIGlmICh0eXBlID09PSBQT1BVUF9MT0FERUQpIHtcbiAgICAgICAgICAgIC8vIEhhY2sgd2l0aCBnZW5lcmljIHRvIHVzZSB0aGUgc2FtZSB0eXBlIGZvciBib3RoIHNlbmQgYW5kIHJlY2VpdmVcbiAgICAgICAgICAgIGF3YWl0IGJjLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgZGF0YTogcGF5bG9hZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBQT1BVUF9SRVNVTFQpIHtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzRXh0cmFGbikgYXdhaXQgc3VjY2Vzc0V4dHJhRm4uY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAvLyBNdXN0IG9ubHkgY2xvc2UgdGhlIGJjIGFmdGVyIHJlc3VsdCBpcyBkb25lXG4gICAgICAgICAgICBiYy5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIGJjLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMub3BlbigpLnRoZW4oKCkgPT4ge1xuICAgICAgICBsb2cuaW5mbyhgb3BlbmVkIHdpbmRvdyAke2JjLm5hbWV9YCk7XG4gICAgICAgIC8vIE9wZW5lZCB3aW5kb3cuIHlheS4gIGxldCB0aGUgYmMgZXZlbnRzIGRvIHRoZWlyIGpvYlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgbG9nLmVycm9yKGVyciwgXCJzb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBvcGVuaW5nIHdpbmRvd1wiKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBSZWRpcmVjdEhhbmRsZXIge1xuICAvLyBwcml2YXRlIGhhc2hQYXJhbWV0ZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG4gIGNvbnN0cnVjdG9yKGluc3RhbmNlSWQpIHtcbiAgICAvLyBwcml2YXRlIGVycm9yOiBzdHJpbmc7XG4gICAgLy8gdGhpcyBpcyBzZXNzaW9uaWQgcG9zdCBsb2dpblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluc3RhbmNlSWRcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaW5hbFF1ZXJ5UGFyYW1zXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnN0YW5jZVBhcmFtZXRlcnNcIiwgdm9pZCAwKTtcbiAgICBjb25zdCB7XG4gICAgICBoYXNoXG4gICAgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xuICAgIHF1ZXJ5UGFyYW1ldGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICB0aGlzLmZpbmFsUXVlcnlQYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGluc3RhbmNlUGFyYW1ldGVyc1xuICAgIH0gPSBoYW5kbGVSZWRpcmVjdFBhcmFtZXRlcnMoaGFzaCwgdGhpcy5maW5hbFF1ZXJ5UGFyYW1zKTtcbiAgICAvLyB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5pbnN0YW5jZVBhcmFtZXRlcnMgPSBpbnN0YW5jZVBhcmFtZXRlcnM7XG4gICAgLy8gdGhpcy5oYXNoUGFyYW1ldGVycyA9IGhhc2hQYXJhbWV0ZXJzO1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IGluc3RhbmNlSWQ7XG4gIH1cbiAgYXN5bmMgaGFuZGxlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpbmFsUXVlcnlQYXJhbXMsXG4gICAgICAgIGluc3RhbmNlUGFyYW1ldGVyc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBsZXQgYmM7XG4gICAgICB0cnkge1xuICAgICAgICAvLyB1c2VkIGZvciBsb2dpbiBjYXNlLiB0aGVyZSdzIG5vIHdpbmRvd0lkIGhlcmVcbiAgICAgICAgLy8gaWYgKCFmaW5hbFF1ZXJ5UGFyYW1zLndpbmRvd0lkKSB7XG4gICAgICAgIC8vICAgYmMgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChgJHtCUk9BRENBU1RfQ0hBTk5FTFMuUkVESVJFQ1RfQ0hBTk5FTH1fJHtpbnN0YW5jZVBhcmFtZXRlcnMuaW5zdGFuY2VJZH1gLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gICAgICAgIC8vICAgYmMuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgYXN5bmMgKGV2KSA9PiB7XG4gICAgICAgIC8vICAgICBpZiAoZXYuZXJyb3IpIHtcbiAgICAgICAgLy8gICAgICAgcmVqZWN0KGV2LmVycm9yKTtcbiAgICAgICAgLy8gICAgICAgd2luZG93LmNsb3NlKCk7XG4gICAgICAgIC8vICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIC8vICAgICAgIGJjLmNsb3NlKCk7XG4gICAgICAgIC8vICAgICAgIGxvZy5pbmZvKFwicG9zdGVkXCIsIHsgZmluYWxRdWVyeVBhcmFtcywgaGFzaFBhcmFtZXRlcnMsIGluc3RhbmNlUGFyYW1ldGVycyB9KTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICB9KTtcbiAgICAgICAgLy8gICBiYy5wb3N0TWVzc2FnZSh7XG4gICAgICAgIC8vICAgICBkYXRhOiB7XG4gICAgICAgIC8vICAgICAgIGluc3RhbmNlUGFyYW1zOiBpbnN0YW5jZVBhcmFtZXRlcnMsXG4gICAgICAgIC8vICAgICAgIGhhc2hQYXJhbXM6IGhhc2hQYXJhbWV0ZXJzLFxuICAgICAgICAvLyAgICAgICBxdWVyeVBhcmFtczogZmluYWxRdWVyeVBhcmFtcyxcbiAgICAgICAgLy8gICAgIH0sXG4gICAgICAgIC8vICAgICBlcnJvcixcbiAgICAgICAgLy8gICB9KTtcblxuICAgICAgICAvLyAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAvLyAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICAgICAgICAvLyAgIH0sIDUwMDApO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjaGFubmVsTmFtZSA9IGAke0JST0FEQ0FTVF9DSEFOTkVMUy5SRURJUkVDVF9DSEFOTkVMfV8ke3RoaXMuaW5zdGFuY2VJZCB8fCBpbnN0YW5jZVBhcmFtZXRlcnMuaW5zdGFuY2VJZH1fJHtmaW5hbFF1ZXJ5UGFyYW1zLndpbmRvd0lkIHx8IGluc3RhbmNlUGFyYW1ldGVycy53aW5kb3dJZH1gO1xuICAgICAgICBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGNoYW5uZWxOYW1lLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucyk7XG4gICAgICAgIGJjLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGFzeW5jIGV2ID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgfSA9IGV2LmRhdGE7XG4gICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlID09PSBTRVRVUF9DT01QTEVURSkge1xuICAgICAgICAgICAgYXdhaXQgYmMucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgd2luZG93SWQ6IGZpbmFsUXVlcnlQYXJhbXMud2luZG93SWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogUE9QVVBfTE9BREVEXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXYuZXJyb3IgJiYgZXYuZXJyb3IgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihldi5lcnJvcik7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICBiYy5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cuaW5mbyhlcnIsIFwic29tZXRoaW5nIHdlbnQgd3JvbmdcIik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICBpZiAoYmMpIGJjLmNsb3NlKCk7XG4gICAgICAgIHdpbmRvdy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbnZhciBIVFRQX01FVEhPRCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoSFRUUF9NRVRIT0QpIHtcbiAgSFRUUF9NRVRIT0RbSFRUUF9NRVRIT0RbXCJHRVRcIl0gPSAwXSA9IFwiR0VUXCI7XG4gIEhUVFBfTUVUSE9EW0hUVFBfTUVUSE9EW1wiUE9TVFwiXSA9IDFdID0gXCJQT1NUXCI7XG4gIEhUVFBfTUVUSE9EW0hUVFBfTUVUSE9EW1wiUFVUXCJdID0gMl0gPSBcIlBVVFwiO1xuICBIVFRQX01FVEhPRFtIVFRQX01FVEhPRFtcIlBBVENIXCJdID0gM10gPSBcIlBBVENIXCI7XG4gIEhUVFBfTUVUSE9EW0hUVFBfTUVUSE9EW1wiREVMRVRFXCJdID0gNF0gPSBcIkRFTEVURVwiO1xuICByZXR1cm4gSFRUUF9NRVRIT0Q7XG59KEhUVFBfTUVUSE9EIHx8IHt9KTtcbmNvbnN0IGNvbnN0cnVjdEF1dGhIZWFkZXJzID0gKHtcbiAgand0VG9rZW4sXG4gIHB1YmxpY0FkZHJlc3Ncbn0pID0+IHtcbiAgcmV0dXJuIHtcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7and0VG9rZW59YCxcbiAgICAgIFwicHVibGljLWFkZHJlc3NcIjogcHVibGljQWRkcmVzc1xuICAgIH1cbiAgfTtcbn07XG5jb25zdCB3aXRoVW5hdXRob3JpemVkSGFuZGxlciA9IGFzeW5jIChmbiwgZW1pdHRlcikgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZm4oKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoaXNVbmF1dGhvcml6ZWRFcnJvcihlKSkge1xuICAgICAgZW1pdHRlci5lbWl0KENvbnRyb2xsZXJFdmVudHMuVXNlclVuYXV0aG9yaXplZCk7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn07XG5jb25zdCBqd3RUb2tlbkV4cGlyZWQgPSBqd3QgPT4ge1xuICBjb25zdCBkZWNvZGVkID0gand0RGVjb2RlKGp3dCk7XG4gIGNvbnN0IGp3dEV4cGlyeSA9IGRlY29kZWQuZXhwICogMTAwMDtcbiAgY29uc3QgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgcmV0dXJuIGN1cnJlbnRUaW1lID49IGp3dEV4cGlyeTtcbn07XG5jb25zdCBXU0FwaUNsaWVudCA9IChiYXNlQXBpVXJsLCBlbWl0dGVyKSA9PiB7XG4gIGNvbnN0IGF1dGhSZXF1ZXN0ID0gKG1ldGhvZCwgdXJsLCBkYXRhLCBhdXRoQ3JlZGVudGlhbHMsIGN1c3RvbU9wdGlvbnMpID0+IHtcbiAgICBpZiAoand0VG9rZW5FeHBpcmVkKGF1dGhDcmVkZW50aWFscy5qd3RUb2tlbikpIHtcbiAgICAgIGVtaXR0ZXIuZW1pdChDb250cm9sbGVyRXZlbnRzLlVzZXJVbmF1dGhvcml6ZWQpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aHJvdy1saXRlcmFsXG4gICAgICB0aHJvdyBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IDQwMSxcbiAgICAgICAgc3RhdHVzVGV4dDogXCJVbmF1dGhvcml6ZWRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfSwgY29uc3RydWN0QXV0aEhlYWRlcnMoYXV0aENyZWRlbnRpYWxzKSk7XG4gICAgaWYgKG1ldGhvZCA9PT0gSFRUUF9NRVRIT0QuR0VUKSB7XG4gICAgICByZXR1cm4gd2l0aFVuYXV0aG9yaXplZEhhbmRsZXIoKCkgPT4gZ2V0KHVybCwgaGVhZGVycywgY3VzdG9tT3B0aW9ucyksIGVtaXR0ZXIpO1xuICAgIH1cbiAgICBpZiAobWV0aG9kID09PSBIVFRQX01FVEhPRC5QT1NUKSB7XG4gICAgICByZXR1cm4gd2l0aFVuYXV0aG9yaXplZEhhbmRsZXIoKCkgPT4gcG9zdCh1cmwsIGRhdGEsIGhlYWRlcnMsIGN1c3RvbU9wdGlvbnMpLCBlbWl0dGVyKTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCA9PT0gSFRUUF9NRVRIT0QuUFVUKSB7XG4gICAgICByZXR1cm4gd2l0aFVuYXV0aG9yaXplZEhhbmRsZXIoKCkgPT4gcHV0KHVybCwgZGF0YSwgaGVhZGVycywgY3VzdG9tT3B0aW9ucyksIGVtaXR0ZXIpO1xuICAgIH1cbiAgICBpZiAobWV0aG9kID09PSBIVFRQX01FVEhPRC5QQVRDSCkge1xuICAgICAgcmV0dXJuIHdpdGhVbmF1dGhvcml6ZWRIYW5kbGVyKCgpID0+IHBhdGNoKHVybCwgZGF0YSwgaGVhZGVycywgY3VzdG9tT3B0aW9ucyksIGVtaXR0ZXIpO1xuICAgIH1cbiAgICBpZiAobWV0aG9kID09PSBIVFRQX01FVEhPRC5ERUxFVEUpIHtcbiAgICAgIHJldHVybiB3aXRoVW5hdXRob3JpemVkSGFuZGxlcigoKSA9PiByZW1vdmUodXJsLCBkYXRhLCBoZWFkZXJzLCBjdXN0b21PcHRpb25zKSwgZW1pdHRlcik7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIGF1dGhHZXQ6ICh1cmwsIGF1dGhDcmVkZW50aWFscywgY3VzdG9tT3B0aW9ucykgPT4gYXV0aFJlcXVlc3QoSFRUUF9NRVRIT0QuR0VULCBgJHtiYXNlQXBpVXJsfS8ke3VybH1gLCB7fSwgYXV0aENyZWRlbnRpYWxzLCBjdXN0b21PcHRpb25zKSxcbiAgICBhdXRoUG9zdDogKHVybCwgZGF0YSwgYXV0aENyZWRlbnRpYWxzLCBjdXN0b21PcHRpb25zKSA9PiBhdXRoUmVxdWVzdChIVFRQX01FVEhPRC5QT1NULCBgJHtiYXNlQXBpVXJsfS8ke3VybH1gLCBkYXRhLCBhdXRoQ3JlZGVudGlhbHMsIGN1c3RvbU9wdGlvbnMpLFxuICAgIGF1dGhQdXQ6ICh1cmwsIGRhdGEsIGF1dGhDcmVkZW50aWFscywgY3VzdG9tT3B0aW9ucykgPT4gYXV0aFJlcXVlc3QoSFRUUF9NRVRIT0QuUFVULCBgJHtiYXNlQXBpVXJsfS8ke3VybH1gLCBkYXRhLCBhdXRoQ3JlZGVudGlhbHMsIGN1c3RvbU9wdGlvbnMpLFxuICAgIGF1dGhQYXRjaDogKHVybCwgZGF0YSwgYXV0aENyZWRlbnRpYWxzLCBjdXN0b21PcHRpb25zKSA9PiBhdXRoUmVxdWVzdChIVFRQX01FVEhPRC5QQVRDSCwgYCR7YmFzZUFwaVVybH0vJHt1cmx9YCwgZGF0YSwgYXV0aENyZWRlbnRpYWxzLCBjdXN0b21PcHRpb25zKSxcbiAgICBhdXRoUmVtb3ZlOiAodXJsLCBkYXRhLCBhdXRoQ3JlZGVudGlhbHMsIGN1c3RvbU9wdGlvbnMpID0+IGF1dGhSZXF1ZXN0KEhUVFBfTUVUSE9ELkRFTEVURSwgYCR7YmFzZUFwaVVybH0vJHt1cmx9YCwgZGF0YSwgYXV0aENyZWRlbnRpYWxzLCBjdXN0b21PcHRpb25zKVxuICB9O1xufTtcblxuY29uc3QgQUNUSVZJVFlfQUNUSU9OID0ge1xuICBBQ1RJVklUWV9BQ1RJT05fQUxMOiBcIndhbGxldEFjdGl2aXR5LmFsbFRyYW5zYWN0aW9uc1wiLFxuICBBQ1RJVklUWV9BQ1RJT05fU0VORDogXCJ3YWxsZXRBY3Rpdml0eS5zZW5kXCIsXG4gIEFDVElWSVRZX0FDVElPTl9SRUNFSVZFOiBcIndhbGxldEFjdGl2aXR5LnJlY2VpdmVcIixcbiAgQUNUSVZJVFlfQUNUSU9OX1RPUFVQOiBcIndhbGxldEFjdGl2aXR5LnRvcHVwXCJcbn07XG5jb25zdCBBQ0NPVU5UX0NBVEVHT1JZID0ge1xuICBOT1JNQUw6IFwibm9ybWFsXCIsXG4gIFRIUkVTSE9MRDogXCJ0aHJlc2hvbGRcIixcbiAgSU1QT1JURUQ6IFwiaW1wb3J0ZWRcIixcbiAgLy8gd2UgaGF2ZSBwcml2YXRlIGtleSBoZXJlXG4gIEFQUF9TQ09QRUQ6IFwiYXBwX3Njb3BlZFwiLFxuICBBQ0NPVU5UX0FCU1RSQUNUSU9OOiBcImFjY291bnRfYWJzdHJhY3Rpb25cIixcbiAgRVhURVJOQUw6IFwiZXh0ZXJuYWxcIixcbiAgLy8gbGlrZSBtZXRhbWFzaywgd2FsbGV0IGNvbm5lY3RcbiAgTVBDOiBcIm1wY1wiLFxuICBTRkE6IFwic2ZhXCJcbn07XG5cbi8qKlxuICogUHJlZmVyZW5jZXMgY29udHJvbGxlciBzdGF0ZVxuICovXG5cbi8qKlxuICogQHBhcmFtIGFkZHJlc3MgLSBhZGRyZXNzIG9mIHRoZSB1c2VyXG4gKiBAcGFyYW0gand0VG9rZW4gLSBpZiBqd3QgdG9rZW4gYWxyZWFkeSBleGlzdHMsIGl0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIGZldGNoaW5nIGZyb20gYmFja2VuZFxuICogQHBhcmFtIGNhbGxlZEZyb21FbWJlZCAtIGlmIGNhbGxlZCBmcm9tIGVtYmVkXG4gKiBAcGFyYW0gdXNlckluZm8gLSBvcHRpb25hbCB1c2VyIGluZm9cbiAqIEBwYXJhbSByZWh5ZHJhdGUgLSBSZWh5ZHJhdGUgdGhlIHByZWZlcmVuY2VzIGZyb20gdGhlIGxvY2FsIHN0b3JhZ2VcbiAqL1xuXG4vLyBCeSBkZWZhdWx0LCBwb2xsIGV2ZXJ5IDMgbWludXRlc1xuY29uc3QgREVGQVVMVF9JTlRFUlZBTCA9IDE4MCAqIDEwMDA7XG5jb25zdCBERUZBVUxUX1BSRUZFUkVOQ0VTID0ge1xuICBzZWxlY3RlZEN1cnJlbmN5OiBcIlVTRFwiLFxuICB0aGVtZTogXCJkYXJrXCIsXG4gIGxvY2FsZTogXCJlblwiLFxuICBhY2NvdW50VHlwZTogQUNDT1VOVF9DQVRFR09SWS5OT1JNQUwsXG4gIGNvbnRhY3RzOiBbXSxcbiAgand0VG9rZW46IFwiXCIsXG4gIGZldGNoZWRQYXN0VHg6IFtdLFxuICBwYXN0VHJhbnNhY3Rpb25zOiBbXSxcbiAgcGF5bWVudFR4OiBbXSxcbiAgZGVmYXVsdFB1YmxpY0FkZHJlc3M6IFwiXCIsXG4gIGN1c3RvbVRva2VuczogW10sXG4gIGN1c3RvbU5mdHM6IFtdLFxuICBjcmFzaFJlcG9ydDogdHJ1ZSxcbiAgdXNlckluZm86IHtcbiAgICBhZ2dyZWdhdGVWZXJpZmllcjogXCJcIixcbiAgICBlbWFpbDogXCJcIixcbiAgICBuYW1lOiBcIlwiLFxuICAgIHByb2ZpbGVJbWFnZTogXCJcIixcbiAgICB0eXBlT2ZMb2dpbjogTE9HSU5fUFJPVklERVIuR09PR0xFLFxuICAgIHZlcmlmaWVyOiBcIlwiLFxuICAgIHZlcmlmaWVySWQ6IFwiXCJcbiAgfVxufTtcblxuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgc3RvcmVzIHNoYXJlZCBzZXR0aW5ncyBhbmQgZXhwb3NlcyBjb252ZW5pZW5jZSBtZXRob2RzXG4gKi9cbmNsYXNzIEJhc2VQcmVmZXJlbmNlc0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUHJlZmVyZW5jZXNDb250cm9sbGVyIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyXG4gICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlclxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbmZpZyxcbiAgICBzdGF0ZSxcbiAgICBkZWZhdWx0UHJlZmVyZW5jZXMsXG4gICAgc2lnbkF1dGhNZXNzYWdlLFxuICAgIHZhbGlkYXRlU2lnbk1lc3NhZ2VcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHN0YXRlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIFwiUHJlZmVyZW5jZXNDb250cm9sbGVyXCIpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlmcmFtZU9yaWdpblwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndzQXBpQ2xpZW50XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2lnbkF1dGhNZXNzYWdlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsaWRhdGVTaWduTWVzc2FnZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRQcmVmZXJlbmNlc1wiLCB2b2lkIDApO1xuICAgIGlmICghY29uZmlnLmFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJlZmVyZW5jZXNDb250cm9sbGVyIC0gbm8gYXBpIHNwZWNpZmllZCBpbiBjb25maWcuXCIpO1xuICAgIH1cbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgIGlkZW50aXRpZXM6IHt9LFxuICAgICAgc2VsZWN0ZWRBZGRyZXNzOiBcIlwiLFxuICAgICAgbGFzdEVycm9yTWVzc2FnZTogXCJcIixcbiAgICAgIGxhc3RTdWNjZXNzTWVzc2FnZTogXCJcIlxuICAgIH07XG4gICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgYXBpOiBjb25maWcuYXBpLFxuICAgICAgcG9sbEludGVydmFsOiBERUZBVUxUX0lOVEVSVkFMXG4gICAgfTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB0aGlzLmRlZmF1bHRQcmVmZXJlbmNlcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgREVGQVVMVF9QUkVGRVJFTkNFUyksIGRlZmF1bHRQcmVmZXJlbmNlcyk7XG4gICAgdGhpcy5zaWduQXV0aE1lc3NhZ2UgPSBzaWduQXV0aE1lc3NhZ2U7XG4gICAgdGhpcy52YWxpZGF0ZVNpZ25NZXNzYWdlID0gdmFsaWRhdGVTaWduTWVzc2FnZTtcbiAgICB0aGlzLndzQXBpQ2xpZW50ID0gV1NBcGlDbGllbnQodGhpcy5jb25maWcuYXBpLCB0aGlzKTtcbiAgfVxuICBzZXRJZnJhbWVPcmlnaW4ob3JpZ2luKSB7XG4gICAgdGhpcy5pZnJhbWVPcmlnaW4gPSBvcmlnaW47XG4gIH1cbiAgZ2V0QWRkcmVzc1N0YXRlKGFkZHJlc3MpIHtcbiAgICBjb25zdCBzZWxlY3RlZEFkZHJlc3MgPSBhZGRyZXNzIHx8IHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzO1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmlkZW50aXRpZXNbc2VsZWN0ZWRBZGRyZXNzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHNlbGVjdGVkIGFkZHJlc3NcbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdGVkQWRkcmVzcyAtIGNhc3BlciBhY2NvdW50IGhhc2hcbiAgICovXG4gIHNldFNlbGVjdGVkQWRkcmVzcyhzZWxlY3RlZEFkZHJlc3MpIHtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICBzZWxlY3RlZEFkZHJlc3NcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRVc2VyKGFkZHJlc3MpIHtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoR2V0KFwidXNlcj9mZXRjaFR4PWZhbHNlXCIsIHRoaXMuYXV0aENyZWRlbnRpYWxzKGFkZHJlc3MpLCB7XG4gICAgICB1c2VBUElLZXk6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdXNlci5kYXRhO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVVzZXIocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2VsZWN0ZWRDdXJyZW5jeSxcbiAgICAgIHRoZW1lLFxuICAgICAgdmVyaWZpZXIsXG4gICAgICB2ZXJpZmllcklkLFxuICAgICAgbG9jYWxlLFxuICAgICAgYWRkcmVzcyxcbiAgICAgIGlkVG9rZW4sXG4gICAgICB0eXBlLFxuICAgICAgd2ViM0F1dGhOZXR3b3JrXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB1c2VyUGF5bG9hZCA9IHtcbiAgICAgIGRlZmF1bHRfY3VycmVuY3k6IHNlbGVjdGVkQ3VycmVuY3ksXG4gICAgICB0aGVtZSxcbiAgICAgIHZlcmlmaWVyLFxuICAgICAgdmVyaWZpZXJfaWQ6IHZlcmlmaWVySWQsXG4gICAgICBsb2NhbGUsXG4gICAgICBpZFRva2VuLFxuICAgICAgYWNjb3VudF90eXBlOiB0eXBlLFxuICAgICAgd2ViM2F1dGhfbmV0d29yazogd2ViM0F1dGhOZXR3b3JrXG4gICAgfTtcbiAgICBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhQb3N0KFwidXNlclwiLCB1c2VyUGF5bG9hZCwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoYWRkcmVzcyksIHtcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgdGhlbWUsXG4gICAgICBkZWZhdWx0UHVibGljQWRkcmVzczogYWRkcmVzcyxcbiAgICAgIHNlbGVjdGVkQ3VycmVuY3ksXG4gICAgICBsb2NhbGUsXG4gICAgICBhY2NvdW50VHlwZTogdHlwZVxuICAgIH0sIGFkZHJlc3MpO1xuICB9XG4gIGFzeW5jIHN0b3JlVXNlckxvZ2luKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZlcmlmaWVySWQsXG4gICAgICB2ZXJpZmllcixcbiAgICAgIG9wdGlvbnMsXG4gICAgICBhZGRyZXNzLFxuICAgICAgaWRUb2tlbixcbiAgICAgIHdlYjNBdXRoQ2xpZW50SWQsXG4gICAgICB3ZWIzQXV0aE5ldHdvcmssXG4gICAgICBzZXNzaW9uUHViS2V5LFxuICAgICAgbG9naW5Nb2RlXG4gICAgfSA9IHBhcmFtcztcbiAgICBpZiAoIW9wdGlvbnMucmVoeWRyYXRlKSB7XG4gICAgICBjb25zdCBicm93c2VyID0gYm93c2VyLmdldFBhcnNlcih3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICBjb25zdCBzcGVjaWFsQnJvd3NlciA9IGdldEN1c3RvbURldmljZUluZm8oKTtcbiAgICAgIGNvbnN0IHJlY29yZExvZ2luUGF5bG9hZCA9IHtcbiAgICAgICAgb3M6IGJyb3dzZXIuZ2V0T1NOYW1lKCksXG4gICAgICAgIG9zX3ZlcnNpb246IGJyb3dzZXIuZ2V0T1NWZXJzaW9uKCkgfHwgXCJ1bmlkZW50aWZpZWRcIixcbiAgICAgICAgYnJvd3NlcjogKHNwZWNpYWxCcm93c2VyID09PSBudWxsIHx8IHNwZWNpYWxCcm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGVjaWFsQnJvd3Nlci5icm93c2VyKSB8fCBicm93c2VyLmdldEJyb3dzZXJOYW1lKCkgfHwgXCJ1bmlkZW50aWZpZWRcIixcbiAgICAgICAgYnJvd3Nlcl92ZXJzaW9uOiBicm93c2VyLmdldEJyb3dzZXJWZXJzaW9uKCkgfHwgXCJ1bmlkZW50aWZpZWRcIixcbiAgICAgICAgcGxhdGZvcm06IGJyb3dzZXIuZ2V0UGxhdGZvcm0oKS50eXBlIHx8IFwiZGVza3RvcFwiLFxuICAgICAgICBob3N0bmFtZTogdGhpcy5pZnJhbWVPcmlnaW4sXG4gICAgICAgIHZlcmlmaWVyLFxuICAgICAgICB2ZXJpZmllcl9pZDogdmVyaWZpZXJJZCxcbiAgICAgICAgaWRUb2tlbixcbiAgICAgICAgd2ViM2F1dGhfY2xpZW50X2lkOiB3ZWIzQXV0aENsaWVudElkLFxuICAgICAgICB3ZWIzYXV0aF9uZXR3b3JrOiB3ZWIzQXV0aE5ldHdvcmssXG4gICAgICAgIHNlc3Npb25fcHViX2tleTogc2Vzc2lvblB1YktleSxcbiAgICAgICAgbG9naW5fbW9kZTogbG9naW5Nb2RlXG4gICAgICB9O1xuICAgICAgYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoUG9zdChcInVzZXIvcmVjb3JkTG9naW5cIiwgcmVjb3JkTG9naW5QYXlsb2FkLCB0aGlzLmF1dGhDcmVkZW50aWFscyhhZGRyZXNzKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyBzZXRDcmFzaFJlcG9ydChpc0VuYWJsZWQpIHtcbiAgICB2YXIgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlO1xuICAgIGlmIChpc0VuYWJsZWQgPT09ICgoX3RoaXMkZ2V0QWRkcmVzc1N0YXRlID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRBZGRyZXNzU3RhdGUuY3Jhc2hSZXBvcnQpKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoUGF0Y2goXCJ1c2VyXCIsIHtcbiAgICAgICAgZW5hYmxlX2NyYXNoX3JlcG9ydGVyOiBpc0VuYWJsZWRcbiAgICAgIH0sIHRoaXMuYXV0aENyZWRlbnRpYWxzKCksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICBjcmFzaFJlcG9ydDogaXNFbmFibGVkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhc3luYyBzZXRVc2VyVGhlbWUodGhlbWUpIHtcbiAgICB2YXIgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlMjtcbiAgICBpZiAodGhlbWUgPT09ICgoX3RoaXMkZ2V0QWRkcmVzc1N0YXRlMiA9IHRoaXMuZ2V0QWRkcmVzc1N0YXRlKCkpID09PSBudWxsIHx8IF90aGlzJGdldEFkZHJlc3NTdGF0ZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldEFkZHJlc3NTdGF0ZTIudGhlbWUpKSByZXR1cm4gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoUGF0Y2goXCJ1c2VyXCIsIHtcbiAgICAgICAgdGhlbWVcbiAgICAgIH0sIHRoaXMuYXV0aENyZWRlbnRpYWxzKCksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICB0aGVtZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2V0VXNlckxvY2FsZShsb2NhbGUpIHtcbiAgICB2YXIgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlMztcbiAgICBpZiAobG9jYWxlID09PSAoKF90aGlzJGdldEFkZHJlc3NTdGF0ZTMgPSB0aGlzLmdldEFkZHJlc3NTdGF0ZSgpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXRBZGRyZXNzU3RhdGUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRBZGRyZXNzU3RhdGUzLmxvY2FsZSkpIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoUGF0Y2goXCJ1c2VyXCIsIHtcbiAgICAgICAgbG9jYWxlXG4gICAgICB9LCB0aGlzLmF1dGhDcmVkZW50aWFscygpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgbG9jYWxlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJ1bmFibGUgdG8gc2V0IGxvY2FsZVwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNldFNlbGVjdGVkQ3VycmVuY3kocGF5bG9hZCkge1xuICAgIHZhciBfdGhpcyRnZXRBZGRyZXNzU3RhdGU0O1xuICAgIGlmIChwYXlsb2FkLnNlbGVjdGVkQ3VycmVuY3kgPT09ICgoX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNCA9IHRoaXMuZ2V0QWRkcmVzc1N0YXRlKCkpID09PSBudWxsIHx8IF90aGlzJGdldEFkZHJlc3NTdGF0ZTQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldEFkZHJlc3NTdGF0ZTQuc2VsZWN0ZWRDdXJyZW5jeSkpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhQYXRjaChcInVzZXJcIiwge1xuICAgICAgICBkZWZhdWx0X2N1cnJlbmN5OiBwYXlsb2FkLnNlbGVjdGVkQ3VycmVuY3lcbiAgICAgIH0sIHRoaXMuYXV0aENyZWRlbnRpYWxzKCksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgICBzZWxlY3RlZEN1cnJlbmN5OiBwYXlsb2FkLnNlbGVjdGVkQ3VycmVuY3lcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIGFkZENvbnRhY3QoY29udGFjdCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoUG9zdChcImNvbnRhY3RcIiwgY29udGFjdCwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgIGNvbnRhY3RzOiBbLi4uKCgoX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNSA9IHRoaXMuZ2V0QWRkcmVzc1N0YXRlKCkpID09PSBudWxsIHx8IF90aGlzJGdldEFkZHJlc3NTdGF0ZTUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldEFkZHJlc3NTdGF0ZTUuY29udGFjdHMpIHx8IFtdKSwgcmVzcG9uc2UuZGF0YV1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihcInVuYWJsZSB0byBhZGQgY29udGFjdFwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRlbGV0ZUNvbnRhY3QoY29udGFjdElkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdGhpcyRnZXRBZGRyZXNzU3RhdGU2O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhSZW1vdmUoYGNvbnRhY3QvJHtjb250YWN0SWR9YCwge30sIHRoaXMuYXV0aENyZWRlbnRpYWxzKCksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGZpbmFsQ29udGFjdHMgPSAoX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNiA9IHRoaXMuZ2V0QWRkcmVzc1N0YXRlKCkpID09PSBudWxsIHx8IF90aGlzJGdldEFkZHJlc3NTdGF0ZTYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldEFkZHJlc3NTdGF0ZTYuY29udGFjdHMuZmlsdGVyKGNvbnRhY3QgPT4gY29udGFjdC5pZCAhPT0gcmVzcG9uc2UuZGF0YS5pZCk7XG4gICAgICBpZiAoZmluYWxDb250YWN0cykgdGhpcy51cGRhdGVTdGF0ZSh7XG4gICAgICAgIGNvbnRhY3RzOiBbLi4uZmluYWxDb250YWN0c11cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihcInVuYWJsZSB0byBkZWxldGUgY29udGFjdFwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJldm9rZURpc2NvcmQoaWRUb2tlbikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoUG9zdChcInJldm9rZS9kaXNjb3JkXCIsIHtcbiAgICAgICAgdG9rZW46IGlkVG9rZW5cbiAgICAgIH0sIHRoaXMuYXV0aENyZWRlbnRpYWxzKCksIHtcbiAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGxvZy5pbmZvKHJlc3ApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBwYXRjaFBhc3RUeChib2R5LCBhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoUGF0Y2goXCJ0cmFuc2FjdGlvblwiLCBib2R5LCB0aGlzLmF1dGhDcmVkZW50aWFscyhhZGRyZXNzKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgbG9nLmluZm8oXCJzdWNjZXNzZnVsbHkgcGF0Y2hlZFwiLCByZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihcInVuYWJsZSB0byBwYXRjaCB0eFwiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIHBvc3RQYXN0VHgodHgsIGFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhQb3N0KFwidHJhbnNhY3Rpb25cIiwgdHgsIHRoaXMuYXV0aENyZWRlbnRpYWxzKGFkZHJlc3MpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBsb2cuaW5mbyhcInN1Y2Nlc3NmdWxseSBwb3N0ZWQgdHhcIiwgcmVzcG9uc2UpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyb3IsIFwidW5hYmxlIHRvIGluc2VydCB0cmFuc2FjdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0V2FsbGV0T3JkZXJzKGFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhHZXQoXCJ0cmFuc2FjdGlvblwiLCB0aGlzLmF1dGhDcmVkZW50aWFscyhhZGRyZXNzKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLnN1Y2Nlc3MgPyByZXNwb25zZS5kYXRhID8gcmVzcG9uc2UuZGF0YSA6IFtdIDogW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihcInVuYWJsZSB0byBnZXQgd2FsbGV0IG9yZGVycyB0eFwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldFRvcFVwT3JkZXJzKGFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndzQXBpQ2xpZW50LmF1dGhHZXQoXCJ0cmFuc2FjdGlvblwiLCB0aGlzLmF1dGhDcmVkZW50aWFscyhhZGRyZXNzKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEgfHwgW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihcInVuYWJsZSB0byBmZXRjaCBwYXN0IFRvcCB1cCBvcmRlcnNcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBnZXRCaWxsQm9hcmREYXRhKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aEdldChcImJpbGxib2FyZFwiLCB0aGlzLmF1dGhDcmVkZW50aWFscygpLCB7XG4gICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2Uuc3VjY2VzcyA/IHJlc3BvbnNlLmRhdGEgOiBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKFwidW5hYmxlIHRvIGdldCBiaWxsYm9hcmQgZGF0YVwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldE1lc3NhZ2VGb3JTaWduaW5nKHB1YmxpY0FkZHJlc3MsIHdlYjNBdXRoSWRUb2tlbikge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdChgJHt0aGlzLmNvbmZpZy5hcGl9L2F1dGgvbWVzc2FnZWAsIHtcbiAgICAgIHB1YmxpY19hZGRyZXNzOiBwdWJsaWNBZGRyZXNzLFxuICAgICAgaWRfdG9rZW46IHdlYjNBdXRoSWRUb2tlblxuICAgIH0sIHt9LCB7XG4gICAgICB1c2VBUElLZXk6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UubWVzc2FnZTtcbiAgfVxuICBhc3luYyBnZXRUd2l0dGVySWQocGF5bG9hZCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMud3NBcGlDbGllbnQuYXV0aEdldChgdHdpdHRlcj9zY3JlZW5fbmFtZT0ke3BheWxvYWQubmlja31gLCB0aGlzLmF1dGhDcmVkZW50aWFscygpLCB7XG4gICAgICB1c2VBUElLZXk6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gYCR7cGF5bG9hZC50eXBlT2ZMb2dpbi50b0xvd2VyQ2FzZSgpfXwke3Jlcy5kYXRhLnRvU3RyaW5nKCl9YDtcbiAgfVxuICBhc3luYyBzZW5kRW1haWwocGF5bG9hZCkge1xuICAgIHJldHVybiB0aGlzLndzQXBpQ2xpZW50LmF1dGhQb3N0KFwidHJhbnNhY3Rpb24vc2VuZGVtYWlsXCIsIHBheWxvYWQuZW1haWxPYmplY3QsIHRoaXMuYXV0aENyZWRlbnRpYWxzKCksIHtcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHJlZnJlc2hKd3QoKSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzO1xuICAgIGNvbnN0IG1lc3NhZ2VUb1NpZ24gPSBhd2FpdCB0aGlzLmdldE1lc3NhZ2VGb3JTaWduaW5nKGFkZHJlc3MpO1xuICAgIGF3YWl0IHRoaXMudmFsaWRhdGVTaWduTWVzc2FnZShtZXNzYWdlVG9TaWduKTtcbiAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gYXdhaXQgdGhpcy5zaWduQXV0aE1lc3NhZ2UoYWRkcmVzcywgbWVzc2FnZVRvU2lnbik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KGAke3RoaXMuY29uZmlnLmFwaX0vYXV0aC92ZXJpZnlgLCB7XG4gICAgICBjaGFsbGVuZ2U6IG1lc3NhZ2VUb1NpZ24sXG4gICAgICBwdWJsaWNfYWRkcmVzczogYWRkcmVzcyxcbiAgICAgIHNpZ25lZF9tZXNzYWdlOiBzaWduZWRNZXNzYWdlXG4gICAgfSwge30sIHtcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlU3RhdGUoe1xuICAgICAgand0VG9rZW46IHJlc3BvbnNlLnRva2VuXG4gICAgfSwgYWRkcmVzcyk7XG4gIH1cbiAgYXN5bmMgZ2V0RGFwcExpc3QoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53c0FwaUNsaWVudC5hdXRoR2V0KFwiZGFwcHNcIiwgdGhpcy5hdXRoQ3JlZGVudGlhbHMoKSwge1xuICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLnN1Y2Nlc3MgPyByZXNwb25zZS5kYXRhIDogW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5lcnJvcihcInVuYWJsZSB0byBnZXQgZGFwcHMgbGlzdFwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0cmF0ZWd5XG4gICAqIEZvciBhY2NvdW50IHR5cGU6IHRocmVzaG9sZCwgbm9ybWFsICh3ZWIzYXV0aCBsb2dpbilcbiAgICogaWRUb2tlbiBmcm9tIHdlYjNhdXRoIGxvZ2luIG11c3QgYmUgcHJlc2VudC4gV2UgdXNlIGl0IGRpcmVjdGx5XG4gICAqXG4gICAqIEZvciBhY2NvdW50IHR5cGU6IGFwcF9zY29wZWQsIElNUE9SVEVEXG4gICAqIGlkVG9rZW4gZnJvbSB3ZWIzYXV0aCBsb2dpbiBtdXN0IGJlIHByZXNlbnQuIFdlIHJlcXVlc3QgYSBtZXNzYWdlIGZvciBzaWduaW5nIHVzaW5nIHRoZSBpZFRva2VuXG4gICAqIGFuZCBzaWduIGl0IHVzaW5nIHRoZSBwcml2YXRlIGtleSBvZiB0aGUgYWNjb3VudC4gV2UgdGhlbiBzZW5kIHRoZSBzaWduZWQgbWVzc2FnZSB0byB0aGUgYmFja2VuZFxuICAgKiB0byB2ZXJpZnkgdGhlIHNpZ25hdHVyZSBhbmQgcmV0dXJuIGEgbmV3IGp3dFRva2VuIHRoYXQgaW5jbHVkZXMgdGhlIGFwcF9zY29wZWQgYWRkcmVzc1xuICAgKlxuICAgKiBGb3IgYWNjb3VudCB0eXBlOiBBY2NvdW50IGFic3RyYWN0aW9uXG4gICAqIGlkVG9rZW4gZnJvbSB3ZWIzYXV0aCBsb2dpbiBtdXN0IGJlIHByZXNlbnQuIFdlIHVzZSBpdCB0byBleGNoYW5nZSBmb3IgYSBuZXcgand0VG9rZW4uXG4gICAqIEJlY2F1c2UgYmFja2VuZCBjYW4gZGVyaXZlIEFBIGFkZHJlc3MgZnJvbSBwdWJsaWMgYWRkcmVzcyBhbmQgaXNzdWUgdGhpcyB0b2tlbiBlYXNpbHkuXG4gICAqXG4gICAqIEZvciBhY2NvdW50IHR5cGU6IGV4dGVybmFsXG4gICAqIGlkVG9rZW4gZnJvbSB3ZWIzYXV0aCBgYXV0aGVudGljYXRlVXNlcmAgKHNpd3cpIGxvZ2luIG11c3QgYmUgcHJlc2VudC4gV2UgdXNlIGl0IGRpcmVjdGx5XG4gICAqL1xuICBhc3luYyBpbml0KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICB1c2VySW5mbyxcbiAgICAgIGlkVG9rZW4sXG4gICAgICBtZXRhZGF0YSA9IHt9LFxuICAgICAgdHlwZVxuICAgIH0gPSBwYXJhbXM7XG4gICAgaWYgKHRoaXMuZ2V0QWRkcmVzc1N0YXRlKGFkZHJlc3MpKSByZXR1cm47XG4gICAgbGV0IGp3dFRva2VuO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBQ0NPVU5UX0NBVEVHT1JZLklNUE9SVEVEOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFpZFRva2VuKSB0aHJvdyBuZXcgRXJyb3IoXCJXZWIzQXV0aCBpZFRva2VuIG11c3QgYmUgcHJlc2VudFwiKTtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlVG9TaWduID0gYXdhaXQgdGhpcy5nZXRNZXNzYWdlRm9yU2lnbmluZyhhZGRyZXNzLCBpZFRva2VuKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlU2lnbk1lc3NhZ2UobWVzc2FnZVRvU2lnbik7XG4gICAgICAgICAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IGF3YWl0IHRoaXMuc2lnbkF1dGhNZXNzYWdlKGFkZHJlc3MsIG1lc3NhZ2VUb1NpZ24pO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcG9zdChgJHt0aGlzLmNvbmZpZy5hcGl9L2F1dGgvdmVyaWZ5YCwgX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICBjaGFsbGVuZ2U6IG1lc3NhZ2VUb1NpZ24sXG4gICAgICAgICAgICBhY2NvdW50X3R5cGU6IHR5cGUsXG4gICAgICAgICAgICBwdWJsaWNfYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgIHNpZ25lZF9tZXNzYWdlOiBzaWduZWRNZXNzYWdlLFxuICAgICAgICAgICAgdmVyaWZpZXI6IHVzZXJJbmZvLmFnZ3JlZ2F0ZVZlcmlmaWVyIHx8IHVzZXJJbmZvLnZlcmlmaWVyLFxuICAgICAgICAgICAgdmVyaWZpZXJfaWQ6IHVzZXJJbmZvLnZlcmlmaWVySWRcbiAgICAgICAgICB9LCBtZXRhZGF0YSksIHt9LCB7XG4gICAgICAgICAgICB1c2VBUElLZXk6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBqd3RUb2tlbiA9IHJlc3BvbnNlLnRva2VuO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIEFDQ09VTlRfQ0FURUdPUlkuRVhURVJOQUw6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIWlkVG9rZW4pIHRocm93IG5ldyBFcnJvcihcIlNJV1cgaWRUb2tlbiBtdXN0IGJlIHByZXNlbnRcIik7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KGAke3RoaXMuY29uZmlnLmFwaX0vYXV0aC92ZXJpZnlgLCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgIGFjY291bnRfdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHB1YmxpY19hZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgaWRfdG9rZW46IGlkVG9rZW4sXG4gICAgICAgICAgICB2ZXJpZmllcjogdXNlckluZm8uYWdncmVnYXRlVmVyaWZpZXIgfHwgdXNlckluZm8udmVyaWZpZXIsXG4gICAgICAgICAgICB2ZXJpZmllcl9pZDogdXNlckluZm8udmVyaWZpZXJJZFxuICAgICAgICAgIH0sIG1ldGFkYXRhKSwge30sIHtcbiAgICAgICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGp3dFRva2VuID0gcmVzcG9uc2UudG9rZW47XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQUNDT1VOVF9DQVRFR09SWS5BQ0NPVU5UX0FCU1RSQUNUSU9OOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFpZFRva2VuKSB0aHJvdyBuZXcgRXJyb3IoXCJXZWIzQXV0aCBpZFRva2VuIG11c3QgYmUgcHJlc2VudFwiKTtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QoYCR7dGhpcy5jb25maWcuYXBpfS9hdXRoL3ZlcmlmeWAsIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgcHVibGljX2FkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICBpZF90b2tlbjogaWRUb2tlbixcbiAgICAgICAgICAgIHZlcmlmaWVyOiB1c2VySW5mby5hZ2dyZWdhdGVWZXJpZmllciB8fCB1c2VySW5mby52ZXJpZmllcixcbiAgICAgICAgICAgIHZlcmlmaWVyX2lkOiB1c2VySW5mby52ZXJpZmllcklkLFxuICAgICAgICAgICAgYWNjb3VudF90eXBlOiB0eXBlXG4gICAgICAgICAgfSwgbWV0YWRhdGEpLCB7fSwge1xuICAgICAgICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgand0VG9rZW4gPSByZXNwb25zZS50b2tlbjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBBQ0NPVU5UX0NBVEVHT1JZLk1QQzpcbiAgICAgIGNhc2UgQUNDT1VOVF9DQVRFR09SWS5TRkE6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIW1ldGFkYXRhLnNpZ25hdHVyZXMpIHRocm93IG5ldyBFcnJvcihcIk1QQyBzaWduYXR1cmVzIG11c3QgYmUgcHJlc2VudFwiKTtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QoYCR7dGhpcy5jb25maWcuYXBpfS9hdXRoL3ZlcmlmeWAsIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgcHVibGljX2FkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICB2ZXJpZmllcjogdXNlckluZm8uYWdncmVnYXRlVmVyaWZpZXIgfHwgdXNlckluZm8udmVyaWZpZXIsXG4gICAgICAgICAgICB2ZXJpZmllcl9pZDogdXNlckluZm8udmVyaWZpZXJJZCxcbiAgICAgICAgICAgIGFjY291bnRfdHlwZTogdHlwZVxuICAgICAgICAgIH0sIG1ldGFkYXRhKSwge30sIHtcbiAgICAgICAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGp3dFRva2VuID0gcmVzcG9uc2UudG9rZW47XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQUNDT1VOVF9DQVRFR09SWS5OT1JNQUw6XG4gICAgICBjYXNlIEFDQ09VTlRfQ0FURUdPUlkuVEhSRVNIT0xEOlxuICAgICAgY2FzZSBBQ0NPVU5UX0NBVEVHT1JZLkFQUF9TQ09QRUQ6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoIWlkVG9rZW4pIHRocm93IG5ldyBFcnJvcihcIldlYjNBdXRoIGlkVG9rZW4gbXVzdCBiZSBwcmVzZW50XCIpO1xuICAgICAgICBqd3RUb2tlbiA9IGlkVG9rZW47XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVN0YXRlKHtcbiAgICAgIGp3dFRva2VuLFxuICAgICAgdXNlckluZm8sXG4gICAgICBhY2NvdW50VHlwZTogdHlwZSAhPT0gbnVsbCAmJiB0eXBlICE9PSB2b2lkIDAgPyB0eXBlIDogdGhpcy5kZWZhdWx0UHJlZmVyZW5jZXMuYWNjb3VudFR5cGVcbiAgICB9LCBhZGRyZXNzKTtcbiAgfVxuICB1cGRhdGVTdGF0ZShwcmVmZXJlbmNlcywgYWRkcmVzcykge1xuICAgIGNvbnN0IHNlbGVjdGVkQWRkcmVzcyA9IGFkZHJlc3MgfHwgdGhpcy5zdGF0ZS5zZWxlY3RlZEFkZHJlc3M7XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5nZXRBZGRyZXNzU3RhdGUoc2VsZWN0ZWRBZGRyZXNzKSB8fCBjbG9uZURlZXAodGhpcy5kZWZhdWx0UHJlZmVyZW5jZXMpO1xuICAgIGNvbnN0IG1lcmdlZFN0YXRlID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjdXJyZW50U3RhdGUpLCBwcmVmZXJlbmNlcyk7XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgaWRlbnRpdGllczogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLnN0YXRlLmlkZW50aXRpZXMpLCB7fSwge1xuICAgICAgICBbc2VsZWN0ZWRBZGRyZXNzXTogbWVyZ2VkU3RhdGVcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIG1lcmdlZFN0YXRlO1xuICB9XG4gIGF1dGhDcmVkZW50aWFscyhhZGRyZXNzKSB7XG4gICAgdmFyIF90aGlzJGdldEFkZHJlc3NTdGF0ZTc7XG4gICAgY29uc3Qgc2VsZWN0ZWRBZGRyZXNzID0gYWRkcmVzcyB8fCB0aGlzLnN0YXRlLnNlbGVjdGVkQWRkcmVzcztcbiAgICBjb25zdCBqd3RUb2tlbiA9ICgoX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNyA9IHRoaXMuZ2V0QWRkcmVzc1N0YXRlKHNlbGVjdGVkQWRkcmVzcykpID09PSBudWxsIHx8IF90aGlzJGdldEFkZHJlc3NTdGF0ZTcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldEFkZHJlc3NTdGF0ZTcuand0VG9rZW4pIHx8IFwiXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGp3dFRva2VuLFxuICAgICAgcHVibGljQWRkcmVzczogc2VsZWN0ZWRBZGRyZXNzXG4gICAgfTtcbiAgfVxuICBoZWFkZXJzKGFkZHJlc3MpIHtcbiAgICB2YXIgX3RoaXMkZ2V0QWRkcmVzc1N0YXRlODtcbiAgICBjb25zdCBzZWxlY3RlZEFkZHJlc3MgPSBhZGRyZXNzIHx8IHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzO1xuICAgIHJldHVybiBnZXRIZWFkZXJzKCgoX3RoaXMkZ2V0QWRkcmVzc1N0YXRlOCA9IHRoaXMuZ2V0QWRkcmVzc1N0YXRlKHNlbGVjdGVkQWRkcmVzcykpID09PSBudWxsIHx8IF90aGlzJGdldEFkZHJlc3NTdGF0ZTggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldEFkZHJlc3NTdGF0ZTguand0VG9rZW4pIHx8IFwiXCIsIHNlbGVjdGVkQWRkcmVzcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgc3RhdHVzIG9mIHRoZSB0cmFuc2FjdGlvbi4gRWFjaCBzdGF0dXMgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIHRyYW5zYWN0aW9uIGludGVybmFsbHlcbiAqIGluIHRoZSB3YWxsZXQuIFNvbWUgb2YgdGhlc2UgY29ycmVzcG9uZCB3aXRoIHRoZSBzdGF0ZSBvZiB0aGUgdHJhbnNhY3Rpb24gb24gdGhlIG5ldHdvcmssIGJ1dFxuICogc29tZSBhcmUgd2FsbGV0LXNwZWNpZmljLlxuICovXG5cbmxldCBUcmFuc2FjdGlvblN0YXR1cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoVHJhbnNhY3Rpb25TdGF0dXMpIHtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJhcHByb3ZlZFwiXSA9IFwiYXBwcm92ZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJjYW5jZWxsZWRcIl0gPSBcImNhbmNlbGxlZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcImNhbmNlbGxpbmdcIl0gPSBcImNhbmNlbGxpbmdcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJjb25maXJtZWRcIl0gPSBcImNvbmZpcm1lZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcImZhaWxlZFwiXSA9IFwiZmFpbGVkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wiZmluYWxpemVkXCJdID0gXCJmaW5hbGl6ZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJwcm9jZXNzZWRcIl0gPSBcInByb2Nlc3NlZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcInJlamVjdGVkXCJdID0gXCJyZWplY3RlZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcInNpZ25lZFwiXSA9IFwic2lnbmVkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wic3VibWl0dGVkXCJdID0gXCJzdWJtaXR0ZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJ1bmFwcHJvdmVkXCJdID0gXCJ1bmFwcHJvdmVkXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1wiZHJvcHBlZFwiXSA9IFwiZHJvcHBlZFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tcImV4cGlyZWRcIl0gPSBcImV4cGlyZWRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbXCJwZW5kaW5nXCJdID0gXCJwZW5kaW5nXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvblN0YXR1cztcbn0oe30pO1xuY29uc3QgVFJBTlNBQ1RJT05fVFlQRVMgPSB7XG4gIENBTkNFTDogXCJjYW5jZWxcIixcbiAgUkVUUlk6IFwicmV0cnlcIixcbiAgQ09OVFJBQ1RfSU5URVJBQ1RJT046IFwiY29udHJhY3RJbnRlcmFjdGlvblwiLFxuICBERVBMT1lfQ09OVFJBQ1Q6IFwiY29udHJhY3REZXBsb3ltZW50XCIsXG4gIFdBU01fQkFTRURfREVQTE9ZOiBcIndhc21CYXNlZERlcGxveVwiLFxuICBTVEFOREFSRF9UUkFOU0FDVElPTjogXCJ0cmFuc2FjdGlvblwiLFxuICBTVEFOREFSRF9QQVlNRU5UX1RSQU5TQUNUSU9OOiBcInBheW1lbnRfdHJhbnNhY3Rpb25cIixcbiAgLy8gc3BlY2lmaWMgdG8gY2hhaW5zIGxpa2Ugc29sYW5hIGFuZCBjYXNwZXJcbiAgU0VOVF9FVEhFUjogXCJzZW50RXRoZXJcIixcbiAgVE9LRU5fTUVUSE9EX1RSQU5TRkVSOiBcInRyYW5zZmVyXCIsXG4gIFRPS0VOX01FVEhPRF9UUkFOU0ZFUl9GUk9NOiBcInRyYW5zZmVyRnJvbVwiLFxuICBUT0tFTl9NRVRIT0RfQVBQUk9WRTogXCJhcHByb3ZlXCIsXG4gIENPTExFQ1RJQkxFX01FVEhPRF9TQUZFX1RSQU5TRkVSX0ZST006IFwic2FmZVRyYW5zZmVyRnJvbVwiLFxuICBTRVRfQVBQUk9WQUxfRk9SX0FMTDogXCJzZXRBcHByb3ZhbEZvckFsbFwiXG59O1xuY29uc3QgVFhfRVZFTlRTID0ge1xuICBUWF9XQVJOSU5HOiBcInR4Ondhcm5pbmdcIixcbiAgVFhfRVJST1I6IFwidHg6ZXJyb3JcIixcbiAgVFhfRkFJTEVEOiBcInR4OmZhaWxlZFwiLFxuICBUWF9DT05GSVJNRUQ6IFwidHg6Y29uZmlybWVkXCIsXG4gIFRYX0RST1BQRUQ6IFwidHg6ZHJvcHBlZFwiLFxuICBUWF9FWFBJUkVEOiBcInR4OmV4cGlyZWRcIixcbiAgVFhfU1RBVFVTX1VQREFURTogXCJ0eDpzdGF0dXNfdXBkYXRlXCIsXG4gIFRYX1VOQVBQUk9WRUQ6IFwidHg6dW5hcHByb3ZlZFwiLFxuICBUWF9SRVRSWTogXCJ0eDpyZXRyeVwiLFxuICBUWF9CTE9DS19VUERBVEU6IFwidHg6YmxvY2tfdXBkYXRlXCJcbn07XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gY29udHJvbGxlciBjb25maWd1cmF0aW9uXG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBjb250cm9sbGVyIHN0YXRlXG4gKi9cblxuLyoqXG4gKiBSZXN1bHRcbiAqXG4gKiByZXN1bHQgLSBQcm9taXNlIHJlc29sdmluZyB0byBhIG5ldyB0cmFuc2FjdGlvbiBoYXNoXG4gKiB0cmFuc2FjdGlvbk1ldGEgLSBNZXRhIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgbmV3IHRyYW5zYWN0aW9uXG4gKi9cblxuY2xhc3MgQmFzZVRyYW5zYWN0aW9uU3RhdGVNYW5hZ2VyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29uZmlnLFxuICAgIHN0YXRlLFxuICAgIGdldEN1cnJlbnRDaGFpbklkXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb25maWcsXG4gICAgICBzdGF0ZVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldEN1cnJlbnRDaGFpbklkXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgdHhIaXN0b3J5TGltaXQ6IDQwXG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgIHRyYW5zYWN0aW9uczoge30sXG4gICAgICB1bmFwcHJvdmVkVHhzOiB7fSxcbiAgICAgIGN1cnJlbnROZXR3b3JrVHhzTGlzdDogW11cbiAgICB9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIHRoaXMuZ2V0Q3VycmVudENoYWluSWQgPSBnZXRDdXJyZW50Q2hhaW5JZDtcbiAgfVxuICBnZXRVbmFwcHJvdmVkVHhMaXN0KCkge1xuICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLmdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgcmV0dXJuIHBpY2tCeSh0aGlzLnN0YXRlLnRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy51bmFwcHJvdmVkICYmIHRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmsodHJhbnNhY3Rpb24sIGNoYWluSWQpKTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbih0eElkKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNhY3Rpb25zXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uc1t0eElkXTtcbiAgfVxuICB1cGRhdGVUcmFuc2FjdGlvbih0eE1ldGEpIHtcbiAgICAvLyBjb21taXQgdHhNZXRhIHRvIHN0YXRlXG4gICAgY29uc3QgdHhJZCA9IHR4TWV0YS5pZDtcbiAgICB0eE1ldGEudXBkYXRlZF9hdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICB0cmFuc2FjdGlvbnM6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5zdGF0ZS50cmFuc2FjdGlvbnMpLCB7fSwge1xuICAgICAgICBbdHhJZF06IHR4TWV0YVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZXRUeFN0YXR1c1JlamVjdGVkKHR4SWQpIHtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUcmFuc2FjdGlvblN0YXR1cy5yZWplY3RlZCk7XG4gICAgdGhpcy5fZGVsZXRlVHJhbnNhY3Rpb24odHhJZCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGltcGxlbWVudGluZyBjb250cm9sbGVyIGNhbiBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uYWxpdHkgYW5kIGFkZCBjdXN0b20gbG9naWMgKyBjYWxsIHN1cGVyLigpXG4gICAqL1xuICBzZXRUeFN0YXR1c1VuYXBwcm92ZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQpO1xuICB9XG4gIHNldFR4U3RhdHVzQXBwcm92ZWQodHhJZCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLmFwcHJvdmVkKTtcbiAgfVxuICBzZXRUeFN0YXR1c1NpZ25lZCh0eElkLCBpc0ZpbmFsU3RlcCkge1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLnNpZ25lZCwgaXNGaW5hbFN0ZXApO1xuICB9XG4gIHNldFR4U3RhdHVzU3VibWl0dGVkKHR4SWQpIHtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUcmFuc2FjdGlvblN0YXR1cy5zdWJtaXR0ZWQpO1xuICB9XG4gIHNldFR4U3RhdHVzRHJvcHBlZCh0eElkKSB7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMuZHJvcHBlZCk7XG4gIH1cbiAgc2V0VHhTdGF0dXNFeHBpcmVkKHR4SWQpIHtcbiAgICB0aGlzLl9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBUcmFuc2FjdGlvblN0YXR1cy5leHBpcmVkKTtcbiAgfVxuICBzZXRUeFN0YXR1c0NvbmZpcm1lZCh0eElkKSB7XG4gICAgdGhpcy5fc2V0VHJhbnNhY3Rpb25TdGF0dXModHhJZCwgVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkKTtcbiAgfVxuICBzZXRUeFN0YXR1c0ZhaWxlZCh0eElkLCBlcnJvcl8pIHtcbiAgICBjb25zdCBlcnJvciA9ICFlcnJvcl8gPyBuZXcgRXJyb3IoXCJJbnRlcm5hbCB0b3J1cyBmYWlsdXJlXCIpIDogZXJyb3JfO1xuICAgIGNvbnN0IHR4TWV0YSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG4gICAgdHhNZXRhLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy51cGRhdGVUcmFuc2FjdGlvbih0eE1ldGEpO1xuICAgIHRoaXMuX3NldFRyYW5zYWN0aW9uU3RhdHVzKHR4SWQsIFRyYW5zYWN0aW9uU3RhdHVzLmZhaWxlZCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHRvIGRldGVybWluZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgaW4gYSBmaW5hbCBzdGF0ZVxuICAgKiBAcGFyYW0gc3RhdHVzIC0gVHJhbnNhY3Rpb24gc3RhdHVzXG4gICAqIEByZXR1cm5zIGJvb2xlYW4gaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGluIGEgZmluYWwgc3RhdGVcbiAgICovXG4gIGlzRmluYWxTdGF0ZShzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5yZWplY3RlZCB8fCBzdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZCB8fCBzdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLmNvbmZpcm1lZCB8fCBzdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLmZhaWxlZCB8fCBzdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLmNhbmNlbGxlZCB8fCBzdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLmV4cGlyZWQ7XG4gIH1cblxuICAvKipcbiAgICogRmlsdGVycyBvdXQgdGhlIHVuYXBwcm92ZWQgdHJhbnNhY3Rpb25zIGZyb20gc3RhdGVcbiAgICovXG4gIGNsZWFyVW5hcHByb3ZlZFR4cygpIHtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICB0cmFuc2FjdGlvbnM6IG9taXRCeSh0aGlzLnN0YXRlLnRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy51bmFwcHJvdmVkKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIHdpbGwgYXBwZW5kIG5ldyB0cmFuc2FjdGlvbnMgdG8gb2xkIHR4bnMuXG4gICAqL1xuICBfYWRkVHJhbnNhY3Rpb25zVG9TdGF0ZSh0cmFuc2FjdGlvbnMpIHtcbiAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICB0cmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9ucy5yZWR1Y2UoKHJlc3VsdCwgbmV3VHgpID0+IHtcbiAgICAgICAgcmVzdWx0W25ld1R4LmlkXSA9IG5ld1R4O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSwgdGhpcy5zdGF0ZS50cmFuc2FjdGlvbnMpXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogd2lsbCBzZXQgbmV3IHR4bnMsIG92ZXJyaWRlIGV4aXN0aW5nIGlmIGFueSBpbiBzdGF0ZS5cbiAgICovXG4gIF9zZXRUcmFuc2FjdGlvbnNUb1N0YXRlKHRyYW5zYWN0aW9ucykge1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIHRyYW5zYWN0aW9uczogdHJhbnNhY3Rpb25zLnJlZHVjZSgocmVzdWx0LCBuZXdUeCkgPT4ge1xuICAgICAgICByZXN1bHRbbmV3VHguaWRdID0gbmV3VHg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCB7fSlcbiAgICB9KTtcbiAgfVxuICBfZGVsZXRlVHJhbnNhY3Rpb24odGFyZ2V0VHJhbnNhY3Rpb25JZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zYWN0aW9uc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGRlbGV0ZSB0cmFuc2FjdGlvbnNbdGFyZ2V0VHJhbnNhY3Rpb25JZF07XG4gICAgdGhpcy51cGRhdGUoe1xuICAgICAgdHJhbnNhY3Rpb25zXG4gICAgfSk7XG4gIH1cbiAgX2RlbGV0ZVRyYW5zYWN0aW9ucyh0YXJnZXRUcmFuc2FjdGlvbklkcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zYWN0aW9uc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHRhcmdldFRyYW5zYWN0aW9uSWRzLmZvckVhY2godHJhbnNhY3Rpb25JZCA9PiB7XG4gICAgICBkZWxldGUgdHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uSWRdO1xuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlKHtcbiAgICAgIHRyYW5zYWN0aW9uc1xuICAgIH0pO1xuICB9XG4gIF9zZXRUcmFuc2FjdGlvblN0YXR1cyh0eElkLCBzdGF0dXMsIGlzRmluYWxTdGVwKSB7XG4gICAgY29uc3QgdHhNZXRhID0gdGhpcy5nZXRUcmFuc2FjdGlvbih0eElkKTtcbiAgICBpZiAoIXR4TWV0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0eE1ldGEuc3RhdHVzID0gc3RhdHVzO1xuICAgIC8vIG9ubHkgdXBkYXRpbmcgc3RhdHVzIHNvIG5vIHZhbGlkYXRpb24gcmVxdWlyZWQgb24gdHhuLlxuICAgIHRoaXMudXBkYXRlVHJhbnNhY3Rpb24odHhNZXRhKTtcbiAgICB0aGlzLmVtaXQoVFhfRVZFTlRTLlRYX1NUQVRVU19VUERBVEUsIHtcbiAgICAgIHR4SWQsXG4gICAgICBzdGF0dXNcbiAgICB9KTtcbiAgICBpZiAodGhpcy5pc0ZpbmFsU3RhdGUoc3RhdHVzKSB8fCBpc0ZpbmFsU3RlcCkge1xuICAgICAgdGhpcy5lbWl0KGAke3R4TWV0YS5pZH06ZmluaXNoZWRgLCB0eE1ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoYCR7dHhNZXRhLmlkfToke3N0YXR1c31gLCB0eElkKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgQUNDT1VOVF9DQVRFR09SWSwgQUNUSVZJVFlfQUNUSU9OLCBBQ1RJVklUWV9BQ1RJT05fQUNDRVBUX05GVF9PRkZFUiwgQUNUSVZJVFlfQUNUSU9OX0FMTCwgQUNUSVZJVFlfQUNUSU9OX0JVUk4sIEFDVElWSVRZX0FDVElPTl9DQU5DRUxfTkZUX09GRkVSLCBBQ1RJVklUWV9BQ1RJT05fQ1JFQVRFX05GVF9PRkZFUiwgQUNUSVZJVFlfQUNUSU9OX0NSRUFURV9UUlVTVExJTkUsIEFDVElWSVRZX0FDVElPTl9SRUNFSVZFLCBBQ1RJVklUWV9BQ1RJT05fUkVNT1ZFX1RSVVNUTElORSwgQUNUSVZJVFlfQUNUSU9OX1NFTkQsIEFDVElWSVRZX0FDVElPTl9UT1BVUCwgQUNUSVZJVFlfUEVSSU9EX0FMTCwgQUNUSVZJVFlfUEVSSU9EX01PTlRIX09ORSwgQUNUSVZJVFlfUEVSSU9EX01PTlRIX1NJWCwgQUNUSVZJVFlfUEVSSU9EX1dFRUtfT05FLCBBQ1RJVklUWV9TVEFUVVNfQ0FOQ0VMTEVELCBBQ1RJVklUWV9TVEFUVVNfQ0FOQ0VMTElORywgQUNUSVZJVFlfU1RBVFVTX1BFTkRJTkcsIEFDVElWSVRZX1NUQVRVU19TVUNDRVNTRlVMLCBBQ1RJVklUWV9TVEFUVVNfVU5TVUNDRVNTRlVMLCBCUk9BRENBU1RfQ0hBTk5FTFMsIEJST0FEQ0FTVF9DSEFOTkVMU19NU0dTLCBCVVRUT05fUE9TSVRJT04sIEJhc2VCbG9ja1RyYWNrZXIsIEJhc2VDb250cm9sbGVyLCBCYXNlQ3VycmVuY3lDb250cm9sbGVyLCBCYXNlRW1iZWRDb250cm9sbGVyLCBCYXNlS2V5cmluZ0NvbnRyb2xsZXIsIEJhc2VQcmVmZXJlbmNlc0NvbnRyb2xsZXIsIEJhc2VUcmFuc2FjdGlvblN0YXRlTWFuYWdlciwgQnJvYWRjYXN0Q2hhbm5lbEhhbmRsZXIsIENIQUlOX05BTUVTUEFDRVMsIENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLCBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMsIENPTkZJUk1BVElPTl9TVFJBVEVHWSwgQ29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXIsIENvbnRyb2xsZXJFdmVudHMsIERFRkFVTFRfUFJFRkVSRU5DRVMsIEZFQVRVUkVTX0NPTkZJUk1fV0lORE9XLCBGRUFUVVJFU19ERUZBVUxUX1BPUFVQX1dJTkRPVywgRkVBVFVSRVNfREVGQVVMVF9XQUxMRVRfV0lORE9XLCBGRUFUVVJFU19QUk9WSURFUl9DSEFOR0VfV0lORE9XLCBMT0dJTl9QUk9WSURFUiwgUEFZTUVOVF9QUk9WSURFUiwgUE9QVVBfTE9BREVELCBQT1BVUF9SRVNVTFQsIFBST1ZJREVSX0pSUENfTUVUSE9EUywgUFJPVklERVJfTk9USUZJQ0FUSU9OUywgUG9wdXBIYW5kbGVyLCBQb3B1cFN0b3JlQ2hhbm5lbCwgUG9wdXBXaXRoQmNIYW5kbGVyLCBSZWRpcmVjdEhhbmRsZXIsIFNFVFVQX0NPTVBMRVRFLCBTdHJlYW1XaW5kb3csIFRSQU5TQUNUSU9OX1RZUEVTLCBUWF9FVkVOVFMsIFRyYW5zYWN0aW9uU3RhdHVzLCBVc2VyRXJyb3IsIFdTQXBpQ2xpZW50LCBhZGRyZXNzU2xpY2VyLCBhdXRoU2VydmVyLCBicm9hZGNhc3RDaGFubmVsT3B0aW9ucywgY2xvbmVEZWVwLCBjb25jYXRTaWcsIGNyZWF0ZUNoYW5nZVByb3ZpZGVyTWlkZGxld2FyZU1pZGRsZXdhcmUsIGNyZWF0ZUNvbW11bmljYXRpb25NaWRkbGV3YXJlLCBjcmVhdGVFdmVudEVtaXR0ZXJQcm94eSwgY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxLCBjcmVhdGVGZXRjaE1pZGRsZXdhcmUsIGNyZWF0ZUdlbmVyaWNKUlBDTWlkZGxld2FyZSwgY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUsIGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUsIGNyZWF0ZU9yaWdpbk1pZGRsZXdhcmUsIGNyZWF0ZVJhbmRvbUlkLCBjcmVhdGVTd2FwcGFibGVQcm94eSwgY3JlYXRlVG9wdXBNaWRkbGV3YXJlLCBmb3JtYXREYXRlLCBmb3JtYXRTbWFsbE51bWJlcnMsIGZvcm1hdFRpbWUsIGdldEN1c3RvbURldmljZUluZm8sIGdldEhlYWRlcnMsIGdldFBvcHVwRmVhdHVyZXMsIGdldFR4U3RhdHVzVGV4dCwgaGFuZGxlUmVkaXJlY3RQYXJhbWV0ZXJzLCBoYXNoTWVzc2FnZSwgaW50VG9IZXgsIGlzVW5hdXRob3JpemVkRXJyb3IsIG9taXRCeSwgcGFkV2l0aFplcm9lcywgcGlja0J5LCByYW5kb21JZCwgc2lnbkNoYWxsZW5nZSwgc2lnbk1lc3NhZ2UsIHNpZ25pZmljYW50RGlnaXRzLCBzbGVlcCwgdGltZW91dCQxIGFzIHRpbWVvdXQsIHRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmssIHZlcmlmeVNpZ25lZENoYWxsZW5nZSB9O1xuIl0sIm5hbWVzIjpbIl9vYmplY3RTcHJlYWQiLCJfZGVmaW5lUHJvcGVydHkiLCJTYWZlRXZlbnRFbWl0dGVyIiwiY3JlYXRlQXN5bmNNaWRkbGV3YXJlIiwibWVyZ2VNaWRkbGV3YXJlIiwiY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlIiwiSlJQQ0VuZ2luZSIsInByb3ZpZGVyRnJvbUVuZ2luZSIsInJwY0Vycm9ycyIsInBvc3QiLCJnZXQiLCJwdXQiLCJwYXRjaCIsInJlbW92ZSIsImxvZyIsImZyb21TaWduZWQiLCJieXRlc1RvQmlnSW50IiwidG9VbnNpZ25lZCIsInN0cmlwSGV4UHJlZml4IiwiYmlnSW50VG9IZXgiLCJhZGRIZXhQcmVmaXgiLCJoYXNoUGVyc29uYWxNZXNzYWdlIiwiZWNzaWduIiwiYmlnSW50VG9CeXRlcyIsInNhZmVhdG9iIiwiQmlnTnVtYmVyIiwiQnJvYWRjYXN0Q2hhbm5lbCIsImJvd3NlciIsImp3dERlY29kZSIsIkJhc2VDb250cm9sbGVyIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJzdGF0ZSIsImRlZmF1bHRDb25maWciLCJkZWZhdWx0U3RhdGUiLCJpbml0aWFsU3RhdGUiLCJpbml0aWFsQ29uZmlnIiwiaW50ZXJuYWxDb25maWciLCJpbnRlcm5hbFN0YXRlIiwiY29uZmlndXJlIiwib3ZlcndyaXRlIiwiZnVsbFVwZGF0ZSIsIk9iamVjdCIsImFzc2lnbiIsImtleSIsInVwZGF0ZSIsImVtaXQiLCJpbml0aWFsaXplIiwic2VjIiwiY2FsY3VsYXRlU3VtIiwiYWNjdW11bGF0b3IiLCJjdXJyZW50VmFsdWUiLCJibG9ja1RyYWNrZXJFdmVudHMiLCJCYXNlQmxvY2tUcmFja2VyIiwiX2N1cnJlbnRCbG9jayIsImlkZW1wb3RlbmN5S2V5IiwiX2lzUnVubmluZyIsImJsb2NrUmVzZXREdXJhdGlvbiIsIl9vbk5ld0xpc3RlbmVyIiwiYmluZCIsIl9vblJlbW92ZUxpc3RlbmVyIiwiX3Jlc2V0Q3VycmVudEJsb2NrIiwiX3NldHVwSW50ZXJuYWxFdmVudHMiLCJpc1J1bm5pbmciLCJnZXRDdXJyZW50QmxvY2siLCJnZXRMYXRlc3RCbG9jayIsImxhdGVzdEJsb2NrIiwiUHJvbWlzZSIsInJlc29sdmUiLCJvbmNlIiwiYmxvY2siLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJldmVudE5hbWUiLCJfc3RhcnQiLCJfZW5kIiwiX25ld1BvdGVudGlhbExhdGVzdCIsIm5ld0Jsb2NrIiwiY3VycmVudEJsb2NrIiwiX3NldEN1cnJlbnRCbG9jayIsInJlbW92ZUxpc3RlbmVyIiwib24iLCJfbWF5YmVTdGFydCIsIl9nZXRCbG9ja1RyYWNrZXJFdmVudENvdW50IiwiX21heWJlRW5kIiwiX2NhbmNlbEJsb2NrUmVzZXRUaW1lb3V0IiwiX3NldHVwQmxvY2tSZXNldFRpbWVvdXQiLCJtYXAiLCJsaXN0ZW5lckNvdW50IiwicmVkdWNlIiwib2xkQmxvY2siLCJfYmxvY2tSZXNldFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwidW5yZWYiLCJjbGVhclRpbWVvdXQiLCJmaWx0ZXJOb29wIiwiaW50ZXJuYWxFdmVudHMiLCJleHRlcm5hbEV2ZW50RmlsdGVyIiwibmFtZSIsImluY2x1ZGVzIiwiZ2V0UmF3TGlzdGVuZXJzIiwiZXZlbnRFbWl0dGVyIiwicmF3TGlzdGVuZXJzIiwibGlzdGVuZXJzIiwiY3JlYXRlRXZlbnRFbWl0dGVyUHJveHkiLCJpbml0aWFsVGFyZ2V0Iiwib3B0cyIsImZpbmFsT3B0cyIsImV2ZW50RmlsdGVyIiwiRXJyb3IiLCJ0YXJnZXQiLCJzZXRUYXJnZXQiLCJuZXdUYXJnZXQiLCJvbGRUYXJnZXQiLCJldmVudE5hbWVzIiwiZmlsdGVyIiwiZm9yRWFjaCIsImhhbmRsZXIiLCJwcm94eSIsIlByb3h5IiwiXyIsInNldCIsInZhbHVlIiwiY3JlYXRlU3dhcHBhYmxlUHJveHkiLCJQT0xMSU5HX0lOVEVSVkFMIiwiQmFzZUN1cnJlbmN5Q29udHJvbGxlciIsImN1cnJlbnRDdXJyZW5jeSIsImNvbnZlcnNpb25SYXRlIiwiY29udmVyc2lvbkRhdGUiLCJuYXRpdmVDdXJyZW5jeSIsInBvbGxJbnRlcnZhbCIsImdldE5hdGl2ZUN1cnJlbmN5Iiwic2V0TmF0aXZlQ3VycmVuY3kiLCJ0aWNrZXIiLCJnZXRDdXJyZW50Q3VycmVuY3kiLCJzZXRDdXJyZW50Q3VycmVuY3kiLCJnZXRDb252ZXJzaW9uUmF0ZSIsInNldENvbnZlcnNpb25SYXRlIiwiZ2V0Q29udmVyc2lvbkRhdGUiLCJzZXRDb252ZXJzaW9uRGF0ZSIsIkZFQVRVUkVTX1BST1ZJREVSX0NIQU5HRV9XSU5ET1ciLCJoZWlnaHQiLCJ3aWR0aCIsIkZFQVRVUkVTX0RFRkFVTFRfV0FMTEVUX1dJTkRPVyIsIkZFQVRVUkVTX0RFRkFVTFRfUE9QVVBfV0lORE9XIiwiRkVBVFVSRVNfQ09ORklSTV9XSU5ET1ciLCJQT1BVUF9MT0FERUQiLCJQT1BVUF9SRVNVTFQiLCJTRVRVUF9DT01QTEVURSIsIkFDVElWSVRZX0FDVElPTl9BTEwiLCJBQ1RJVklUWV9BQ1RJT05fU0VORCIsIkFDVElWSVRZX0FDVElPTl9CVVJOIiwiQUNUSVZJVFlfQUNUSU9OX1JFQ0VJVkUiLCJBQ1RJVklUWV9BQ1RJT05fVE9QVVAiLCJBQ1RJVklUWV9BQ1RJT05fQ1JFQVRFX1RSVVNUTElORSIsIkFDVElWSVRZX0FDVElPTl9SRU1PVkVfVFJVU1RMSU5FIiwiQUNUSVZJVFlfQUNUSU9OX0NSRUFURV9ORlRfT0ZGRVIiLCJBQ1RJVklUWV9BQ1RJT05fQUNDRVBUX05GVF9PRkZFUiIsIkFDVElWSVRZX0FDVElPTl9DQU5DRUxfTkZUX09GRkVSIiwiQUNUSVZJVFlfUEVSSU9EX0FMTCIsIkFDVElWSVRZX1BFUklPRF9XRUVLX09ORSIsIkFDVElWSVRZX1BFUklPRF9NT05USF9PTkUiLCJBQ1RJVklUWV9QRVJJT0RfTU9OVEhfU0lYIiwiQUNUSVZJVFlfU1RBVFVTX1NVQ0NFU1NGVUwiLCJBQ1RJVklUWV9TVEFUVVNfVU5TVUNDRVNTRlVMIiwiQUNUSVZJVFlfU1RBVFVTX1BFTkRJTkciLCJBQ1RJVklUWV9TVEFUVVNfQ0FOQ0VMTEVEIiwiQUNUSVZJVFlfU1RBVFVTX0NBTkNFTExJTkciLCJDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMiLCJJRlJBTUVfU1RBVFVTIiwiQ0xPU0VfV0lORE9XIiwiVVNFUl9MT0dHRURfSU4iLCJVU0VSX0xPR0dFRF9PVVQiLCJDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUyIsIkxPR09VVCIsIldBTExFVF9JTlNUQU5DRV9JRCIsIlVTRVJfSU5GTyIsIlNFVF9QUk9WSURFUiIsIlRPUFVQIiwiQ0xPU0VEX1dJTkRPVyIsIldJTkRPV19CTE9DS0VEIiwiR0VUX1BST1ZJREVSX1NUQVRFIiwiTE9HSU5fV0lUSF9QUklWQVRFX0tFWSIsIlNIT1dfV0FMTEVUX0NPTk5FQ1QiLCJTSE9XX0NIRUNLT1VUIiwiU0hPV19XQUxMRVRfVUkiLCJMT0dJTl9XSVRIX1NFU1NJT05fSUQiLCJQUk9WSURFUl9KUlBDX01FVEhPRFMiLCJQUk9WSURFUl9OT1RJRklDQVRJT05TIiwiQUNDT1VOVFNfQ0hBTkdFRCIsIkNIQUlOX0NIQU5HRUQiLCJVTkxPQ0tfU1RBVEVfQ0hBTkdFRCIsIkJST0FEQ0FTVF9DSEFOTkVMUyIsIlJFRElSRUNUX0NIQU5ORUwiLCJQUk9WSURFUl9DSEFOR0VfQ0hBTk5FTCIsIlRSQU5TQUNUSU9OX0NIQU5ORUwiLCJNRVNTQUdFX0NIQU5ORUwiLCJXQUxMRVRfTE9HT1VUX0NIQU5ORUwiLCJXQUxMRVRfU0VMRUNURURfQUREUkVTU19DSEFOTkVMIiwiV0FMTEVUX05FVFdPUktfQ0hBTkdFX0NIQU5ORUwiLCJXQUxMRVRfQUNDT1VOVF9JTVBPUlRfQ0hBTk5FTCIsIlRIRU1FX0NIQU5HRSIsIlRPUF9VUF9DSEFOTkVMIiwiQlJPQURDQVNUX0NIQU5ORUxTX01TR1MiLCJBQ0NPVU5UX0lNUE9SVEVEIiwiU0VMRUNURURfQUREUkVTU19DSEFOR0UiLCJORVRXT1JLX0NIQU5HRSIsIlNFVF9USEVNRSIsIkNvbnRyb2xsZXJFdmVudHMiLCJjcmVhdGVDaGFuZ2VQcm92aWRlck1pZGRsZXdhcmVNaWRkbGV3YXJlIiwiY2hhbmdlUHJvdmlkZXIiLCJyZXF1ZXN0IiwicmVzcG9uc2UiLCJuZXh0IiwibWV0aG9kIiwicmVzdWx0IiwiY3JlYXRlVG9wdXBNaWRkbGV3YXJlIiwidG9wdXAiLCJjcmVhdGVHZW5lcmljSlJQQ01pZGRsZXdhcmUiLCJ0YXJnZXRNZXRob2QiLCJ1bmRlZmluZWQiLCJjcmVhdGVDb21tdW5pY2F0aW9uTWlkZGxld2FyZSIsInByb3ZpZGVySGFuZGxlcnMiLCJnZXRVc2VySW5mbyIsImdldFdhbGxldEluc3RhbmNlSWQiLCJsb2dvdXQiLCJzZXRJRnJhbWVTdGF0dXMiLCJoYW5kbGVXaW5kb3dScGMiLCJnZXRQcm92aWRlclN0YXRlIiwibG9naW5XaXRoUHJpdmF0ZUtleSIsInNob3dXYWxsZXRDb25uZWN0Iiwic2hvd0NoZWNrb3V0Iiwic2hvd1dhbGxldFVpIiwic2hvd1dpbmRvd0Jsb2NrQWxlcnQiLCJsb2dpbldpdGhTZXNzaW9uSWQiLCJCYXNlRW1iZWRDb250cm9sbGVyIiwiaXNJRnJhbWVGdWxsU2NyZWVuIiwib2F1dGhNb2RhbFZpc2liaWxpdHkiLCJsb2dpbkluUHJvZ3Jlc3MiLCJkYXBwTWV0YWRhdGEiLCJpY29uIiwid2ViM0F1dGhDbGllbnRJZCIsIndlYjNBdXRoTmV0d29yayIsIndoaXRlTGFiZWwiLCJjb25maXJtYXRpb25TdHJhdGVneSIsImluaXRpYWxpemVQcm92aWRlciIsImhhbmRsZXJzIiwiZW5naW5lIiwiY29tbXVuaWNhdGlvbk1pZGRsZXdhcmUiLCJwdXNoIiwiY29tbXVuaWNhdGlvblByb3ZpZGVyIiwic2V0Q29tbXVuaWNhdGlvblByb3ZpZGVyIiwiX2NvbW11bmljYXRpb25Qcm92aWRlclByb3h5IiwiQ29tbXVuaWNhdGlvbldpbmRvd01hbmFnZXIiLCJhcmdzIiwiZW5kIiwicGFyYW1zIiwid2luZG93SWQiLCJCVVRUT05fUE9TSVRJT04iLCJCT1RUT01fTEVGVCIsIlRPUF9MRUZUIiwiQk9UVE9NX1JJR0hUIiwiVE9QX1JJR0hUIiwiQ09ORklSTUFUSU9OX1NUUkFURUdZIiwiUE9QVVAiLCJNT0RBTCIsIkFVVE9fQVBQUk9WRSIsIkRFRkFVTFQiLCJMT0dJTl9QUk9WSURFUiIsIkdPT0dMRSIsIkZBQ0VCT09LIiwiUkVERElUIiwiRElTQ09SRCIsIlRXSVRDSCIsIkFQUExFIiwiTElORSIsIkdJVEhVQiIsIktBS0FPIiwiTElOS0VESU4iLCJUV0lUVEVSIiwiV0VJQk8iLCJXRUNIQVQiLCJFTUFJTF9QQVNTV09SRExFU1MiLCJTTVNfUEFTU1dPUkRMRVNTIiwiUEFZTUVOVF9QUk9WSURFUiIsIk1PT05QQVkiLCJXWVJFIiwiUkFNUE5FVFdPUksiLCJYQU5QT09MIiwiTUVSQ1VSWU8iLCJUUkFOU0FLIiwib21pdEJ5Iiwib2JqZWN0IiwicHJlZGljYXRlIiwiZW50cmllcyIsInBpY2tCeSIsImNsb25lRGVlcCIsInN0cnVjdHVyZWRDbG9uZSIsImVycm9yIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiYXV0aFNlcnZlciIsInNpZ25DaGFsbGVuZ2UiLCJwYXlsb2FkIiwiY2hhaW5OYW1lc3BhY2UiLCJ0IiwiaGVhZGVyIiwibmV0d29yayIsImRhdGEiLCJyZXMiLCJzdWNjZXNzIiwiY2hhbGxlbmdlIiwidmVyaWZ5U2lnbmVkQ2hhbGxlbmdlIiwic2lnbmVkTWVzc2FnZSIsImlzc3VlciIsInNlc3Npb25UaW1lIiwiY2xpZW50SWQiLCJhdWRpZW5jZSIsImFkZGl0aW9uYWxNZXRhZGF0YSIsIl93aW5kb3ckbG9jYXRpb24iLCJzaWdEYXRhIiwic2lnbmF0dXJlIiwicyIsIm1lc3NhZ2UiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhvc3RuYW1lIiwidGltZW91dCIsImlkVG9rZW5SZXMiLCJoZWFkZXJzIiwiY2xpZW50X2lkIiwid2FsbGV0X3Byb3ZpZGVyIiwid2ViM2F1dGhfbmV0d29yayIsInRva2VuIiwiZ2V0VHhTdGF0dXNUZXh0IiwidHhTdGF0dXMiLCJpbnRUb0hleCIsImkiLCJoZXgiLCJ0b1N0cmluZyIsInJhbmRvbUlkIiwiTWF0aCIsInJhbmRvbSIsInNsaWNlIiwicGFkV2l0aFplcm9lcyIsImhleFN0cmluZyIsInRhcmdldExlbmd0aCIsInRlc3QiLCJTdHJpbmciLCJwcm90b3R5cGUiLCJwYWRTdGFydCIsImNhbGwiLCJjb25jYXRTaWciLCJ2IiwiciIsInJTaWciLCJzU2lnIiwidlNpZyIsInJTdHIiLCJCdWZmZXIiLCJmcm9tIiwic1N0ciIsInZTdHIiLCJjb25jYXQiLCJ0aW1lb3V0JDEiLCJkdXJhdGlvbiIsInRpbWVvdXRSZWYiLCJnZXRIZWFkZXJzIiwiand0IiwicHVibGljQWRkcmVzcyIsIkF1dGhvcml6YXRpb24iLCJmb3JtYXRTbWFsbE51bWJlcnMiLCJudW1iZXIiLCJjdXJyZW5jeSIsIm5vVGlsZGUiLCJmaW5hbE51bWJlciIsImlzQmlnTnVtYmVyIiwidG9OdW1iZXIiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInRvTG93ZXJDYXNlIiwicGFyc2VGbG9hdCIsInRvRml4ZWQiLCJ0aWxkZSIsInRvVXBwZXJDYXNlIiwiYWRkcmVzc1NsaWNlciIsImFkZHJlc3MiLCJzbGljZUxlbmd0aCIsImxlbmd0aCIsInNpZ25pZmljYW50RGlnaXRzIiwicGVyYyIsImxlbmd0aF8iLCJpbnB1dCIsImlzWmVybyIsInRpbWVzIiwiZGVwdGgiLCJndGUiLCJjZWlsIiwibG9nMTAiLCJkaXYiLCJzaGlmdCIsInBvdyIsInJvdW5kZWROdW1iZXIiLCJyb3VuZCIsImZvcm1hdERhdGUiLCJpbnB1dERhdGUiLCJtb250aExpc3QiLCJkYXRlIiwiRGF0ZSIsImRheSIsImdldERhdGUiLCJtb250aCIsImdldE1vbnRoIiwieWVhciIsImdldEZ1bGxZZWFyIiwiZm9ybWF0VGltZSIsInRpbWUiLCJ0b1RpbWVTdHJpbmciLCJ0cmFuc2FjdGlvbk1hdGNoZXNOZXR3b3JrIiwidHJhbnNhY3Rpb24iLCJjaGFpbklkIiwiaGFzaE1lc3NhZ2UiLCJidWZmZXJlZE1lc3NhZ2UiLCJlbCIsInNpZ25NZXNzYWdlIiwicHJpdmF0ZUtleSIsInByaXZLZXkiLCJtc2dTaWciLCJyYXdNc2dTaWciLCJnZXRQb3B1cEZlYXR1cmVzIiwidyIsImgiLCJkdWFsU2NyZWVuTGVmdCIsInNjcmVlbkxlZnQiLCJzY3JlZW5YIiwiZHVhbFNjcmVlblRvcCIsInNjcmVlblRvcCIsInNjcmVlblkiLCJpbm5lcldpZHRoIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsInNjcmVlbiIsImlubmVySGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic3lzdGVtWm9vbSIsImxlZnQiLCJhYnMiLCJ0b3AiLCJmZWF0dXJlcyIsImJyb2FkY2FzdENoYW5uZWxPcHRpb25zIiwidHlwZSIsIndlYldvcmtlclN1cHBvcnQiLCJnZXRDdXN0b21EZXZpY2VJbmZvIiwiX25hdmlnYXRvciIsIm5hdmlnYXRvciIsImJyYXZlIiwiYnJvd3NlciIsIlVzZXJFcnJvciIsImhhbmRsZVJlZGlyZWN0UGFyYW1ldGVycyIsImhhc2giLCJxdWVyeVBhcmFtZXRlcnMiLCJoYXNoUGFyYW1ldGVycyIsImhhc2hVcmwiLCJVUkwiLCJvcmlnaW4iLCJzZWFyY2hQYXJhbXMiLCJpbnN0YW5jZVBhcmFtZXRlcnMiLCJrZXlzIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXJyb3JfZGVzY3JpcHRpb24iLCJzbGVlcCIsIm1zIiwiaXNVbmF1dGhvcml6ZWRFcnJvciIsIlJlc3BvbnNlIiwic3RhdHVzIiwiQmFzZUtleXJpbmdDb250cm9sbGVyIiwiX3N0YXRlJHdhbGxldHMiLCJ3YWxsZXRzIiwic2lnbkF1dGhNZXNzYWdlIiwia2V5cmluZyIsImZpbmQiLCJ4IiwiaGFzaGVkTWVzc2FnZSIsInJhd01lc3NhZ2VTaWciLCJSRVRSSUFCTEVfRVJST1JTIiwiY2hlY2tGb3JIdHRwRXJyb3JzIiwiZmV0Y2hSZXMiLCJtZXRob2ROb3RGb3VuZCIsImludGVybmFsIiwiY2F1c2UiLCJwYXJzZVJlc3BvbnNlIiwiYm9keSIsImNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSIsInJlcSIsInJwY1RhcmdldCIsIm9yaWdpbkh0dHBIZWFkZXJLZXkiLCJwYXJzZWRVcmwiLCJpZCIsImpzb25ycGMiLCJvcmlnaW5Eb21haW4iLCJzZXJpYWxpemVkUGF5bG9hZCIsImZldGNoUGFyYW1zIiwiQWNjZXB0IiwiZmV0Y2hVcmwiLCJocmVmIiwiY3JlYXRlRmV0Y2hNaWRkbGV3YXJlIiwiX25leHQiLCJtYXhBdHRlbXB0cyIsInJldHJ5SW50ZXJ2YWwiLCJhdHRlbXB0IiwiZmV0Y2giLCJmZXRjaEJvZHkiLCJqc29uIiwiZXJyIiwiZXJyTXNnIiwiaXNSZXRyaWFibGUiLCJzb21lIiwicGhyYXNlIiwiZGVmZXJyZWRQcm9taXNlIiwicHJvbWlzZSIsIl9yZXNvbHZlIiwiY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUiLCJjYWNoZUlkZW50aWZpZXJGb3JSZXF1ZXN0IiwiaW5mbGlnaHRSZXF1ZXN0cyIsImNyZWF0ZUFjdGl2ZVJlcXVlc3RIYW5kbGVyIiwiYWN0aXZlUmVxdWVzdEhhbmRsZXJzIiwiaGFuZGxlZFJlcyIsImhhbmRsZUFjdGl2ZVJlcXVlc3QiLCJza2lwQ2FjaGUiLCJjYWNoZUlkIiwiaW5mbyIsImNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUiLCJvcHRpb25zIiwibG9nZ2VyTWlkZGxld2FyZSIsImNhbGxiYWNrIiwid2FybiIsImlzVG9ydXNJbnRlcm5hbCIsImNyZWF0ZU9yaWdpbk1pZGRsZXdhcmUiLCJvcmlnaW5NaWRkbGV3YXJlIiwiY3JlYXRlUmFuZG9tSWQiLCJzdWJzdHJpbmciLCJDSEFJTl9OQU1FU1BBQ0VTIiwiRUlQMTU1IiwiU09MQU5BIiwiQ0FTUEVSIiwiWFJQTCIsIk9USEVSIiwiQnJvYWRjYXN0Q2hhbm5lbEhhbmRsZXIiLCJjaGFubmVsUHJlZml4IiwiaW5zdGFuY2VJZCIsIlVSTFNlYXJjaFBhcmFtcyIsInNlYXJjaCIsImNoYW5uZWwiLCJiYyIsImdldE1lc3NhZ2VGcm9tQ2hhbm5lbCIsInJlamVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldiIsImNsb3NlIiwicG9zdE1lc3NhZ2UiLCJTdHJlYW1XaW5kb3ciLCJvcGVuIiwiY29tbXVuaWNhdGlvbkVuZ2luZSIsImNvbW11bmljYXRpb25XaW5kb3dNYW5hZ2VyIiwicG9wdXBTdWNjZXNzIiwiY2xvc2VkIiwiaGFuZGxlV2luZG93QmxvY2tBbGVydCIsImZpbmFsVXJsIiwidXJsIiwidGhlbiIsImNhdGNoIiwiaXNGdWxsU2NyZWVuIiwicmlkIiwiY2hhbm5lbE5hbWUiLCJwb3N0TXNnIiwibG9jYWxSZXNwb25zZSIsImN1cnJlbnREZWxheSIsInJlY3Vyc2l2ZUZuIiwic2VydmVyUmVzcG9uc2UiLCJQb3B1cEhhbmRsZXIiLCJ3aW5kb3dUaW1lciIsImlDbG9zZWRXaW5kb3ciLCJfc2V0dXBUaW1lciIsImxvY2FsV2luZG93IiwiZmluYWxXaW5kb3dJZCIsInN0cmVhbVdpbmRvdyIsInRpbWVyIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiUG9wdXBTdG9yZUNoYW5uZWwiLCJoYW5kbGVMb2dvdXQiLCJoYW5kbGVBY2NvdW50SW1wb3J0IiwiaGFuZGxlTmV0d29ya0NoYW5nZSIsImhhbmRsZVNlbGVjdGVkQWRkcmVzc0NoYW5nZSIsImhhbmRsZVRoZW1lQ2hhbmdlIiwic2V0dXBTdG9yZUNoYW5uZWxzIiwibG9nb3V0Q2hhbm5lbCIsImltcG9ydEFjY291bnRDaGFubmVsIiwibmV0d29ya0NoYW5nZUNoYW5uZWwiLCJzZWxlY3RlZEFkZHJlc3NDaGFuZ2VDaGFubmVsIiwidGhlbWVDaGFuZ2VkQ2hhbm5lbCIsIl9ldiRkYXRhIiwid2FsbGV0QWNjb3VudEltcG9ydENoYW5uZWwiLCJfZXYkZGF0YTIiLCJfZXYkZGF0YTMiLCJfZXYkZGF0YTQiLCJfZXYkZGF0YTUiLCJfZXYkZGF0YTYiLCJfZXYkZGF0YTciLCJ0aGVtZSIsIl9ldiRkYXRhOCIsIl9ldiRkYXRhOSIsInNlbGVjdGVkQWRkcmVzcyIsIlBvcHVwV2l0aEJjSGFuZGxlciIsImhhbmRsZSIsInN1Y2Nlc3NFeHRyYUZuIiwiY2xvc2VMaXN0ZW5lciIsImhhbmRsZVdpdGhIYW5kc2hha2UiLCJSZWRpcmVjdEhhbmRsZXIiLCJmaW5hbFF1ZXJ5UGFyYW1zIiwiSFRUUF9NRVRIT0QiLCJjb25zdHJ1Y3RBdXRoSGVhZGVycyIsImp3dFRva2VuIiwid2l0aFVuYXV0aG9yaXplZEhhbmRsZXIiLCJmbiIsImVtaXR0ZXIiLCJlIiwiVXNlclVuYXV0aG9yaXplZCIsImp3dFRva2VuRXhwaXJlZCIsImRlY29kZWQiLCJqd3RFeHBpcnkiLCJleHAiLCJjdXJyZW50VGltZSIsImdldFRpbWUiLCJXU0FwaUNsaWVudCIsImJhc2VBcGlVcmwiLCJhdXRoUmVxdWVzdCIsImF1dGhDcmVkZW50aWFscyIsImN1c3RvbU9wdGlvbnMiLCJzdGF0dXNUZXh0IiwiR0VUIiwiUE9TVCIsIlBVVCIsIlBBVENIIiwiREVMRVRFIiwiYXV0aEdldCIsImF1dGhQb3N0IiwiYXV0aFB1dCIsImF1dGhQYXRjaCIsImF1dGhSZW1vdmUiLCJBQ1RJVklUWV9BQ1RJT04iLCJBQ0NPVU5UX0NBVEVHT1JZIiwiTk9STUFMIiwiVEhSRVNIT0xEIiwiSU1QT1JURUQiLCJBUFBfU0NPUEVEIiwiQUNDT1VOVF9BQlNUUkFDVElPTiIsIkVYVEVSTkFMIiwiTVBDIiwiU0ZBIiwiREVGQVVMVF9JTlRFUlZBTCIsIkRFRkFVTFRfUFJFRkVSRU5DRVMiLCJzZWxlY3RlZEN1cnJlbmN5IiwibG9jYWxlIiwiYWNjb3VudFR5cGUiLCJjb250YWN0cyIsImZldGNoZWRQYXN0VHgiLCJwYXN0VHJhbnNhY3Rpb25zIiwicGF5bWVudFR4IiwiZGVmYXVsdFB1YmxpY0FkZHJlc3MiLCJjdXN0b21Ub2tlbnMiLCJjdXN0b21OZnRzIiwiY3Jhc2hSZXBvcnQiLCJ1c2VySW5mbyIsImFnZ3JlZ2F0ZVZlcmlmaWVyIiwiZW1haWwiLCJwcm9maWxlSW1hZ2UiLCJ0eXBlT2ZMb2dpbiIsInZlcmlmaWVyIiwidmVyaWZpZXJJZCIsIkJhc2VQcmVmZXJlbmNlc0NvbnRyb2xsZXIiLCJkZWZhdWx0UHJlZmVyZW5jZXMiLCJ2YWxpZGF0ZVNpZ25NZXNzYWdlIiwiYXBpIiwiaWRlbnRpdGllcyIsImxhc3RFcnJvck1lc3NhZ2UiLCJsYXN0U3VjY2Vzc01lc3NhZ2UiLCJ3c0FwaUNsaWVudCIsInNldElmcmFtZU9yaWdpbiIsImlmcmFtZU9yaWdpbiIsImdldEFkZHJlc3NTdGF0ZSIsInNldFNlbGVjdGVkQWRkcmVzcyIsImdldFVzZXIiLCJ1c2VyIiwidXNlQVBJS2V5IiwiY3JlYXRlVXNlciIsImlkVG9rZW4iLCJ1c2VyUGF5bG9hZCIsImRlZmF1bHRfY3VycmVuY3kiLCJ2ZXJpZmllcl9pZCIsImFjY291bnRfdHlwZSIsInVwZGF0ZVN0YXRlIiwic3RvcmVVc2VyTG9naW4iLCJzZXNzaW9uUHViS2V5IiwibG9naW5Nb2RlIiwicmVoeWRyYXRlIiwiZ2V0UGFyc2VyIiwidXNlckFnZW50Iiwic3BlY2lhbEJyb3dzZXIiLCJyZWNvcmRMb2dpblBheWxvYWQiLCJvcyIsImdldE9TTmFtZSIsIm9zX3ZlcnNpb24iLCJnZXRPU1ZlcnNpb24iLCJnZXRCcm93c2VyTmFtZSIsImJyb3dzZXJfdmVyc2lvbiIsImdldEJyb3dzZXJWZXJzaW9uIiwicGxhdGZvcm0iLCJnZXRQbGF0Zm9ybSIsIndlYjNhdXRoX2NsaWVudF9pZCIsInNlc3Npb25fcHViX2tleSIsImxvZ2luX21vZGUiLCJzZXRDcmFzaFJlcG9ydCIsImlzRW5hYmxlZCIsIl90aGlzJGdldEFkZHJlc3NTdGF0ZSIsImVuYWJsZV9jcmFzaF9yZXBvcnRlciIsInNldFVzZXJUaGVtZSIsIl90aGlzJGdldEFkZHJlc3NTdGF0ZTIiLCJzZXRVc2VyTG9jYWxlIiwiX3RoaXMkZ2V0QWRkcmVzc1N0YXRlMyIsInNldFNlbGVjdGVkQ3VycmVuY3kiLCJfdGhpcyRnZXRBZGRyZXNzU3RhdGU0IiwiYWRkQ29udGFjdCIsImNvbnRhY3QiLCJfdGhpcyRnZXRBZGRyZXNzU3RhdGU1IiwiZGVsZXRlQ29udGFjdCIsImNvbnRhY3RJZCIsIl90aGlzJGdldEFkZHJlc3NTdGF0ZTYiLCJmaW5hbENvbnRhY3RzIiwicmV2b2tlRGlzY29yZCIsInJlc3AiLCJwYXRjaFBhc3RUeCIsInBvc3RQYXN0VHgiLCJ0eCIsImdldFdhbGxldE9yZGVycyIsImdldFRvcFVwT3JkZXJzIiwiZ2V0QmlsbEJvYXJkRGF0YSIsImdldE1lc3NhZ2VGb3JTaWduaW5nIiwid2ViM0F1dGhJZFRva2VuIiwicHVibGljX2FkZHJlc3MiLCJpZF90b2tlbiIsImdldFR3aXR0ZXJJZCIsIm5pY2siLCJzZW5kRW1haWwiLCJlbWFpbE9iamVjdCIsInJlZnJlc2hKd3QiLCJtZXNzYWdlVG9TaWduIiwic2lnbmVkX21lc3NhZ2UiLCJnZXREYXBwTGlzdCIsImluaXQiLCJtZXRhZGF0YSIsInNpZ25hdHVyZXMiLCJwcmVmZXJlbmNlcyIsImN1cnJlbnRTdGF0ZSIsIm1lcmdlZFN0YXRlIiwiX3RoaXMkZ2V0QWRkcmVzc1N0YXRlNyIsIl90aGlzJGdldEFkZHJlc3NTdGF0ZTgiLCJUcmFuc2FjdGlvblN0YXR1cyIsIlRSQU5TQUNUSU9OX1RZUEVTIiwiQ0FOQ0VMIiwiUkVUUlkiLCJDT05UUkFDVF9JTlRFUkFDVElPTiIsIkRFUExPWV9DT05UUkFDVCIsIldBU01fQkFTRURfREVQTE9ZIiwiU1RBTkRBUkRfVFJBTlNBQ1RJT04iLCJTVEFOREFSRF9QQVlNRU5UX1RSQU5TQUNUSU9OIiwiU0VOVF9FVEhFUiIsIlRPS0VOX01FVEhPRF9UUkFOU0ZFUiIsIlRPS0VOX01FVEhPRF9UUkFOU0ZFUl9GUk9NIiwiVE9LRU5fTUVUSE9EX0FQUFJPVkUiLCJDT0xMRUNUSUJMRV9NRVRIT0RfU0FGRV9UUkFOU0ZFUl9GUk9NIiwiU0VUX0FQUFJPVkFMX0ZPUl9BTEwiLCJUWF9FVkVOVFMiLCJUWF9XQVJOSU5HIiwiVFhfRVJST1IiLCJUWF9GQUlMRUQiLCJUWF9DT05GSVJNRUQiLCJUWF9EUk9QUEVEIiwiVFhfRVhQSVJFRCIsIlRYX1NUQVRVU19VUERBVEUiLCJUWF9VTkFQUFJPVkVEIiwiVFhfUkVUUlkiLCJUWF9CTE9DS19VUERBVEUiLCJCYXNlVHJhbnNhY3Rpb25TdGF0ZU1hbmFnZXIiLCJnZXRDdXJyZW50Q2hhaW5JZCIsInR4SGlzdG9yeUxpbWl0IiwidHJhbnNhY3Rpb25zIiwidW5hcHByb3ZlZFR4cyIsImN1cnJlbnROZXR3b3JrVHhzTGlzdCIsImdldFVuYXBwcm92ZWRUeExpc3QiLCJ1bmFwcHJvdmVkIiwiZ2V0VHJhbnNhY3Rpb24iLCJ0eElkIiwidXBkYXRlVHJhbnNhY3Rpb24iLCJ0eE1ldGEiLCJ1cGRhdGVkX2F0IiwidG9JU09TdHJpbmciLCJzZXRUeFN0YXR1c1JlamVjdGVkIiwiX3NldFRyYW5zYWN0aW9uU3RhdHVzIiwicmVqZWN0ZWQiLCJfZGVsZXRlVHJhbnNhY3Rpb24iLCJzZXRUeFN0YXR1c1VuYXBwcm92ZWQiLCJzZXRUeFN0YXR1c0FwcHJvdmVkIiwiYXBwcm92ZWQiLCJzZXRUeFN0YXR1c1NpZ25lZCIsImlzRmluYWxTdGVwIiwic2lnbmVkIiwic2V0VHhTdGF0dXNTdWJtaXR0ZWQiLCJzdWJtaXR0ZWQiLCJzZXRUeFN0YXR1c0Ryb3BwZWQiLCJkcm9wcGVkIiwic2V0VHhTdGF0dXNFeHBpcmVkIiwiZXhwaXJlZCIsInNldFR4U3RhdHVzQ29uZmlybWVkIiwiY29uZmlybWVkIiwic2V0VHhTdGF0dXNGYWlsZWQiLCJlcnJvcl8iLCJmYWlsZWQiLCJpc0ZpbmFsU3RhdGUiLCJjYW5jZWxsZWQiLCJjbGVhclVuYXBwcm92ZWRUeHMiLCJfYWRkVHJhbnNhY3Rpb25zVG9TdGF0ZSIsIm5ld1R4IiwiX3NldFRyYW5zYWN0aW9uc1RvU3RhdGUiLCJ0YXJnZXRUcmFuc2FjdGlvbklkIiwiX2RlbGV0ZVRyYW5zYWN0aW9ucyIsInRhcmdldFRyYW5zYWN0aW9uSWRzIiwidHJhbnNhY3Rpb25JZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BroadcastChannel: () => (/* binding */ BroadcastChannel$1),\n/* harmony export */   IndexedDbMethod: () => (/* binding */ IndexeDbMethod),\n/* harmony export */   LocalStorageMethod: () => (/* binding */ LocalstorageMethod),\n/* harmony export */   NativeMethod: () => (/* binding */ NativeMethod),\n/* harmony export */   OPEN_BROADCAST_CHANNELS: () => (/* binding */ OPEN_BROADCAST_CHANNELS),\n/* harmony export */   ServerMethod: () => (/* binding */ ServerMethod),\n/* harmony export */   chooseMethod: () => (/* binding */ chooseMethod),\n/* harmony export */   enforceOptions: () => (/* binding */ enforceOptions)\n/* harmony export */ });\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var oblivious_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! oblivious-set */ \"(ssr)/./node_modules/oblivious-set/dist/esm/src/index.js\");\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! socket.io-client */ \"(ssr)/./node_modules/socket.io-client/build/esm-debug/index.js\");\n/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/eccrypto */ \"(ssr)/./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\");\n/* harmony import */ var _toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/metadata-helpers */ \"(ssr)/./node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js\");\n\n\n\n\n\n// import Bowser from 'bowser';\n/**\n * returns true if the given object is a promise\n */ function isPromise(obj) {\n    if (obj && typeof obj.then === \"function\") {\n        return true;\n    } else {\n        return false;\n    }\n}\nPromise.resolve(false);\nPromise.resolve(true);\nconst PROMISE_RESOLVED_VOID = Promise.resolve();\nfunction sleep(time, resolveWith) {\n    if (!time) time = 0;\n    return new Promise((res)=>setTimeout(()=>res(resolveWith), time));\n}\nfunction randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\n * https://stackoverflow.com/a/8084248\n */ function randomToken() {\n    return Math.random().toString(36).substring(2);\n}\nlet lastMs = 0;\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */ function microSeconds$5() {\n    let ret = Date.now() * 1000; // milliseconds to microseconds\n    if (ret <= lastMs) {\n        ret = lastMs + 1;\n    }\n    lastMs = ret;\n    return ret;\n}\n// the problem is only in iframes. we should default to server in case of iframes.\n// storage scoping is present in all browsers now\n// Safari and other browsers support native Broadcast channel now. It's in LS.\n// test here: https://pubkey.github.io/broadcast-channel/e2e.html?methodType=native\n// https://caniuse.com/broadcastchannel\n// export function are3PCSupported() {\n//     if (typeof navigator === 'undefined') return false;\n//     const browserInfo = Bowser.parse(navigator.userAgent);\n//     log.info(JSON.stringify(browserInfo), 'current browser info');\n//     let thirdPartyCookieSupport = true;\n//     // brave\n//     if (navigator.brave) {\n//         thirdPartyCookieSupport = false;\n//     }\n//     // All webkit & gecko engine instances use itp (intelligent tracking prevention -\n//     // https://webkit.org/tracking-prevention/#intelligent-tracking-prevention-itp)\n//     if (browserInfo.engine.name === Bowser.ENGINE_MAP.WebKit || browserInfo.engine.name === Bowser.ENGINE_MAP.Gecko) {\n//         thirdPartyCookieSupport = false;\n//     }\n//     return thirdPartyCookieSupport;\n// }\nconst log = loglevel__WEBPACK_IMPORTED_MODULE_0___default().getLogger(\"broadcast-channel\");\nlog.setLevel(\"error\");\nconst microSeconds$4 = microSeconds$5;\nconst type$4 = \"native\";\nfunction create$4(channelName) {\n    const state = {\n        time: microSeconds$5(),\n        messagesCallback: null,\n        bc: new BroadcastChannel(channelName),\n        subFns: [] // subscriberFunctions\n    };\n    state.bc.onmessage = (msg)=>{\n        if (state.messagesCallback) {\n            state.messagesCallback(msg.data);\n        }\n    };\n    return state;\n}\nfunction close$4(channelState) {\n    channelState.bc.close();\n    channelState.subFns = [];\n}\nfunction postMessage$4(channelState, messageJson) {\n    try {\n        channelState.bc.postMessage(messageJson, false);\n        return PROMISE_RESOLVED_VOID;\n    } catch (err) {\n        return Promise.reject(err);\n    }\n}\nfunction onMessage$4(channelState, fn1) {\n    channelState.messagesCallback = fn1;\n}\nfunction canBeUsed$4() {\n    /**\n   * in the electron-renderer, isNode will be true even if we are in browser-context\n   * so we also check if window is undefined\n   */ if (true) return false;\n    if (typeof BroadcastChannel === \"function\") {\n        if (BroadcastChannel._pubkey) {\n            throw new Error(\"BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill\");\n        }\n        return true;\n    } else return false;\n}\nfunction averageResponseTime$4() {\n    return 150;\n}\nvar NativeMethod = {\n    create: create$4,\n    close: close$4,\n    onMessage: onMessage$4,\n    postMessage: postMessage$4,\n    canBeUsed: canBeUsed$4,\n    type: type$4,\n    averageResponseTime: averageResponseTime$4,\n    microSeconds: microSeconds$4\n};\nfunction fillOptionsWithDefaults() {\n    let originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const options = JSON.parse(JSON.stringify(originalOptions));\n    // main\n    if (typeof options.webWorkerSupport === \"undefined\") options.webWorkerSupport = true;\n    // indexed-db\n    if (!options.idb) options.idb = {};\n    //  after this time the messages get deleted\n    if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n    if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;\n    //  handles abrupt db onclose events.\n    if (originalOptions.idb && typeof originalOptions.idb.onclose === \"function\") options.idb.onclose = originalOptions.idb.onclose;\n    // localstorage\n    if (!options.localstorage) options.localstorage = {};\n    if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60;\n    // server\n    if (!options.server) options.server = {};\n    if (!options.server.url) options.server.url = \"https://session.web3auth.io\";\n    if (!options.server.removeTimeout) options.server.removeTimeout = 1000 * 60 * 5; // 5 minutes\n    // custom methods\n    if (originalOptions.methods) options.methods = originalOptions.methods;\n    return options;\n}\n/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n *\n * When working on this, ensure to use these performance optimizations:\n * @link https://rxdb.info/slow-indexeddb.html\n */ const microSeconds$3 = microSeconds$5;\nconst DB_PREFIX = \"pubkey.broadcast-channel-0-\";\nconst OBJECT_STORE_ID = \"messages\";\n/**\n * Use relaxed durability for faster performance on all transactions.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */ const TRANSACTION_SETTINGS = {\n    durability: \"relaxed\"\n};\nconst type$3 = \"idb\";\nfunction getIdb() {\n    if (typeof indexedDB !== \"undefined\") return indexedDB;\n    if (false) {}\n    return false;\n}\n/**\n * If possible, we should explicitly commit IndexedDB transactions\n * for better performance.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */ function commitIndexedDBTransaction(tx) {\n    if (tx.commit) {\n        tx.commit();\n    }\n}\nfunction createDatabase(channelName) {\n    const IndexedDB = getIdb();\n    // create table\n    const dbName = DB_PREFIX + channelName;\n    /**\n   * All IndexedDB databases are opened without version\n   * because it is a bit faster, especially on firefox\n   * @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version\n   */ const openRequest = IndexedDB.open(dbName);\n    openRequest.onupgradeneeded = (ev)=>{\n        const db = ev.target.result;\n        db.createObjectStore(OBJECT_STORE_ID, {\n            keyPath: \"id\",\n            autoIncrement: true\n        });\n    };\n    const dbPromise = new Promise((res, rej)=>{\n        openRequest.onerror = (ev)=>rej(ev);\n        openRequest.onsuccess = ()=>{\n            res(openRequest.result);\n        };\n    });\n    return dbPromise;\n}\n/**\n * writes the new message to the database\n * so other readers can find it\n */ function writeMessage(db, readerUuid, messageJson) {\n    const time = Date.now();\n    const writeObject = {\n        uuid: readerUuid,\n        time,\n        data: messageJson\n    };\n    const tx = db.transaction([\n        OBJECT_STORE_ID\n    ], \"readwrite\", TRANSACTION_SETTINGS);\n    return new Promise((res, rej)=>{\n        tx.oncomplete = ()=>res();\n        tx.onerror = (ev)=>rej(ev);\n        const objectStore = tx.objectStore(OBJECT_STORE_ID);\n        objectStore.add(writeObject);\n        commitIndexedDBTransaction(tx);\n    });\n}\nfunction getAllMessages(db) {\n    const tx = db.transaction(OBJECT_STORE_ID, \"readonly\", TRANSACTION_SETTINGS);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    const ret = [];\n    return new Promise((res)=>{\n        objectStore.openCursor().onsuccess = (ev)=>{\n            const cursor = ev.target.result;\n            if (cursor) {\n                ret.push(cursor.value);\n                //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n                cursor.continue();\n            } else {\n                commitIndexedDBTransaction(tx);\n                res(ret);\n            }\n        };\n    });\n}\nfunction getMessagesHigherThan(db, lastCursorId) {\n    const tx = db.transaction(OBJECT_STORE_ID, \"readonly\", TRANSACTION_SETTINGS);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    const ret = [];\n    let keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n    /**\n   * Optimization shortcut,\n   * if getAll() can be used, do not use a cursor.\n   * @link https://rxdb.info/slow-indexeddb.html\n   */ if (objectStore.getAll) {\n        const getAllRequest = objectStore.getAll(keyRangeValue);\n        return new Promise((res, rej)=>{\n            getAllRequest.onerror = (err)=>rej(err);\n            getAllRequest.onsuccess = function(e) {\n                res(e.target.result);\n            };\n        });\n    }\n    function openCursor() {\n        // Occasionally Safari will fail on IDBKeyRange.bound, this\n        // catches that error, having it open the cursor to the first\n        // item. When it gets data it will advance to the desired key.\n        try {\n            keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n            return objectStore.openCursor(keyRangeValue);\n        } catch (e) {\n            return objectStore.openCursor();\n        }\n    }\n    return new Promise((res, rej)=>{\n        const openCursorRequest = openCursor();\n        openCursorRequest.onerror = (err)=>rej(err);\n        openCursorRequest.onsuccess = (ev)=>{\n            const cursor = ev.target.result;\n            if (cursor) {\n                if (cursor.value.id < lastCursorId + 1) {\n                    cursor.continue(lastCursorId + 1);\n                } else {\n                    ret.push(cursor.value);\n                    cursor.continue();\n                }\n            } else {\n                commitIndexedDBTransaction(tx);\n                res(ret);\n            }\n        };\n    });\n}\nfunction removeMessagesById(db, ids) {\n    const tx = db.transaction([\n        OBJECT_STORE_ID\n    ], \"readwrite\", TRANSACTION_SETTINGS);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    return Promise.all(ids.map((id)=>{\n        const deleteRequest = objectStore.delete(id);\n        return new Promise((res)=>{\n            deleteRequest.onsuccess = ()=>res();\n        });\n    }));\n}\nfunction getOldMessages(db, ttl) {\n    const olderThen = Date.now() - ttl;\n    const tx = db.transaction(OBJECT_STORE_ID, \"readonly\", TRANSACTION_SETTINGS);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    const ret = [];\n    return new Promise((res)=>{\n        objectStore.openCursor().onsuccess = (ev)=>{\n            const cursor = ev.target.result;\n            if (cursor) {\n                const msgObk = cursor.value;\n                if (msgObk.time < olderThen) {\n                    ret.push(msgObk);\n                    //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n                    cursor.continue();\n                } else {\n                    // no more old messages,\n                    commitIndexedDBTransaction(tx);\n                    res(ret);\n                    return;\n                }\n            } else {\n                res(ret);\n            }\n        };\n    });\n}\nfunction cleanOldMessages(db, ttl) {\n    return getOldMessages(db, ttl).then((tooOld)=>{\n        return removeMessagesById(db, tooOld.map((msg)=>msg.id));\n    });\n}\nfunction create$3(channelName, options) {\n    options = fillOptionsWithDefaults(options);\n    return createDatabase(channelName).then((db)=>{\n        const state = {\n            closed: false,\n            lastCursorId: 0,\n            channelName,\n            options,\n            uuid: randomToken(),\n            /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */ eMIs: new oblivious_set__WEBPACK_IMPORTED_MODULE_4__.ObliviousSet(options.idb.ttl * 2),\n            // ensures we do not read messages in parrallel\n            writeBlockPromise: PROMISE_RESOLVED_VOID,\n            messagesCallback: null,\n            readQueuePromises: [],\n            db,\n            time: microSeconds$5()\n        };\n        /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */ db.onclose = function() {\n            state.closed = true;\n            if (options.idb.onclose) options.idb.onclose();\n        };\n        /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */ _readLoop(state);\n        return state;\n    });\n}\nfunction _readLoop(state) {\n    if (state.closed) return;\n    readNewMessages(state).then(()=>sleep(state.options.idb.fallbackInterval)).then(()=>_readLoop(state));\n}\nfunction _filterMessage(msgObj, state) {\n    if (msgObj.uuid === state.uuid) return false; // send by own\n    if (state.eMIs.has(msgObj.id)) return false; // already emitted\n    if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n    return true;\n}\n/**\n * reads all new messages from the database and emits them\n */ function readNewMessages(state) {\n    // channel already closed\n    if (state.closed) return PROMISE_RESOLVED_VOID;\n    // if no one is listening, we do not need to scan for new messages\n    if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;\n    return getMessagesHigherThan(state.db, state.lastCursorId).then((newerMessages)=>{\n        const useMessages = newerMessages/**\n     * there is a bug in iOS where the msgObj can be undefined some times\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */ .filter((msgObj)=>!!msgObj).map((msgObj)=>{\n            if (msgObj.id > state.lastCursorId) {\n                state.lastCursorId = msgObj.id;\n            }\n            return msgObj;\n        }).filter((msgObj)=>_filterMessage(msgObj, state)).sort((msgObjA, msgObjB)=>msgObjA.time - msgObjB.time); // sort by time\n        useMessages.forEach((msgObj)=>{\n            if (state.messagesCallback) {\n                state.eMIs.add(msgObj.id);\n                state.messagesCallback(msgObj.data);\n            }\n        });\n        return PROMISE_RESOLVED_VOID;\n    });\n}\nfunction close$3(channelState) {\n    channelState.closed = true;\n    channelState.db.close();\n}\nfunction postMessage$3(channelState, messageJson) {\n    channelState.writeBlockPromise = channelState.writeBlockPromise.then(()=>writeMessage(channelState.db, channelState.uuid, messageJson)).then(()=>{\n        if (randomInt(0, 10) === 0) {\n            /* await (do not await) */ cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n        }\n    });\n    return channelState.writeBlockPromise;\n}\nfunction onMessage$3(channelState, fn1, time) {\n    channelState.messagesCallbackTime = time;\n    channelState.messagesCallback = fn1;\n    readNewMessages(channelState);\n}\nfunction canBeUsed$3() {\n    const idb = getIdb();\n    if (!idb) return false;\n    return true;\n}\nfunction averageResponseTime$3(options) {\n    return options.idb.fallbackInterval * 2;\n}\nvar IndexeDbMethod = {\n    getIdb,\n    createDatabase,\n    create: create$3,\n    close: close$3,\n    onMessage: onMessage$3,\n    postMessage: postMessage$3,\n    canBeUsed: canBeUsed$3,\n    type: type$3,\n    averageResponseTime: averageResponseTime$3,\n    microSeconds: microSeconds$3,\n    writeMessage,\n    getAllMessages,\n    cleanOldMessages,\n    getMessagesHigherThan,\n    getOldMessages\n};\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */ const microSeconds$2 = microSeconds$5;\nconst KEY_PREFIX$1 = \"pubkey.broadcastChannel-\";\nconst type$2 = \"localstorage\";\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */ function getLocalStorage() {\n    let localStorage;\n    if (true) return null;\n    try {\n        localStorage = window.localStorage;\n        localStorage = window[\"ie8-eventlistener/storage\"] || window.localStorage;\n    } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n    }\n    return localStorage;\n}\nfunction storageKey$1(channelName) {\n    return KEY_PREFIX$1 + channelName;\n}\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */ function postMessage$2(channelState, messageJson) {\n    return new Promise((res)=>{\n        sleep().then(()=>{\n            const key = storageKey$1(channelState.channelName);\n            const writeObj = {\n                token: randomToken(),\n                time: Date.now(),\n                data: messageJson,\n                uuid: channelState.uuid\n            };\n            const value = JSON.stringify(writeObj);\n            getLocalStorage().setItem(key, value);\n            /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */ const ev = document.createEvent(\"Event\");\n            ev.initEvent(\"storage\", true, true);\n            ev.key = key;\n            ev.newValue = value;\n            window.dispatchEvent(ev);\n            res();\n        });\n    });\n}\nfunction addStorageEventListener(channelName, fn1) {\n    const key = storageKey$1(channelName);\n    const listener = (ev)=>{\n        if (ev.key === key) {\n            fn1(JSON.parse(ev.newValue));\n        }\n    };\n    window.addEventListener(\"storage\", listener);\n    return listener;\n}\nfunction removeStorageEventListener(listener) {\n    window.removeEventListener(\"storage\", listener);\n}\nfunction create$2(channelName, options) {\n    options = fillOptionsWithDefaults(options);\n    if (!canBeUsed$2()) {\n        throw new Error(\"BroadcastChannel: localstorage cannot be used\");\n    }\n    const uuid = randomToken();\n    /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */ const eMIs = new oblivious_set__WEBPACK_IMPORTED_MODULE_4__.ObliviousSet(options.localstorage.removeTimeout);\n    const state = {\n        channelName,\n        uuid,\n        time: microSeconds$5(),\n        eMIs\n    };\n    state.listener = addStorageEventListener(channelName, (msgObj)=>{\n        if (!state.messagesCallback) return; // no listener\n        if (msgObj.uuid === uuid) return; // own message\n        if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n        if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n        eMIs.add(msgObj.token);\n        state.messagesCallback(msgObj.data);\n    });\n    return state;\n}\nfunction close$2(channelState) {\n    removeStorageEventListener(channelState.listener);\n}\nfunction onMessage$2(channelState, fn1, time) {\n    channelState.messagesCallbackTime = time;\n    channelState.messagesCallback = fn1;\n}\nfunction canBeUsed$2() {\n    const ls = getLocalStorage();\n    if (!ls) return false;\n    try {\n        const key = \"__broadcastchannel_check\";\n        ls.setItem(key, \"works\");\n        ls.removeItem(key);\n    } catch (e) {\n        // Safari 10 in private mode will not allow write access to local\n        // storage and fail with a QuotaExceededError. See\n        // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n        return false;\n    }\n    return true;\n}\nfunction averageResponseTime$2() {\n    const defaultTime = 120;\n    const userAgent = navigator.userAgent.toLowerCase();\n    if (userAgent.includes(\"safari\") && !userAgent.includes(\"chrome\")) {\n        // safari is much slower so this time is higher\n        return defaultTime * 2;\n    }\n    return defaultTime;\n}\nvar LocalstorageMethod = {\n    getLocalStorage,\n    create: create$2,\n    close: close$2,\n    onMessage: onMessage$2,\n    postMessage: postMessage$2,\n    canBeUsed: canBeUsed$2,\n    type: type$2,\n    averageResponseTime: averageResponseTime$2,\n    microSeconds: microSeconds$2,\n    storageKey: storageKey$1,\n    addStorageEventListener,\n    removeStorageEventListener\n};\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */ const microSeconds$1 = microSeconds$5;\nconst KEY_PREFIX = \"pubkey.broadcastChannel-\";\nconst type$1 = \"server\";\nlet SOCKET_CONN_INSTANCE = null;\n// used to decide to reconnect socket e.g. when socket connection is disconnected unexpectedly\nconst runningChannels = new Set();\nfunction storageKey(channelName) {\n    return KEY_PREFIX + channelName;\n}\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */ function postMessage$1(channelState, messageJson) {\n    return new Promise((res, rej)=>{\n        sleep().then(async ()=>{\n            const key = storageKey(channelState.channelName);\n            const channelEncPrivKey = (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(key, \"utf8\"));\n            const encData = await (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.encryptData)(channelEncPrivKey.toString(\"hex\"), {\n                token: randomToken(),\n                time: Date.now(),\n                data: messageJson,\n                uuid: channelState.uuid\n            });\n            const body = {\n                sameOriginCheck: true,\n                sameIpCheck: true,\n                key: (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.getPublic)(channelEncPrivKey).toString(\"hex\"),\n                data: encData,\n                signature: (await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.sign)(channelEncPrivKey, (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(encData, \"utf8\")))).toString(\"hex\")\n            };\n            if (channelState.timeout) body.timeout = channelState.timeout;\n            return fetch(channelState.serverUrl + \"/channel/set\", {\n                method: \"POST\",\n                body: JSON.stringify(body),\n                headers: {\n                    \"Content-Type\": \"application/json; charset=utf-8\"\n                }\n            }).then(res).catch(rej);\n        });\n    });\n}\nfunction getSocketInstance(serverUrl) {\n    if (SOCKET_CONN_INSTANCE) {\n        return SOCKET_CONN_INSTANCE;\n    }\n    const SOCKET_CONN = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_1__.io)(serverUrl, {\n        transports: [\n            \"websocket\",\n            \"polling\"\n        ],\n        // use WebSocket first, if available\n        withCredentials: true,\n        reconnectionDelayMax: 10000,\n        reconnectionAttempts: 10\n    });\n    SOCKET_CONN.on(\"connect_error\", (err)=>{\n        // revert to classic upgrade\n        SOCKET_CONN.io.opts.transports = [\n            \"polling\",\n            \"websocket\"\n        ];\n        log.error(\"connect error\", err);\n    });\n    SOCKET_CONN.on(\"connect\", async ()=>{\n        const { engine } = SOCKET_CONN.io;\n        log.debug(\"initially connected to\", engine.transport.name); // in most cases, prints \"polling\"\n        engine.once(\"upgrade\", ()=>{\n            // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)\n            log.debug(\"upgraded\", engine.transport.name); // in most cases, prints \"websocket\"\n        });\n        engine.once(\"close\", (reason)=>{\n            // called when the underlying connection is closed\n            log.debug(\"connection closed\", reason);\n        });\n    });\n    SOCKET_CONN.on(\"error\", (err)=>{\n        log.error(\"socket errored\", err);\n        SOCKET_CONN.disconnect();\n    });\n    SOCKET_CONN_INSTANCE = SOCKET_CONN;\n    return SOCKET_CONN;\n}\nfunction setupSocketConnection(serverUrl, channelState, fn1) {\n    const socketConn = getSocketInstance(serverUrl);\n    const key = storageKey(channelState.channelName);\n    const channelEncPrivKey = (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.keccak256)(Buffer.from(key, \"utf8\"));\n    const channelPubKey = (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_2__.getPublic)(channelEncPrivKey).toString(\"hex\");\n    if (socketConn.connected) {\n        socketConn.emit(\"check_auth_status\", channelPubKey, {\n            sameOriginCheck: true,\n            sameIpCheck: true\n        });\n    } else {\n        socketConn.once(\"connect\", ()=>{\n            log.debug(\"connected with socket\");\n            socketConn.emit(\"check_auth_status\", channelPubKey, {\n                sameOriginCheck: true,\n                sameIpCheck: true\n            });\n        });\n    }\n    const reconnect = ()=>{\n        socketConn.once(\"connect\", async ()=>{\n            if (runningChannels.has(channelState.channelName)) {\n                socketConn.emit(\"check_auth_status\", channelPubKey, {\n                    sameOriginCheck: true,\n                    sameIpCheck: true\n                });\n            }\n        });\n    };\n    const visibilityListener = ()=>{\n        // if channel is closed, then remove the listener.\n        if (!socketConn || !runningChannels.has(channelState.channelName)) {\n            document.removeEventListener(\"visibilitychange\", visibilityListener);\n            return;\n        }\n        // if not connected, then wait for connection and ping server for latest msg.\n        if (!socketConn.connected && document.visibilityState === \"visible\") {\n            reconnect();\n        }\n    };\n    const listener = async (ev)=>{\n        try {\n            const decData = await (0,_toruslabs_metadata_helpers__WEBPACK_IMPORTED_MODULE_3__.decryptData)(channelEncPrivKey.toString(\"hex\"), ev);\n            log.info(decData);\n            fn1(decData);\n        } catch (error) {\n            log.error(error);\n        }\n    };\n    socketConn.on(\"disconnect\", ()=>{\n        log.debug(\"socket disconnected\");\n        if (runningChannels.has(channelState.channelName)) {\n            log.error(\"socket disconnected unexpectedly, reconnecting socket\");\n            reconnect();\n        }\n    });\n    socketConn.on(`${channelPubKey}_success`, listener);\n    if (typeof document !== \"undefined\") document.addEventListener(\"visibilitychange\", visibilityListener);\n    return socketConn;\n}\nfunction create$1(channelName, options) {\n    options = fillOptionsWithDefaults(options);\n    const uuid = randomToken();\n    /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */ const eMIs = new oblivious_set__WEBPACK_IMPORTED_MODULE_4__.ObliviousSet(options.server.removeTimeout);\n    const state = {\n        channelName,\n        uuid,\n        eMIs,\n        // emittedMessagesIds\n        serverUrl: options.server.url,\n        time: microSeconds$5()\n    };\n    if (options.server.timeout) state.timeout = options.server.timeout;\n    setupSocketConnection(options.server.url, state, (msgObj)=>{\n        if (!state.messagesCallback) return; // no listener\n        if (msgObj.uuid === state.uuid) return; // own message\n        if (!msgObj.token || state.eMIs.has(msgObj.token)) return; // already emitted\n        // if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n        state.eMIs.add(msgObj.token);\n        state.messagesCallback(msgObj.data);\n    });\n    runningChannels.add(channelName);\n    return state;\n}\nfunction close$1(channelState) {\n    runningChannels.delete(channelState.channelName);\n// give 2 sec for all msgs which are in transit to be consumed\n// by receiver.\n// window.setTimeout(() => {\n//     removeStorageEventListener(channelState);\n//     SOCKET_CONN_INSTANCE = null;\n// }, 1000);\n}\nfunction onMessage$1(channelState, fn1, time) {\n    channelState.messagesCallbackTime = time;\n    channelState.messagesCallback = fn1;\n}\nfunction canBeUsed$1() {\n    return true;\n}\nfunction averageResponseTime$1() {\n    const defaultTime = 500;\n    // TODO: Maybe increase it based on operation\n    return defaultTime;\n}\nvar ServerMethod = {\n    create: create$1,\n    close: close$1,\n    onMessage: onMessage$1,\n    postMessage: postMessage$1,\n    canBeUsed: canBeUsed$1,\n    type: type$1,\n    averageResponseTime: averageResponseTime$1,\n    microSeconds: microSeconds$1\n};\nconst microSeconds = microSeconds$5;\nconst type = \"simulate\";\nconst SIMULATE_CHANNELS = new Set();\nconst SIMULATE_DELAY_TIME = 5;\nfunction create(channelName) {\n    const state = {\n        time: microSeconds$5(),\n        name: channelName,\n        messagesCallback: null\n    };\n    SIMULATE_CHANNELS.add(state);\n    return state;\n}\nfunction close(channelState) {\n    SIMULATE_CHANNELS.delete(channelState);\n}\nfunction postMessage(channelState, messageJson) {\n    return new Promise((res)=>setTimeout(()=>{\n            const channelArray = Array.from(SIMULATE_CHANNELS);\n            channelArray.forEach((channel)=>{\n                if (channel.name === channelState.name && // has same name\n                channel !== channelState && // not own channel\n                !!channel.messagesCallback && // has subscribers\n                channel.time < messageJson.time // channel not created after postMessage() call\n                ) {\n                    channel.messagesCallback(messageJson);\n                }\n            });\n            res();\n        }, SIMULATE_DELAY_TIME));\n}\nfunction onMessage(channelState, fn1) {\n    channelState.messagesCallback = fn1;\n}\nfunction canBeUsed() {\n    return true;\n}\nfunction averageResponseTime() {\n    return SIMULATE_DELAY_TIME;\n}\nvar SimulateMethod = {\n    create,\n    close,\n    onMessage,\n    postMessage,\n    canBeUsed,\n    type,\n    averageResponseTime,\n    microSeconds\n};\n// order is important\nconst METHODS = [\n    NativeMethod,\n    // fastest\n    IndexeDbMethod,\n    LocalstorageMethod,\n    ServerMethod\n];\nfunction chooseMethod(options) {\n    let chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);\n    // directly chosen\n    if (options.type) {\n        if (options.type === \"simulate\") {\n            // only use simulate-method if directly chosen\n            return SimulateMethod;\n        }\n        const ret = chooseMethods.find((m)=>m.type === options.type);\n        if (!ret) throw new Error(\"method-type \" + options.type + \" not found\");\n        else return ret;\n    }\n    /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage is been chosen\n   */ if (!options.webWorkerSupport) {\n        chooseMethods = chooseMethods.filter((m)=>m.type !== \"idb\");\n    }\n    const useMethod = chooseMethods.find((method)=>method.canBeUsed(options));\n    if (!useMethod) throw new Error(`No useable method found in ${JSON.stringify(METHODS.map((m)=>m.type))}`);\n    else return useMethod;\n}\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */ const OPEN_BROADCAST_CHANNELS = new Set();\nlet lastId = 0;\nconst BroadcastChannel$1 = function(name, options) {\n    // identifier of the channel to debug stuff\n    this.id = lastId++;\n    OPEN_BROADCAST_CHANNELS.add(this);\n    this.name = name;\n    if (ENFORCED_OPTIONS) {\n        options = ENFORCED_OPTIONS;\n    }\n    this.options = fillOptionsWithDefaults(options);\n    this.method = chooseMethod(this.options);\n    // isListening\n    this._iL = false;\n    /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */ this._onML = null;\n    /**\n   * _addEventListeners\n   */ this._addEL = {\n        message: [],\n        internal: []\n    };\n    /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */ this._uMP = new Set();\n    /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */ this._befC = [];\n    /**\n   * _preparePromise\n   */ this._prepP = null;\n    _prepareChannel(this);\n};\n// STATICS\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */ BroadcastChannel$1._pubkey = true;\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */ let ENFORCED_OPTIONS;\nfunction enforceOptions(options) {\n    ENFORCED_OPTIONS = options;\n}\n// PROTOTYPE\nBroadcastChannel$1.prototype = {\n    postMessage (msg) {\n        if (this.closed) {\n            throw new Error(\"BroadcastChannel.postMessage(): \" + \"Cannot post message after channel has closed \" + /**\n       * In the past when this error appeared, it was realy hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */ JSON.stringify(msg));\n        }\n        return _post(this, \"message\", msg);\n    },\n    postInternal (msg) {\n        return _post(this, \"internal\", msg);\n    },\n    set onmessage (fn){\n        const time = this.method.microSeconds();\n        const listenObj = {\n            time,\n            fn\n        };\n        _removeListenerObject(this, \"message\", this._onML);\n        if (fn && typeof fn === \"function\") {\n            this._onML = listenObj;\n            _addListenerObject(this, \"message\", listenObj);\n        } else {\n            this._onML = null;\n        }\n    },\n    addEventListener (type, fn1) {\n        const time = this.method.microSeconds();\n        const listenObj = {\n            time,\n            fn: fn1\n        };\n        _addListenerObject(this, type, listenObj);\n    },\n    removeEventListener (type, fn1) {\n        const obj = this._addEL[type].find((obj)=>obj.fn === fn1);\n        _removeListenerObject(this, type, obj);\n    },\n    close () {\n        if (this.closed) {\n            return;\n        }\n        OPEN_BROADCAST_CHANNELS.delete(this);\n        this.closed = true;\n        const awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;\n        this._onML = null;\n        this._addEL.message = [];\n        return awaitPrepare// wait until all current sending are processed\n        .then(()=>Promise.all(Array.from(this._uMP)))// run before-close hooks\n        .then(()=>Promise.all(this._befC.map((fn1)=>fn1())))// close the channel\n        .then(()=>this.method.close(this._state));\n    },\n    get type () {\n        return this.method.type;\n    },\n    get isClosed () {\n        return this.closed;\n    }\n};\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */ function _post(broadcastChannel, type, msg) {\n    const time = broadcastChannel.method.microSeconds();\n    const msgObj = {\n        time,\n        type,\n        data: msg\n    };\n    const awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;\n    return awaitPrepare.then(()=>{\n        const sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n        // add/remove to unsend messages list\n        broadcastChannel._uMP.add(sendPromise);\n        sendPromise.catch().then(()=>broadcastChannel._uMP.delete(sendPromise));\n        return sendPromise;\n    });\n}\nfunction _prepareChannel(channel) {\n    const maybePromise = channel.method.create(channel.name, channel.options);\n    if (isPromise(maybePromise)) {\n        channel._prepP = maybePromise;\n        maybePromise.then((s)=>{\n            // used in tests to simulate slow runtime\n            /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/ channel._state = s;\n        });\n    } else {\n        channel._state = maybePromise;\n    }\n}\nfunction _hasMessageListeners(channel) {\n    if (channel._addEL.message.length > 0) return true;\n    if (channel._addEL.internal.length > 0) return true;\n    return false;\n}\nfunction _addListenerObject(channel, type, obj) {\n    channel._addEL[type].push(obj);\n    _startListening(channel);\n}\nfunction _removeListenerObject(channel, type, obj) {\n    channel._addEL[type] = channel._addEL[type].filter((o)=>o !== obj);\n    _stopListening(channel);\n}\nfunction _startListening(channel) {\n    if (!channel._iL && _hasMessageListeners(channel)) {\n        // someone is listening, start subscribing\n        const listenerFn = (msgObj)=>{\n            channel._addEL[msgObj.type].forEach((listenerObject)=>{\n                /**\n         * Getting the current time in JavaScript has no good precision.\n         * So instead of only listening to events that happend 'after' the listener\n         * was added, we also listen to events that happended 100ms before it.\n         * This ensures that when another process, like a WebWorker, sends events\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\n         */ // const hundredMsInMicro = 100 * 1000;\n                // const minMessageTime = listenerObject.time - hundredMsInMicro;\n                if (msgObj.time >= listenerObject.time) {\n                    listenerObject.fn(msgObj.data);\n                } else if (channel.method.type === \"server\") {\n                    // server msg might lag based on connection.\n                    listenerObject.fn(msgObj.data);\n                }\n            });\n        };\n        const time = channel.method.microSeconds();\n        if (channel._prepP) {\n            channel._prepP.then(()=>{\n                channel._iL = true;\n                channel.method.onMessage(channel._state, listenerFn, time);\n            });\n        } else {\n            channel._iL = true;\n            channel.method.onMessage(channel._state, listenerFn, time);\n        }\n    }\n}\nfunction _stopListening(channel) {\n    if (channel._iL && !_hasMessageListeners(channel)) {\n        // noone is listening, stop subscribing\n        channel._iL = false;\n        const time = channel.method.microSeconds();\n        channel.method.onMessage(channel._state, null, time);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9icm9hZGNhc3QtY2hhbm5lbC9kaXN0L2Jyb2FkY2FzdENoYW5uZWwuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ2E7QUFDUDtBQUNnQjtBQUM0QjtBQUVsRiwrQkFBK0I7QUFFL0I7O0NBRUMsR0FDRCxTQUFTUSxVQUFVQyxHQUFHO0lBQ3BCLElBQUlBLE9BQU8sT0FBT0EsSUFBSUMsSUFBSSxLQUFLLFlBQVk7UUFDekMsT0FBTztJQUNULE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRjtBQUNBQyxRQUFRQyxPQUFPLENBQUM7QUFDaEJELFFBQVFDLE9BQU8sQ0FBQztBQUNoQixNQUFNQyx3QkFBd0JGLFFBQVFDLE9BQU87QUFDN0MsU0FBU0UsTUFBTUMsSUFBSSxFQUFFQyxXQUFXO0lBQzlCLElBQUksQ0FBQ0QsTUFBTUEsT0FBTztJQUNsQixPQUFPLElBQUlKLFFBQVFNLENBQUFBLE1BQU9DLFdBQVcsSUFBTUQsSUFBSUQsY0FBY0Q7QUFDL0Q7QUFDQSxTQUFTSSxVQUFVQyxHQUFHLEVBQUVDLEdBQUc7SUFDekIsT0FBT0MsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQU1ILENBQUFBLE1BQU1ELE1BQU0sS0FBS0E7QUFDdEQ7QUFFQTs7Q0FFQyxHQUNELFNBQVNLO0lBQ1AsT0FBT0gsS0FBS0UsTUFBTSxHQUFHRSxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDO0FBQzlDO0FBQ0EsSUFBSUMsU0FBUztBQUViOzs7Ozs7Q0FNQyxHQUNELFNBQVNDO0lBQ1AsSUFBSUMsTUFBTUMsS0FBS0MsR0FBRyxLQUFLLE1BQU0sK0JBQStCO0lBQzVELElBQUlGLE9BQU9GLFFBQVE7UUFDakJFLE1BQU1GLFNBQVM7SUFDakI7SUFDQUEsU0FBU0U7SUFDVCxPQUFPQTtBQUNUO0FBRUEsa0ZBQWtGO0FBQ2xGLGlEQUFpRDtBQUNqRCw4RUFBOEU7QUFDOUUsbUZBQW1GO0FBQ25G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Ozs7Ozs7OztTQVFDLEdBQ0QsdUNBQXVDO2dCQUN2QyxpRUFBaUU7Z0JBRWpFLElBQUl0SixPQUFPckosSUFBSSxJQUFJMlMsZUFBZTNTLElBQUksRUFBRTtvQkFDdEMyUyxlQUFlalEsRUFBRSxDQUFDMkcsT0FBT3JILElBQUk7Z0JBQy9CLE9BQU8sSUFBSWlPLFFBQVF2QyxNQUFNLENBQUN2SyxJQUFJLEtBQUssVUFBVTtvQkFDM0MsNENBQTRDO29CQUM1Q3dQLGVBQWVqUSxFQUFFLENBQUMyRyxPQUFPckgsSUFBSTtnQkFDL0I7WUFDRjtRQUNGO1FBQ0EsTUFBTWhDLE9BQU9pUSxRQUFRdkMsTUFBTSxDQUFDckssWUFBWTtRQUN4QyxJQUFJNE0sUUFBUXFCLE1BQU0sRUFBRTtZQUNsQnJCLFFBQVFxQixNQUFNLENBQUMzUixJQUFJLENBQUM7Z0JBQ2xCc1EsUUFBUWMsR0FBRyxHQUFHO2dCQUNkZCxRQUFRdkMsTUFBTSxDQUFDekssU0FBUyxDQUFDZ04sUUFBUStCLE1BQU0sRUFBRVUsWUFBWTFTO1lBQ3ZEO1FBQ0YsT0FBTztZQUNMaVEsUUFBUWMsR0FBRyxHQUFHO1lBQ2RkLFFBQVF2QyxNQUFNLENBQUN6SyxTQUFTLENBQUNnTixRQUFRK0IsTUFBTSxFQUFFVSxZQUFZMVM7UUFDdkQ7SUFDRjtBQUNGO0FBQ0EsU0FBU3lTLGVBQWV4QyxPQUFPO0lBQzdCLElBQUlBLFFBQVFjLEdBQUcsSUFBSSxDQUFDdUIscUJBQXFCckMsVUFBVTtRQUNqRCx1Q0FBdUM7UUFDdkNBLFFBQVFjLEdBQUcsR0FBRztRQUNkLE1BQU0vUSxPQUFPaVEsUUFBUXZDLE1BQU0sQ0FBQ3JLLFlBQVk7UUFDeEM0TSxRQUFRdkMsTUFBTSxDQUFDekssU0FBUyxDQUFDZ04sUUFBUStCLE1BQU0sRUFBRSxNQUFNaFM7SUFDakQ7QUFDRjtBQUVrTiIsInNvdXJjZXMiOlsid2VicGFjazovL3NvbC1wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvYnJvYWRjYXN0LWNoYW5uZWwvZGlzdC9icm9hZGNhc3RDaGFubmVsLmVzbS5qcz85NzMzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBsb2dsZXZlbCBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgeyBPYmxpdmlvdXNTZXQgfSBmcm9tICdvYmxpdmlvdXMtc2V0JztcbmltcG9ydCB7IGlvIH0gZnJvbSAnc29ja2V0LmlvLWNsaWVudCc7XG5pbXBvcnQgeyBnZXRQdWJsaWMsIHNpZ24gfSBmcm9tICdAdG9ydXNsYWJzL2VjY3J5cHRvJztcbmltcG9ydCB7IGtlY2NhazI1NiwgZW5jcnlwdERhdGEsIGRlY3J5cHREYXRhIH0gZnJvbSAnQHRvcnVzbGFicy9tZXRhZGF0YS1oZWxwZXJzJztcblxuLy8gaW1wb3J0IEJvd3NlciBmcm9tICdib3dzZXInO1xuXG4vKipcbiAqIHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gIGlmIChvYmogJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5Qcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuY29uc3QgUFJPTUlTRV9SRVNPTFZFRF9WT0lEID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5mdW5jdGlvbiBzbGVlcCh0aW1lLCByZXNvbHZlV2l0aCkge1xuICBpZiAoIXRpbWUpIHRpbWUgPSAwO1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQoKCkgPT4gcmVzKHJlc29sdmVXaXRoKSwgdGltZSkpO1xufVxuZnVuY3Rpb24gcmFuZG9tSW50KG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW4pO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84MDg0MjQ4XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbVRva2VuKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpO1xufVxubGV0IGxhc3RNcyA9IDA7XG5cbi8qKlxuICogcmV0dXJucyB0aGUgY3VycmVudCB0aW1lIGluIG1pY3JvLXNlY29uZHMsXG4gKiBXQVJOSU5HOiBUaGlzIGlzIGEgcHNldWRvLWZ1bmN0aW9uXG4gKiBQZXJmb3JtYW5jZS5ub3cgaXMgbm90IHJlbGlhYmxlIGluIHdlYndvcmtlcnMsIHNvIHdlIGp1c3QgbWFrZSBzdXJlIHRvIG5ldmVyIHJldHVybiB0aGUgc2FtZSB0aW1lLlxuICogVGhpcyBpcyBlbm91Z2ggaW4gYnJvd3NlcnMsIGFuZCB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IGJlIHVzZWQgaW4gbm9kZWpzLlxuICogVGhlIG1haW4gcmVhc29uIGZvciB0aGlzIGhhY2sgaXMgdG8gZW5zdXJlIHRoYXQgQnJvYWRjYXN0Q2hhbm5lbCBiZWhhdmVzIGVxdWFsIHRvIHByb2R1Y3Rpb24gd2hlbiBpdCBpcyB1c2VkIGluIGZhc3QtcnVubmluZyB1bml0IHRlc3RzLlxuICovXG5mdW5jdGlvbiBtaWNyb1NlY29uZHMkNSgpIHtcbiAgbGV0IHJldCA9IERhdGUubm93KCkgKiAxMDAwOyAvLyBtaWxsaXNlY29uZHMgdG8gbWljcm9zZWNvbmRzXG4gIGlmIChyZXQgPD0gbGFzdE1zKSB7XG4gICAgcmV0ID0gbGFzdE1zICsgMTtcbiAgfVxuICBsYXN0TXMgPSByZXQ7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIHRoZSBwcm9ibGVtIGlzIG9ubHkgaW4gaWZyYW1lcy4gd2Ugc2hvdWxkIGRlZmF1bHQgdG8gc2VydmVyIGluIGNhc2Ugb2YgaWZyYW1lcy5cbi8vIHN0b3JhZ2Ugc2NvcGluZyBpcyBwcmVzZW50IGluIGFsbCBicm93c2VycyBub3dcbi8vIFNhZmFyaSBhbmQgb3RoZXIgYnJvd3NlcnMgc3VwcG9ydCBuYXRpdmUgQnJvYWRjYXN0IGNoYW5uZWwgbm93LiBJdCdzIGluIExTLlxuLy8gdGVzdCBoZXJlOiBodHRwczovL3B1YmtleS5naXRodWIuaW8vYnJvYWRjYXN0LWNoYW5uZWwvZTJlLmh0bWw/bWV0aG9kVHlwZT1uYXRpdmVcbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vYnJvYWRjYXN0Y2hhbm5lbFxuLy8gZXhwb3J0IGZ1bmN0aW9uIGFyZTNQQ1N1cHBvcnRlZCgpIHtcbi8vICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcbi8vICAgICBjb25zdCBicm93c2VySW5mbyA9IEJvd3Nlci5wYXJzZShuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vICAgICBsb2cuaW5mbyhKU09OLnN0cmluZ2lmeShicm93c2VySW5mbyksICdjdXJyZW50IGJyb3dzZXIgaW5mbycpO1xuXG4vLyAgICAgbGV0IHRoaXJkUGFydHlDb29raWVTdXBwb3J0ID0gdHJ1ZTtcbi8vICAgICAvLyBicmF2ZVxuLy8gICAgIGlmIChuYXZpZ2F0b3IuYnJhdmUpIHtcbi8vICAgICAgICAgdGhpcmRQYXJ0eUNvb2tpZVN1cHBvcnQgPSBmYWxzZTtcbi8vICAgICB9XG4vLyAgICAgLy8gQWxsIHdlYmtpdCAmIGdlY2tvIGVuZ2luZSBpbnN0YW5jZXMgdXNlIGl0cCAoaW50ZWxsaWdlbnQgdHJhY2tpbmcgcHJldmVudGlvbiAtXG4vLyAgICAgLy8gaHR0cHM6Ly93ZWJraXQub3JnL3RyYWNraW5nLXByZXZlbnRpb24vI2ludGVsbGlnZW50LXRyYWNraW5nLXByZXZlbnRpb24taXRwKVxuLy8gICAgIGlmIChicm93c2VySW5mby5lbmdpbmUubmFtZSA9PT0gQm93c2VyLkVOR0lORV9NQVAuV2ViS2l0IHx8IGJyb3dzZXJJbmZvLmVuZ2luZS5uYW1lID09PSBCb3dzZXIuRU5HSU5FX01BUC5HZWNrbykge1xuLy8gICAgICAgICB0aGlyZFBhcnR5Q29va2llU3VwcG9ydCA9IGZhbHNlO1xuLy8gICAgIH1cblxuLy8gICAgIHJldHVybiB0aGlyZFBhcnR5Q29va2llU3VwcG9ydDtcbi8vIH1cblxuY29uc3QgbG9nID0gbG9nbGV2ZWwuZ2V0TG9nZ2VyKCdicm9hZGNhc3QtY2hhbm5lbCcpO1xubG9nLnNldExldmVsKCdlcnJvcicpO1xuXG5jb25zdCBtaWNyb1NlY29uZHMkNCA9IG1pY3JvU2Vjb25kcyQ1O1xuY29uc3QgdHlwZSQ0ID0gJ25hdGl2ZSc7XG5mdW5jdGlvbiBjcmVhdGUkNChjaGFubmVsTmFtZSkge1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICB0aW1lOiBtaWNyb1NlY29uZHMkNSgpLFxuICAgIG1lc3NhZ2VzQ2FsbGJhY2s6IG51bGwsXG4gICAgYmM6IG5ldyBCcm9hZGNhc3RDaGFubmVsKGNoYW5uZWxOYW1lKSxcbiAgICBzdWJGbnM6IFtdIC8vIHN1YnNjcmliZXJGdW5jdGlvbnNcbiAgfTtcbiAgc3RhdGUuYmMub25tZXNzYWdlID0gbXNnID0+IHtcbiAgICBpZiAoc3RhdGUubWVzc2FnZXNDYWxsYmFjaykge1xuICAgICAgc3RhdGUubWVzc2FnZXNDYWxsYmFjayhtc2cuZGF0YSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBjbG9zZSQ0KGNoYW5uZWxTdGF0ZSkge1xuICBjaGFubmVsU3RhdGUuYmMuY2xvc2UoKTtcbiAgY2hhbm5lbFN0YXRlLnN1YkZucyA9IFtdO1xufVxuZnVuY3Rpb24gcG9zdE1lc3NhZ2UkNChjaGFubmVsU3RhdGUsIG1lc3NhZ2VKc29uKSB7XG4gIHRyeSB7XG4gICAgY2hhbm5lbFN0YXRlLmJjLnBvc3RNZXNzYWdlKG1lc3NhZ2VKc29uLCBmYWxzZSk7XG4gICAgcmV0dXJuIFBST01JU0VfUkVTT0xWRURfVk9JRDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uTWVzc2FnZSQ0KGNoYW5uZWxTdGF0ZSwgZm4pIHtcbiAgY2hhbm5lbFN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sgPSBmbjtcbn1cbmZ1bmN0aW9uIGNhbkJlVXNlZCQ0KCkge1xuICAvKipcbiAgICogaW4gdGhlIGVsZWN0cm9uLXJlbmRlcmVyLCBpc05vZGUgd2lsbCBiZSB0cnVlIGV2ZW4gaWYgd2UgYXJlIGluIGJyb3dzZXItY29udGV4dFxuICAgKiBzbyB3ZSBhbHNvIGNoZWNrIGlmIHdpbmRvdyBpcyB1bmRlZmluZWRcbiAgICovXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIEJyb2FkY2FzdENoYW5uZWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoQnJvYWRjYXN0Q2hhbm5lbC5fcHVia2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb2FkY2FzdENoYW5uZWw6IERvIG5vdCBvdmVyd3JpdGUgd2luZG93LkJyb2FkY2FzdENoYW5uZWwgd2l0aCB0aGlzIG1vZHVsZSwgdGhpcyBpcyBub3QgYSBwb2x5ZmlsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGF2ZXJhZ2VSZXNwb25zZVRpbWUkNCgpIHtcbiAgcmV0dXJuIDE1MDtcbn1cbnZhciBOYXRpdmVNZXRob2QgPSB7XG4gIGNyZWF0ZTogY3JlYXRlJDQsXG4gIGNsb3NlOiBjbG9zZSQ0LFxuICBvbk1lc3NhZ2U6IG9uTWVzc2FnZSQ0LFxuICBwb3N0TWVzc2FnZTogcG9zdE1lc3NhZ2UkNCxcbiAgY2FuQmVVc2VkOiBjYW5CZVVzZWQkNCxcbiAgdHlwZTogdHlwZSQ0LFxuICBhdmVyYWdlUmVzcG9uc2VUaW1lOiBhdmVyYWdlUmVzcG9uc2VUaW1lJDQsXG4gIG1pY3JvU2Vjb25kczogbWljcm9TZWNvbmRzJDRcbn07XG5cbmZ1bmN0aW9uIGZpbGxPcHRpb25zV2l0aERlZmF1bHRzKCkge1xuICBsZXQgb3JpZ2luYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgY29uc3Qgb3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3JpZ2luYWxPcHRpb25zKSk7XG5cbiAgLy8gbWFpblxuICBpZiAodHlwZW9mIG9wdGlvbnMud2ViV29ya2VyU3VwcG9ydCA9PT0gJ3VuZGVmaW5lZCcpIG9wdGlvbnMud2ViV29ya2VyU3VwcG9ydCA9IHRydWU7XG5cbiAgLy8gaW5kZXhlZC1kYlxuICBpZiAoIW9wdGlvbnMuaWRiKSBvcHRpb25zLmlkYiA9IHt9O1xuICAvLyAgYWZ0ZXIgdGhpcyB0aW1lIHRoZSBtZXNzYWdlcyBnZXQgZGVsZXRlZFxuICBpZiAoIW9wdGlvbnMuaWRiLnR0bCkgb3B0aW9ucy5pZGIudHRsID0gMTAwMCAqIDQ1O1xuICBpZiAoIW9wdGlvbnMuaWRiLmZhbGxiYWNrSW50ZXJ2YWwpIG9wdGlvbnMuaWRiLmZhbGxiYWNrSW50ZXJ2YWwgPSAxNTA7XG4gIC8vICBoYW5kbGVzIGFicnVwdCBkYiBvbmNsb3NlIGV2ZW50cy5cbiAgaWYgKG9yaWdpbmFsT3B0aW9ucy5pZGIgJiYgdHlwZW9mIG9yaWdpbmFsT3B0aW9ucy5pZGIub25jbG9zZSA9PT0gJ2Z1bmN0aW9uJykgb3B0aW9ucy5pZGIub25jbG9zZSA9IG9yaWdpbmFsT3B0aW9ucy5pZGIub25jbG9zZTtcblxuICAvLyBsb2NhbHN0b3JhZ2VcbiAgaWYgKCFvcHRpb25zLmxvY2Fsc3RvcmFnZSkgb3B0aW9ucy5sb2NhbHN0b3JhZ2UgPSB7fTtcbiAgaWYgKCFvcHRpb25zLmxvY2Fsc3RvcmFnZS5yZW1vdmVUaW1lb3V0KSBvcHRpb25zLmxvY2Fsc3RvcmFnZS5yZW1vdmVUaW1lb3V0ID0gMTAwMCAqIDYwO1xuXG4gIC8vIHNlcnZlclxuICBpZiAoIW9wdGlvbnMuc2VydmVyKSBvcHRpb25zLnNlcnZlciA9IHt9O1xuICBpZiAoIW9wdGlvbnMuc2VydmVyLnVybCkgb3B0aW9ucy5zZXJ2ZXIudXJsID0gJ2h0dHBzOi8vc2Vzc2lvbi53ZWIzYXV0aC5pbyc7XG4gIGlmICghb3B0aW9ucy5zZXJ2ZXIucmVtb3ZlVGltZW91dCkgb3B0aW9ucy5zZXJ2ZXIucmVtb3ZlVGltZW91dCA9IDEwMDAgKiA2MCAqIDU7IC8vIDUgbWludXRlc1xuXG4gIC8vIGN1c3RvbSBtZXRob2RzXG4gIGlmIChvcmlnaW5hbE9wdGlvbnMubWV0aG9kcykgb3B0aW9ucy5tZXRob2RzID0gb3JpZ2luYWxPcHRpb25zLm1ldGhvZHM7XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIHRoaXMgbWV0aG9kIHVzZXMgaW5kZXhlZGRiIHRvIHN0b3JlIHRoZSBtZXNzYWdlc1xuICogVGhlcmUgaXMgY3VycmVudGx5IG5vIG9ic2VydmVyQVBJIGZvciBpZGJcbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvSW5kZXhlZERCL2lzc3Vlcy81MVxuICpcbiAqIFdoZW4gd29ya2luZyBvbiB0aGlzLCBlbnN1cmUgdG8gdXNlIHRoZXNlIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiBAbGluayBodHRwczovL3J4ZGIuaW5mby9zbG93LWluZGV4ZWRkYi5odG1sXG4gKi9cblxuY29uc3QgbWljcm9TZWNvbmRzJDMgPSBtaWNyb1NlY29uZHMkNTtcbmNvbnN0IERCX1BSRUZJWCA9ICdwdWJrZXkuYnJvYWRjYXN0LWNoYW5uZWwtMC0nO1xuY29uc3QgT0JKRUNUX1NUT1JFX0lEID0gJ21lc3NhZ2VzJztcblxuLyoqXG4gKiBVc2UgcmVsYXhlZCBkdXJhYmlsaXR5IGZvciBmYXN0ZXIgcGVyZm9ybWFuY2Ugb24gYWxsIHRyYW5zYWN0aW9ucy5cbiAqIEBsaW5rIGh0dHBzOi8vbm9sYW5sYXdzb24uY29tLzIwMjEvMDgvMjIvc3BlZWRpbmctdXAtaW5kZXhlZGRiLXJlYWRzLWFuZC13cml0ZXMvXG4gKi9cbmNvbnN0IFRSQU5TQUNUSU9OX1NFVFRJTkdTID0ge1xuICBkdXJhYmlsaXR5OiAncmVsYXhlZCdcbn07XG5jb25zdCB0eXBlJDMgPSAnaWRiJztcbmZ1bmN0aW9uIGdldElkYigpIHtcbiAgaWYgKHR5cGVvZiBpbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gaW5kZXhlZERCO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5tb3pJbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2luZG93Lm1vekluZGV4ZWREQjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy53ZWJraXRJbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2luZG93LndlYmtpdEluZGV4ZWREQjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5tc0luZGV4ZWREQiAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB3aW5kb3cubXNJbmRleGVkREI7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIElmIHBvc3NpYmxlLCB3ZSBzaG91bGQgZXhwbGljaXRseSBjb21taXQgSW5kZXhlZERCIHRyYW5zYWN0aW9uc1xuICogZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbiAqIEBsaW5rIGh0dHBzOi8vbm9sYW5sYXdzb24uY29tLzIwMjEvMDgvMjIvc3BlZWRpbmctdXAtaW5kZXhlZGRiLXJlYWRzLWFuZC13cml0ZXMvXG4gKi9cbmZ1bmN0aW9uIGNvbW1pdEluZGV4ZWREQlRyYW5zYWN0aW9uKHR4KSB7XG4gIGlmICh0eC5jb21taXQpIHtcbiAgICB0eC5jb21taXQoKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRGF0YWJhc2UoY2hhbm5lbE5hbWUpIHtcbiAgY29uc3QgSW5kZXhlZERCID0gZ2V0SWRiKCk7XG5cbiAgLy8gY3JlYXRlIHRhYmxlXG4gIGNvbnN0IGRiTmFtZSA9IERCX1BSRUZJWCArIGNoYW5uZWxOYW1lO1xuXG4gIC8qKlxuICAgKiBBbGwgSW5kZXhlZERCIGRhdGFiYXNlcyBhcmUgb3BlbmVkIHdpdGhvdXQgdmVyc2lvblxuICAgKiBiZWNhdXNlIGl0IGlzIGEgYml0IGZhc3RlciwgZXNwZWNpYWxseSBvbiBmaXJlZm94XG4gICAqIEBsaW5rIGh0dHA6Ly9ucGFyYXNodXJhbS5jb20vSW5kZXhlZERCL3BlcmYvI09wZW4lMjBEYXRhYmFzZSUyMHdpdGglMjB2ZXJzaW9uXG4gICAqL1xuICBjb25zdCBvcGVuUmVxdWVzdCA9IEluZGV4ZWREQi5vcGVuKGRiTmFtZSk7XG4gIG9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGV2ID0+IHtcbiAgICBjb25zdCBkYiA9IGV2LnRhcmdldC5yZXN1bHQ7XG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lELCB7XG4gICAgICBrZXlQYXRoOiAnaWQnLFxuICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxuICAgIH0pO1xuICB9O1xuICBjb25zdCBkYlByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICBvcGVuUmVxdWVzdC5vbmVycm9yID0gZXYgPT4gcmVqKGV2KTtcbiAgICBvcGVuUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICByZXMob3BlblJlcXVlc3QucmVzdWx0KTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGRiUHJvbWlzZTtcbn1cblxuLyoqXG4gKiB3cml0ZXMgdGhlIG5ldyBtZXNzYWdlIHRvIHRoZSBkYXRhYmFzZVxuICogc28gb3RoZXIgcmVhZGVycyBjYW4gZmluZCBpdFxuICovXG5mdW5jdGlvbiB3cml0ZU1lc3NhZ2UoZGIsIHJlYWRlclV1aWQsIG1lc3NhZ2VKc29uKSB7XG4gIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpO1xuICBjb25zdCB3cml0ZU9iamVjdCA9IHtcbiAgICB1dWlkOiByZWFkZXJVdWlkLFxuICAgIHRpbWUsXG4gICAgZGF0YTogbWVzc2FnZUpzb25cbiAgfTtcbiAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihbT0JKRUNUX1NUT1JFX0lEXSwgJ3JlYWR3cml0ZScsIFRSQU5TQUNUSU9OX1NFVFRJTkdTKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHR4Lm9uY29tcGxldGUgPSAoKSA9PiByZXMoKTtcbiAgICB0eC5vbmVycm9yID0gZXYgPT4gcmVqKGV2KTtcbiAgICBjb25zdCBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9JRCk7XG4gICAgb2JqZWN0U3RvcmUuYWRkKHdyaXRlT2JqZWN0KTtcbiAgICBjb21taXRJbmRleGVkREJUcmFuc2FjdGlvbih0eCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QWxsTWVzc2FnZXMoZGIpIHtcbiAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfSUQsICdyZWFkb25seScsIFRSQU5TQUNUSU9OX1NFVFRJTkdTKTtcbiAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfSUQpO1xuICBjb25zdCByZXQgPSBbXTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlcyA9PiB7XG4gICAgb2JqZWN0U3RvcmUub3BlbkN1cnNvcigpLm9uc3VjY2VzcyA9IGV2ID0+IHtcbiAgICAgIGNvbnN0IGN1cnNvciA9IGV2LnRhcmdldC5yZXN1bHQ7XG4gICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgIHJldC5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIC8vYWxlcnQoXCJOYW1lIGZvciBTU04gXCIgKyBjdXJzb3Iua2V5ICsgXCIgaXMgXCIgKyBjdXJzb3IudmFsdWUubmFtZSk7XG4gICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0SW5kZXhlZERCVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICByZXMocmV0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VzSGlnaGVyVGhhbihkYiwgbGFzdEN1cnNvcklkKSB7XG4gIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oT0JKRUNUX1NUT1JFX0lELCAncmVhZG9ubHknLCBUUkFOU0FDVElPTl9TRVRUSU5HUyk7XG4gIGNvbnN0IG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKTtcbiAgY29uc3QgcmV0ID0gW107XG4gIGxldCBrZXlSYW5nZVZhbHVlID0gSURCS2V5UmFuZ2UuYm91bmQobGFzdEN1cnNvcklkICsgMSwgSW5maW5pdHkpO1xuXG4gIC8qKlxuICAgKiBPcHRpbWl6YXRpb24gc2hvcnRjdXQsXG4gICAqIGlmIGdldEFsbCgpIGNhbiBiZSB1c2VkLCBkbyBub3QgdXNlIGEgY3Vyc29yLlxuICAgKiBAbGluayBodHRwczovL3J4ZGIuaW5mby9zbG93LWluZGV4ZWRkYi5odG1sXG4gICAqL1xuICBpZiAob2JqZWN0U3RvcmUuZ2V0QWxsKSB7XG4gICAgY29uc3QgZ2V0QWxsUmVxdWVzdCA9IG9iamVjdFN0b3JlLmdldEFsbChrZXlSYW5nZVZhbHVlKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICBnZXRBbGxSZXF1ZXN0Lm9uZXJyb3IgPSBlcnIgPT4gcmVqKGVycik7XG4gICAgICBnZXRBbGxSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJlcyhlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBvcGVuQ3Vyc29yKCkge1xuICAgIC8vIE9jY2FzaW9uYWxseSBTYWZhcmkgd2lsbCBmYWlsIG9uIElEQktleVJhbmdlLmJvdW5kLCB0aGlzXG4gICAgLy8gY2F0Y2hlcyB0aGF0IGVycm9yLCBoYXZpbmcgaXQgb3BlbiB0aGUgY3Vyc29yIHRvIHRoZSBmaXJzdFxuICAgIC8vIGl0ZW0uIFdoZW4gaXQgZ2V0cyBkYXRhIGl0IHdpbGwgYWR2YW5jZSB0byB0aGUgZGVzaXJlZCBrZXkuXG4gICAgdHJ5IHtcbiAgICAgIGtleVJhbmdlVmFsdWUgPSBJREJLZXlSYW5nZS5ib3VuZChsYXN0Q3Vyc29ySWQgKyAxLCBJbmZpbml0eSk7XG4gICAgICByZXR1cm4gb2JqZWN0U3RvcmUub3BlbkN1cnNvcihrZXlSYW5nZVZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0U3RvcmUub3BlbkN1cnNvcigpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgY29uc3Qgb3BlbkN1cnNvclJlcXVlc3QgPSBvcGVuQ3Vyc29yKCk7XG4gICAgb3BlbkN1cnNvclJlcXVlc3Qub25lcnJvciA9IGVyciA9PiByZWooZXJyKTtcbiAgICBvcGVuQ3Vyc29yUmVxdWVzdC5vbnN1Y2Nlc3MgPSBldiA9PiB7XG4gICAgICBjb25zdCBjdXJzb3IgPSBldi50YXJnZXQucmVzdWx0O1xuICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICBpZiAoY3Vyc29yLnZhbHVlLmlkIDwgbGFzdEN1cnNvcklkICsgMSkge1xuICAgICAgICAgIGN1cnNvci5jb250aW51ZShsYXN0Q3Vyc29ySWQgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21taXRJbmRleGVkREJUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIHJlcyhyZXQpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlTWVzc2FnZXNCeUlkKGRiLCBpZHMpIHtcbiAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihbT0JKRUNUX1NUT1JFX0lEXSwgJ3JlYWR3cml0ZScsIFRSQU5TQUNUSU9OX1NFVFRJTkdTKTtcbiAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShPQkpFQ1RfU1RPUkVfSUQpO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoaWRzLm1hcChpZCA9PiB7XG4gICAgY29uc3QgZGVsZXRlUmVxdWVzdCA9IG9iamVjdFN0b3JlLmRlbGV0ZShpZCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlcyA9PiB7XG4gICAgICBkZWxldGVSZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlcygpO1xuICAgIH0pO1xuICB9KSk7XG59XG5mdW5jdGlvbiBnZXRPbGRNZXNzYWdlcyhkYiwgdHRsKSB7XG4gIGNvbnN0IG9sZGVyVGhlbiA9IERhdGUubm93KCkgLSB0dGw7XG4gIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oT0JKRUNUX1NUT1JFX0lELCAncmVhZG9ubHknLCBUUkFOU0FDVElPTl9TRVRUSU5HUyk7XG4gIGNvbnN0IG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX0lEKTtcbiAgY29uc3QgcmV0ID0gW107XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXMgPT4ge1xuICAgIG9iamVjdFN0b3JlLm9wZW5DdXJzb3IoKS5vbnN1Y2Nlc3MgPSBldiA9PiB7XG4gICAgICBjb25zdCBjdXJzb3IgPSBldi50YXJnZXQucmVzdWx0O1xuICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICBjb25zdCBtc2dPYmsgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgIGlmIChtc2dPYmsudGltZSA8IG9sZGVyVGhlbikge1xuICAgICAgICAgIHJldC5wdXNoKG1zZ09iayk7XG4gICAgICAgICAgLy9hbGVydChcIk5hbWUgZm9yIFNTTiBcIiArIGN1cnNvci5rZXkgKyBcIiBpcyBcIiArIGN1cnNvci52YWx1ZS5uYW1lKTtcbiAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBtb3JlIG9sZCBtZXNzYWdlcyxcbiAgICAgICAgICBjb21taXRJbmRleGVkREJUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgICAgcmVzKHJldCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXMocmV0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNsZWFuT2xkTWVzc2FnZXMoZGIsIHR0bCkge1xuICByZXR1cm4gZ2V0T2xkTWVzc2FnZXMoZGIsIHR0bCkudGhlbih0b29PbGQgPT4ge1xuICAgIHJldHVybiByZW1vdmVNZXNzYWdlc0J5SWQoZGIsIHRvb09sZC5tYXAobXNnID0+IG1zZy5pZCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZSQzKGNoYW5uZWxOYW1lLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBmaWxsT3B0aW9uc1dpdGhEZWZhdWx0cyhvcHRpb25zKTtcbiAgcmV0dXJuIGNyZWF0ZURhdGFiYXNlKGNoYW5uZWxOYW1lKS50aGVuKGRiID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgIGNsb3NlZDogZmFsc2UsXG4gICAgICBsYXN0Q3Vyc29ySWQ6IDAsXG4gICAgICBjaGFubmVsTmFtZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICB1dWlkOiByYW5kb21Ub2tlbigpLFxuICAgICAgLyoqXG4gICAgICAgKiBlbWl0dGVkTWVzc2FnZXNJZHNcbiAgICAgICAqIGNvbnRhaW5zIGFsbCBtZXNzYWdlcyB0aGF0IGhhdmUgYmVlbiBlbWl0dGVkIGJlZm9yZVxuICAgICAgICogQHR5cGUge09ibGl2aW91c1NldH1cbiAgICAgICAqL1xuICAgICAgZU1JczogbmV3IE9ibGl2aW91c1NldChvcHRpb25zLmlkYi50dGwgKiAyKSxcbiAgICAgIC8vIGVuc3VyZXMgd2UgZG8gbm90IHJlYWQgbWVzc2FnZXMgaW4gcGFycmFsbGVsXG4gICAgICB3cml0ZUJsb2NrUHJvbWlzZTogUFJPTUlTRV9SRVNPTFZFRF9WT0lELFxuICAgICAgbWVzc2FnZXNDYWxsYmFjazogbnVsbCxcbiAgICAgIHJlYWRRdWV1ZVByb21pc2VzOiBbXSxcbiAgICAgIGRiLFxuICAgICAgdGltZTogbWljcm9TZWNvbmRzJDUoKVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYWJydXB0IGNsb3NlcyB0aGF0IGRvIG5vdCBvcmlnaW5hdGUgZnJvbSBkYi5jbG9zZSgpLlxuICAgICAqIFRoaXMgY291bGQgaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgdGhlIHVuZGVybHlpbmcgc3RvcmFnZSBpc1xuICAgICAqIHJlbW92ZWQgb3IgaWYgdGhlIHVzZXIgY2xlYXJzIHRoZSBkYXRhYmFzZSBpbiB0aGUgYnJvd3NlcidzXG4gICAgICogaGlzdG9yeSBwcmVmZXJlbmNlcy5cbiAgICAgKi9cbiAgICBkYi5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3RhdGUuY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGlmIChvcHRpb25zLmlkYi5vbmNsb3NlKSBvcHRpb25zLmlkYi5vbmNsb3NlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGlmIHNlcnZpY2Utd29ya2VycyBhcmUgdXNlZCxcbiAgICAgKiB3ZSBoYXZlIG5vICdzdG9yYWdlJy1ldmVudCBpZiB0aGV5IHBvc3QgYSBtZXNzYWdlLFxuICAgICAqIHRoZXJlZm9yZSB3ZSBhbHNvIGhhdmUgdG8gc2V0IGFuIGludGVydmFsXG4gICAgICovXG4gICAgX3JlYWRMb29wKHN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gX3JlYWRMb29wKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5jbG9zZWQpIHJldHVybjtcbiAgcmVhZE5ld01lc3NhZ2VzKHN0YXRlKS50aGVuKCgpID0+IHNsZWVwKHN0YXRlLm9wdGlvbnMuaWRiLmZhbGxiYWNrSW50ZXJ2YWwpKS50aGVuKCgpID0+IF9yZWFkTG9vcChzdGF0ZSkpO1xufVxuZnVuY3Rpb24gX2ZpbHRlck1lc3NhZ2UobXNnT2JqLCBzdGF0ZSkge1xuICBpZiAobXNnT2JqLnV1aWQgPT09IHN0YXRlLnV1aWQpIHJldHVybiBmYWxzZTsgLy8gc2VuZCBieSBvd25cbiAgaWYgKHN0YXRlLmVNSXMuaGFzKG1zZ09iai5pZCkpIHJldHVybiBmYWxzZTsgLy8gYWxyZWFkeSBlbWl0dGVkXG4gIGlmIChtc2dPYmouZGF0YS50aW1lIDwgc3RhdGUubWVzc2FnZXNDYWxsYmFja1RpbWUpIHJldHVybiBmYWxzZTsgLy8gb2xkZXIgdGhlbiBvbk1lc3NhZ2VDYWxsYmFja1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiByZWFkcyBhbGwgbmV3IG1lc3NhZ2VzIGZyb20gdGhlIGRhdGFiYXNlIGFuZCBlbWl0cyB0aGVtXG4gKi9cbmZ1bmN0aW9uIHJlYWROZXdNZXNzYWdlcyhzdGF0ZSkge1xuICAvLyBjaGFubmVsIGFscmVhZHkgY2xvc2VkXG4gIGlmIChzdGF0ZS5jbG9zZWQpIHJldHVybiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7XG5cbiAgLy8gaWYgbm8gb25lIGlzIGxpc3RlbmluZywgd2UgZG8gbm90IG5lZWQgdG8gc2NhbiBmb3IgbmV3IG1lc3NhZ2VzXG4gIGlmICghc3RhdGUubWVzc2FnZXNDYWxsYmFjaykgcmV0dXJuIFBST01JU0VfUkVTT0xWRURfVk9JRDtcbiAgcmV0dXJuIGdldE1lc3NhZ2VzSGlnaGVyVGhhbihzdGF0ZS5kYiwgc3RhdGUubGFzdEN1cnNvcklkKS50aGVuKG5ld2VyTWVzc2FnZXMgPT4ge1xuICAgIGNvbnN0IHVzZU1lc3NhZ2VzID0gbmV3ZXJNZXNzYWdlc1xuICAgIC8qKlxuICAgICAqIHRoZXJlIGlzIGEgYnVnIGluIGlPUyB3aGVyZSB0aGUgbXNnT2JqIGNhbiBiZSB1bmRlZmluZWQgc29tZSB0aW1lc1xuICAgICAqIHNvIHdlIGZpbHRlciB0aGVtIG91dFxuICAgICAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9wdWJrZXkvYnJvYWRjYXN0LWNoYW5uZWwvaXNzdWVzLzE5XG4gICAgICovLmZpbHRlcihtc2dPYmogPT4gISFtc2dPYmopLm1hcChtc2dPYmogPT4ge1xuICAgICAgaWYgKG1zZ09iai5pZCA+IHN0YXRlLmxhc3RDdXJzb3JJZCkge1xuICAgICAgICBzdGF0ZS5sYXN0Q3Vyc29ySWQgPSBtc2dPYmouaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbXNnT2JqO1xuICAgIH0pLmZpbHRlcihtc2dPYmogPT4gX2ZpbHRlck1lc3NhZ2UobXNnT2JqLCBzdGF0ZSkpLnNvcnQoKG1zZ09iakEsIG1zZ09iakIpID0+IG1zZ09iakEudGltZSAtIG1zZ09iakIudGltZSk7IC8vIHNvcnQgYnkgdGltZVxuICAgIHVzZU1lc3NhZ2VzLmZvckVhY2gobXNnT2JqID0+IHtcbiAgICAgIGlmIChzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKSB7XG4gICAgICAgIHN0YXRlLmVNSXMuYWRkKG1zZ09iai5pZCk7XG4gICAgICAgIHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2sobXNnT2JqLmRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gY2xvc2UkMyhjaGFubmVsU3RhdGUpIHtcbiAgY2hhbm5lbFN0YXRlLmNsb3NlZCA9IHRydWU7XG4gIGNoYW5uZWxTdGF0ZS5kYi5jbG9zZSgpO1xufVxuZnVuY3Rpb24gcG9zdE1lc3NhZ2UkMyhjaGFubmVsU3RhdGUsIG1lc3NhZ2VKc29uKSB7XG4gIGNoYW5uZWxTdGF0ZS53cml0ZUJsb2NrUHJvbWlzZSA9IGNoYW5uZWxTdGF0ZS53cml0ZUJsb2NrUHJvbWlzZS50aGVuKCgpID0+IHdyaXRlTWVzc2FnZShjaGFubmVsU3RhdGUuZGIsIGNoYW5uZWxTdGF0ZS51dWlkLCBtZXNzYWdlSnNvbikpLnRoZW4oKCkgPT4ge1xuICAgIGlmIChyYW5kb21JbnQoMCwgMTApID09PSAwKSB7XG4gICAgICAvKiBhd2FpdCAoZG8gbm90IGF3YWl0KSAqL1xuICAgICAgY2xlYW5PbGRNZXNzYWdlcyhjaGFubmVsU3RhdGUuZGIsIGNoYW5uZWxTdGF0ZS5vcHRpb25zLmlkYi50dGwpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjaGFubmVsU3RhdGUud3JpdGVCbG9ja1Byb21pc2U7XG59XG5mdW5jdGlvbiBvbk1lc3NhZ2UkMyhjaGFubmVsU3RhdGUsIGZuLCB0aW1lKSB7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSA9IHRpbWU7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrID0gZm47XG4gIHJlYWROZXdNZXNzYWdlcyhjaGFubmVsU3RhdGUpO1xufVxuZnVuY3Rpb24gY2FuQmVVc2VkJDMoKSB7XG4gIGNvbnN0IGlkYiA9IGdldElkYigpO1xuICBpZiAoIWlkYikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGF2ZXJhZ2VSZXNwb25zZVRpbWUkMyhvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmlkYi5mYWxsYmFja0ludGVydmFsICogMjtcbn1cbnZhciBJbmRleGVEYk1ldGhvZCA9IHtcbiAgZ2V0SWRiLFxuICBjcmVhdGVEYXRhYmFzZSxcbiAgY3JlYXRlOiBjcmVhdGUkMyxcbiAgY2xvc2U6IGNsb3NlJDMsXG4gIG9uTWVzc2FnZTogb25NZXNzYWdlJDMsXG4gIHBvc3RNZXNzYWdlOiBwb3N0TWVzc2FnZSQzLFxuICBjYW5CZVVzZWQ6IGNhbkJlVXNlZCQzLFxuICB0eXBlOiB0eXBlJDMsXG4gIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IGF2ZXJhZ2VSZXNwb25zZVRpbWUkMyxcbiAgbWljcm9TZWNvbmRzOiBtaWNyb1NlY29uZHMkMyxcbiAgd3JpdGVNZXNzYWdlLFxuICBnZXRBbGxNZXNzYWdlcyxcbiAgY2xlYW5PbGRNZXNzYWdlcyxcbiAgZ2V0TWVzc2FnZXNIaWdoZXJUaGFuLFxuICBnZXRPbGRNZXNzYWdlc1xufTtcblxuLyoqXG4gKiBBIGxvY2FsU3RvcmFnZS1vbmx5IG1ldGhvZCB3aGljaCB1c2VzIGxvY2Fsc3RvcmFnZSBhbmQgaXRzICdzdG9yYWdlJy1ldmVudFxuICogVGhpcyBkb2VzIG5vdCB3b3JrIGluc2lkZSBvZiB3ZWJ3b3JrZXJzIGJlY2F1c2UgdGhleSBoYXZlIG5vIGFjY2VzcyB0byBsb2Nhc3RvcmFnZVxuICogVGhpcyBpcyBiYXNpY2FsbHkgaW1wbGVtZW50ZWQgdG8gc3VwcG9ydCBJRTkgb3IgeW91ciBncmFuZG1vdGhlcnMgdG9hc3Rlci5cbiAqIEBsaW5rIGh0dHBzOi8vY2FuaXVzZS5jb20vI2ZlYXQ9bmFtZXZhbHVlLXN0b3JhZ2VcbiAqIEBsaW5rIGh0dHBzOi8vY2FuaXVzZS5jb20vI2ZlYXQ9aW5kZXhlZGRiXG4gKi9cblxuY29uc3QgbWljcm9TZWNvbmRzJDIgPSBtaWNyb1NlY29uZHMkNTtcbmNvbnN0IEtFWV9QUkVGSVgkMSA9ICdwdWJrZXkuYnJvYWRjYXN0Q2hhbm5lbC0nO1xuY29uc3QgdHlwZSQyID0gJ2xvY2Fsc3RvcmFnZSc7XG5cbi8qKlxuICogY29waWVkIGZyb20gY3Jvc3N0YWJcbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS90ZWphY3F1ZXMvY3Jvc3N0YWIvYmxvYi9tYXN0ZXIvc3JjL2Nyb3NzdGFiLmpzI0wzMlxuICovXG5mdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2UoKSB7XG4gIGxldCBsb2NhbFN0b3JhZ2U7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgbG9jYWxTdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICBsb2NhbFN0b3JhZ2UgPSB3aW5kb3dbJ2llOC1ldmVudGxpc3RlbmVyL3N0b3JhZ2UnXSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmV3IHZlcnNpb25zIG9mIEZpcmVmb3ggdGhyb3cgYSBTZWN1cml0eSBleGNlcHRpb25cbiAgICAvLyBpZiBjb29raWVzIGFyZSBkaXNhYmxlZC4gU2VlXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTAyODE1M1xuICB9XG4gIHJldHVybiBsb2NhbFN0b3JhZ2U7XG59XG5mdW5jdGlvbiBzdG9yYWdlS2V5JDEoY2hhbm5lbE5hbWUpIHtcbiAgcmV0dXJuIEtFWV9QUkVGSVgkMSArIGNoYW5uZWxOYW1lO1xufVxuXG4vKipcbiAqIHdyaXRlcyB0aGUgbmV3IG1lc3NhZ2UgdG8gdGhlIHN0b3JhZ2VcbiAqIGFuZCBmaXJlcyB0aGUgc3RvcmFnZS1ldmVudCBzbyBvdGhlciByZWFkZXJzIGNhbiBmaW5kIGl0XG4gKi9cbmZ1bmN0aW9uIHBvc3RNZXNzYWdlJDIoY2hhbm5lbFN0YXRlLCBtZXNzYWdlSnNvbikge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzID0+IHtcbiAgICBzbGVlcCgpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gc3RvcmFnZUtleSQxKGNoYW5uZWxTdGF0ZS5jaGFubmVsTmFtZSk7XG4gICAgICBjb25zdCB3cml0ZU9iaiA9IHtcbiAgICAgICAgdG9rZW46IHJhbmRvbVRva2VuKCksXG4gICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgIGRhdGE6IG1lc3NhZ2VKc29uLFxuICAgICAgICB1dWlkOiBjaGFubmVsU3RhdGUudXVpZFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHZhbHVlID0gSlNPTi5zdHJpbmdpZnkod3JpdGVPYmopO1xuICAgICAgZ2V0TG9jYWxTdG9yYWdlKCkuc2V0SXRlbShrZXksIHZhbHVlKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBTdG9yYWdlRXZlbnQgZG9lcyBub3QgZmlyZSB0aGUgJ3N0b3JhZ2UnIGV2ZW50XG4gICAgICAgKiBpbiB0aGUgd2luZG93IHRoYXQgY2hhbmdlcyB0aGUgc3RhdGUgb2YgdGhlIGxvY2FsIHN0b3JhZ2UuXG4gICAgICAgKiBTbyB3ZSBmaXJlIGl0IG1hbnVhbGx5XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBldi5pbml0RXZlbnQoJ3N0b3JhZ2UnLCB0cnVlLCB0cnVlKTtcbiAgICAgIGV2LmtleSA9IGtleTtcbiAgICAgIGV2Lm5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldik7XG4gICAgICByZXMoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRTdG9yYWdlRXZlbnRMaXN0ZW5lcihjaGFubmVsTmFtZSwgZm4pIHtcbiAgY29uc3Qga2V5ID0gc3RvcmFnZUtleSQxKGNoYW5uZWxOYW1lKTtcbiAgY29uc3QgbGlzdGVuZXIgPSBldiA9PiB7XG4gICAgaWYgKGV2LmtleSA9PT0ga2V5KSB7XG4gICAgICBmbihKU09OLnBhcnNlKGV2Lm5ld1ZhbHVlKSk7XG4gICAgfVxuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIGxpc3RlbmVyKTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3RvcmFnZUV2ZW50TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBsaXN0ZW5lcik7XG59XG5mdW5jdGlvbiBjcmVhdGUkMihjaGFubmVsTmFtZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMob3B0aW9ucyk7XG4gIGlmICghY2FuQmVVc2VkJDIoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQnJvYWRjYXN0Q2hhbm5lbDogbG9jYWxzdG9yYWdlIGNhbm5vdCBiZSB1c2VkJyk7XG4gIH1cbiAgY29uc3QgdXVpZCA9IHJhbmRvbVRva2VuKCk7XG5cbiAgLyoqXG4gICAqIGVNSXNcbiAgICogY29udGFpbnMgYWxsIG1lc3NhZ2VzIHRoYXQgaGF2ZSBiZWVuIGVtaXR0ZWQgYmVmb3JlXG4gICAqIEB0eXBlIHtPYmxpdmlvdXNTZXR9XG4gICAqL1xuICBjb25zdCBlTUlzID0gbmV3IE9ibGl2aW91c1NldChvcHRpb25zLmxvY2Fsc3RvcmFnZS5yZW1vdmVUaW1lb3V0KTtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgY2hhbm5lbE5hbWUsXG4gICAgdXVpZCxcbiAgICB0aW1lOiBtaWNyb1NlY29uZHMkNSgpLFxuICAgIGVNSXMgLy8gZW1pdHRlZE1lc3NhZ2VzSWRzXG4gIH07XG4gIHN0YXRlLmxpc3RlbmVyID0gYWRkU3RvcmFnZUV2ZW50TGlzdGVuZXIoY2hhbm5lbE5hbWUsIG1zZ09iaiA9PiB7XG4gICAgaWYgKCFzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKSByZXR1cm47IC8vIG5vIGxpc3RlbmVyXG4gICAgaWYgKG1zZ09iai51dWlkID09PSB1dWlkKSByZXR1cm47IC8vIG93biBtZXNzYWdlXG4gICAgaWYgKCFtc2dPYmoudG9rZW4gfHwgZU1Jcy5oYXMobXNnT2JqLnRva2VuKSkgcmV0dXJuOyAvLyBhbHJlYWR5IGVtaXR0ZWRcbiAgICBpZiAobXNnT2JqLmRhdGEudGltZSAmJiBtc2dPYmouZGF0YS50aW1lIDwgc3RhdGUubWVzc2FnZXNDYWxsYmFja1RpbWUpIHJldHVybjsgLy8gdG9vIG9sZFxuXG4gICAgZU1Jcy5hZGQobXNnT2JqLnRva2VuKTtcbiAgICBzdGF0ZS5tZXNzYWdlc0NhbGxiYWNrKG1zZ09iai5kYXRhKTtcbiAgfSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGNsb3NlJDIoY2hhbm5lbFN0YXRlKSB7XG4gIHJlbW92ZVN0b3JhZ2VFdmVudExpc3RlbmVyKGNoYW5uZWxTdGF0ZS5saXN0ZW5lcik7XG59XG5mdW5jdGlvbiBvbk1lc3NhZ2UkMihjaGFubmVsU3RhdGUsIGZuLCB0aW1lKSB7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSA9IHRpbWU7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrID0gZm47XG59XG5mdW5jdGlvbiBjYW5CZVVzZWQkMigpIHtcbiAgY29uc3QgbHMgPSBnZXRMb2NhbFN0b3JhZ2UoKTtcbiAgaWYgKCFscykgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IGtleSA9ICdfX2Jyb2FkY2FzdGNoYW5uZWxfY2hlY2snO1xuICAgIGxzLnNldEl0ZW0oa2V5LCAnd29ya3MnKTtcbiAgICBscy5yZW1vdmVJdGVtKGtleSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBTYWZhcmkgMTAgaW4gcHJpdmF0ZSBtb2RlIHdpbGwgbm90IGFsbG93IHdyaXRlIGFjY2VzcyB0byBsb2NhbFxuICAgIC8vIHN0b3JhZ2UgYW5kIGZhaWwgd2l0aCBhIFF1b3RhRXhjZWVkZWRFcnJvci4gU2VlXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9TdG9yYWdlX0FQSSNQcml2YXRlX0Jyb3dzaW5nX0luY29nbml0b19tb2Rlc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGF2ZXJhZ2VSZXNwb25zZVRpbWUkMigpIHtcbiAgY29uc3QgZGVmYXVsdFRpbWUgPSAxMjA7XG4gIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHVzZXJBZ2VudC5pbmNsdWRlcygnc2FmYXJpJykgJiYgIXVzZXJBZ2VudC5pbmNsdWRlcygnY2hyb21lJykpIHtcbiAgICAvLyBzYWZhcmkgaXMgbXVjaCBzbG93ZXIgc28gdGhpcyB0aW1lIGlzIGhpZ2hlclxuICAgIHJldHVybiBkZWZhdWx0VGltZSAqIDI7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRUaW1lO1xufVxudmFyIExvY2Fsc3RvcmFnZU1ldGhvZCA9IHtcbiAgZ2V0TG9jYWxTdG9yYWdlLFxuICBjcmVhdGU6IGNyZWF0ZSQyLFxuICBjbG9zZTogY2xvc2UkMixcbiAgb25NZXNzYWdlOiBvbk1lc3NhZ2UkMixcbiAgcG9zdE1lc3NhZ2U6IHBvc3RNZXNzYWdlJDIsXG4gIGNhbkJlVXNlZDogY2FuQmVVc2VkJDIsXG4gIHR5cGU6IHR5cGUkMixcbiAgYXZlcmFnZVJlc3BvbnNlVGltZTogYXZlcmFnZVJlc3BvbnNlVGltZSQyLFxuICBtaWNyb1NlY29uZHM6IG1pY3JvU2Vjb25kcyQyLFxuICBzdG9yYWdlS2V5OiBzdG9yYWdlS2V5JDEsXG4gIGFkZFN0b3JhZ2VFdmVudExpc3RlbmVyLFxuICByZW1vdmVTdG9yYWdlRXZlbnRMaXN0ZW5lclxufTtcblxuLyoqXG4gKiBBIGxvY2FsU3RvcmFnZS1vbmx5IG1ldGhvZCB3aGljaCB1c2VzIGxvY2Fsc3RvcmFnZSBhbmQgaXRzICdzdG9yYWdlJy1ldmVudFxuICogVGhpcyBkb2VzIG5vdCB3b3JrIGluc2lkZSBvZiB3ZWJ3b3JrZXJzIGJlY2F1c2UgdGhleSBoYXZlIG5vIGFjY2VzcyB0byBsb2Nhc3RvcmFnZVxuICogVGhpcyBpcyBiYXNpY2FsbHkgaW1wbGVtZW50ZWQgdG8gc3VwcG9ydCBJRTkgb3IgeW91ciBncmFuZG1vdGhlcnMgdG9hc3Rlci5cbiAqIEBsaW5rIGh0dHBzOi8vY2FuaXVzZS5jb20vI2ZlYXQ9bmFtZXZhbHVlLXN0b3JhZ2VcbiAqIEBsaW5rIGh0dHBzOi8vY2FuaXVzZS5jb20vI2ZlYXQ9aW5kZXhlZGRiXG4gKi9cblxuY29uc3QgbWljcm9TZWNvbmRzJDEgPSBtaWNyb1NlY29uZHMkNTtcbmNvbnN0IEtFWV9QUkVGSVggPSAncHVia2V5LmJyb2FkY2FzdENoYW5uZWwtJztcbmNvbnN0IHR5cGUkMSA9ICdzZXJ2ZXInO1xubGV0IFNPQ0tFVF9DT05OX0lOU1RBTkNFID0gbnVsbDtcbi8vIHVzZWQgdG8gZGVjaWRlIHRvIHJlY29ubmVjdCBzb2NrZXQgZS5nLiB3aGVuIHNvY2tldCBjb25uZWN0aW9uIGlzIGRpc2Nvbm5lY3RlZCB1bmV4cGVjdGVkbHlcbmNvbnN0IHJ1bm5pbmdDaGFubmVscyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHN0b3JhZ2VLZXkoY2hhbm5lbE5hbWUpIHtcbiAgcmV0dXJuIEtFWV9QUkVGSVggKyBjaGFubmVsTmFtZTtcbn1cblxuLyoqXG4gKiB3cml0ZXMgdGhlIG5ldyBtZXNzYWdlIHRvIHRoZSBzdG9yYWdlXG4gKiBhbmQgZmlyZXMgdGhlIHN0b3JhZ2UtZXZlbnQgc28gb3RoZXIgcmVhZGVycyBjYW4gZmluZCBpdFxuICovXG5mdW5jdGlvbiBwb3N0TWVzc2FnZSQxKGNoYW5uZWxTdGF0ZSwgbWVzc2FnZUpzb24pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHNsZWVwKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBzdG9yYWdlS2V5KGNoYW5uZWxTdGF0ZS5jaGFubmVsTmFtZSk7XG4gICAgICBjb25zdCBjaGFubmVsRW5jUHJpdktleSA9IGtlY2NhazI1NihCdWZmZXIuZnJvbShrZXksICd1dGY4JykpO1xuICAgICAgY29uc3QgZW5jRGF0YSA9IGF3YWl0IGVuY3J5cHREYXRhKGNoYW5uZWxFbmNQcml2S2V5LnRvU3RyaW5nKCdoZXgnKSwge1xuICAgICAgICB0b2tlbjogcmFuZG9tVG9rZW4oKSxcbiAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgZGF0YTogbWVzc2FnZUpzb24sXG4gICAgICAgIHV1aWQ6IGNoYW5uZWxTdGF0ZS51dWlkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgIHNhbWVPcmlnaW5DaGVjazogdHJ1ZSxcbiAgICAgICAgc2FtZUlwQ2hlY2s6IHRydWUsXG4gICAgICAgIGtleTogZ2V0UHVibGljKGNoYW5uZWxFbmNQcml2S2V5KS50b1N0cmluZygnaGV4JyksXG4gICAgICAgIGRhdGE6IGVuY0RhdGEsXG4gICAgICAgIHNpZ25hdHVyZTogKGF3YWl0IHNpZ24oY2hhbm5lbEVuY1ByaXZLZXksIGtlY2NhazI1NihCdWZmZXIuZnJvbShlbmNEYXRhLCAndXRmOCcpKSkpLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgfTtcbiAgICAgIGlmIChjaGFubmVsU3RhdGUudGltZW91dCkgYm9keS50aW1lb3V0ID0gY2hhbm5lbFN0YXRlLnRpbWVvdXQ7XG4gICAgICByZXR1cm4gZmV0Y2goY2hhbm5lbFN0YXRlLnNlcnZlclVybCArICcvY2hhbm5lbC9zZXQnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOCdcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihyZXMpLmNhdGNoKHJlaik7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U29ja2V0SW5zdGFuY2Uoc2VydmVyVXJsKSB7XG4gIGlmIChTT0NLRVRfQ09OTl9JTlNUQU5DRSkge1xuICAgIHJldHVybiBTT0NLRVRfQ09OTl9JTlNUQU5DRTtcbiAgfVxuICBjb25zdCBTT0NLRVRfQ09OTiA9IGlvKHNlcnZlclVybCwge1xuICAgIHRyYW5zcG9ydHM6IFsnd2Vic29ja2V0JywgJ3BvbGxpbmcnXSxcbiAgICAvLyB1c2UgV2ViU29ja2V0IGZpcnN0LCBpZiBhdmFpbGFibGVcbiAgICB3aXRoQ3JlZGVudGlhbHM6IHRydWUsXG4gICAgcmVjb25uZWN0aW9uRGVsYXlNYXg6IDEwMDAwLFxuICAgIHJlY29ubmVjdGlvbkF0dGVtcHRzOiAxMFxuICB9KTtcbiAgU09DS0VUX0NPTk4ub24oJ2Nvbm5lY3RfZXJyb3InLCBlcnIgPT4ge1xuICAgIC8vIHJldmVydCB0byBjbGFzc2ljIHVwZ3JhZGVcbiAgICBTT0NLRVRfQ09OTi5pby5vcHRzLnRyYW5zcG9ydHMgPSBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG4gICAgbG9nLmVycm9yKCdjb25uZWN0IGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIFNPQ0tFVF9DT05OLm9uKCdjb25uZWN0JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGVuZ2luZVxuICAgIH0gPSBTT0NLRVRfQ09OTi5pbztcbiAgICBsb2cuZGVidWcoJ2luaXRpYWxseSBjb25uZWN0ZWQgdG8nLCBlbmdpbmUudHJhbnNwb3J0Lm5hbWUpOyAvLyBpbiBtb3N0IGNhc2VzLCBwcmludHMgXCJwb2xsaW5nXCJcbiAgICBlbmdpbmUub25jZSgndXBncmFkZScsICgpID0+IHtcbiAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgdXBncmFkZWQgKGkuZS4gZnJvbSBIVFRQIGxvbmctcG9sbGluZyB0byBXZWJTb2NrZXQpXG4gICAgICBsb2cuZGVidWcoJ3VwZ3JhZGVkJywgZW5naW5lLnRyYW5zcG9ydC5uYW1lKTsgLy8gaW4gbW9zdCBjYXNlcywgcHJpbnRzIFwid2Vic29ja2V0XCJcbiAgICB9KTtcbiAgICBlbmdpbmUub25jZSgnY2xvc2UnLCByZWFzb24gPT4ge1xuICAgICAgLy8gY2FsbGVkIHdoZW4gdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbiBpcyBjbG9zZWRcbiAgICAgIGxvZy5kZWJ1ZygnY29ubmVjdGlvbiBjbG9zZWQnLCByZWFzb24pO1xuICAgIH0pO1xuICB9KTtcbiAgU09DS0VUX0NPTk4ub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICBsb2cuZXJyb3IoJ3NvY2tldCBlcnJvcmVkJywgZXJyKTtcbiAgICBTT0NLRVRfQ09OTi5kaXNjb25uZWN0KCk7XG4gIH0pO1xuICBTT0NLRVRfQ09OTl9JTlNUQU5DRSA9IFNPQ0tFVF9DT05OO1xuICByZXR1cm4gU09DS0VUX0NPTk47XG59XG5mdW5jdGlvbiBzZXR1cFNvY2tldENvbm5lY3Rpb24oc2VydmVyVXJsLCBjaGFubmVsU3RhdGUsIGZuKSB7XG4gIGNvbnN0IHNvY2tldENvbm4gPSBnZXRTb2NrZXRJbnN0YW5jZShzZXJ2ZXJVcmwpO1xuICBjb25zdCBrZXkgPSBzdG9yYWdlS2V5KGNoYW5uZWxTdGF0ZS5jaGFubmVsTmFtZSk7XG4gIGNvbnN0IGNoYW5uZWxFbmNQcml2S2V5ID0ga2VjY2FrMjU2KEJ1ZmZlci5mcm9tKGtleSwgJ3V0ZjgnKSk7XG4gIGNvbnN0IGNoYW5uZWxQdWJLZXkgPSBnZXRQdWJsaWMoY2hhbm5lbEVuY1ByaXZLZXkpLnRvU3RyaW5nKCdoZXgnKTtcbiAgaWYgKHNvY2tldENvbm4uY29ubmVjdGVkKSB7XG4gICAgc29ja2V0Q29ubi5lbWl0KCdjaGVja19hdXRoX3N0YXR1cycsIGNoYW5uZWxQdWJLZXksIHtcbiAgICAgIHNhbWVPcmlnaW5DaGVjazogdHJ1ZSxcbiAgICAgIHNhbWVJcENoZWNrOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc29ja2V0Q29ubi5vbmNlKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgbG9nLmRlYnVnKCdjb25uZWN0ZWQgd2l0aCBzb2NrZXQnKTtcbiAgICAgIHNvY2tldENvbm4uZW1pdCgnY2hlY2tfYXV0aF9zdGF0dXMnLCBjaGFubmVsUHViS2V5LCB7XG4gICAgICAgIHNhbWVPcmlnaW5DaGVjazogdHJ1ZSxcbiAgICAgICAgc2FtZUlwQ2hlY2s6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHJlY29ubmVjdCA9ICgpID0+IHtcbiAgICBzb2NrZXRDb25uLm9uY2UoJ2Nvbm5lY3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAocnVubmluZ0NoYW5uZWxzLmhhcyhjaGFubmVsU3RhdGUuY2hhbm5lbE5hbWUpKSB7XG4gICAgICAgIHNvY2tldENvbm4uZW1pdCgnY2hlY2tfYXV0aF9zdGF0dXMnLCBjaGFubmVsUHViS2V5LCB7XG4gICAgICAgICAgc2FtZU9yaWdpbkNoZWNrOiB0cnVlLFxuICAgICAgICAgIHNhbWVJcENoZWNrOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCB2aXNpYmlsaXR5TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgLy8gaWYgY2hhbm5lbCBpcyBjbG9zZWQsIHRoZW4gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICBpZiAoIXNvY2tldENvbm4gfHwgIXJ1bm5pbmdDaGFubmVscy5oYXMoY2hhbm5lbFN0YXRlLmNoYW5uZWxOYW1lKSkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHZpc2liaWxpdHlMaXN0ZW5lcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlmIG5vdCBjb25uZWN0ZWQsIHRoZW4gd2FpdCBmb3IgY29ubmVjdGlvbiBhbmQgcGluZyBzZXJ2ZXIgZm9yIGxhdGVzdCBtc2cuXG4gICAgaWYgKCFzb2NrZXRDb25uLmNvbm5lY3RlZCAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgcmVjb25uZWN0KCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBsaXN0ZW5lciA9IGFzeW5jIGV2ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVjRGF0YSA9IGF3YWl0IGRlY3J5cHREYXRhKGNoYW5uZWxFbmNQcml2S2V5LnRvU3RyaW5nKCdoZXgnKSwgZXYpO1xuICAgICAgbG9nLmluZm8oZGVjRGF0YSk7XG4gICAgICBmbihkZWNEYXRhKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH07XG4gIHNvY2tldENvbm4ub24oJ2Rpc2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgbG9nLmRlYnVnKCdzb2NrZXQgZGlzY29ubmVjdGVkJyk7XG4gICAgaWYgKHJ1bm5pbmdDaGFubmVscy5oYXMoY2hhbm5lbFN0YXRlLmNoYW5uZWxOYW1lKSkge1xuICAgICAgbG9nLmVycm9yKCdzb2NrZXQgZGlzY29ubmVjdGVkIHVuZXhwZWN0ZWRseSwgcmVjb25uZWN0aW5nIHNvY2tldCcpO1xuICAgICAgcmVjb25uZWN0KCk7XG4gICAgfVxuICB9KTtcbiAgc29ja2V0Q29ubi5vbihgJHtjaGFubmVsUHViS2V5fV9zdWNjZXNzYCwgbGlzdGVuZXIpO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHZpc2liaWxpdHlMaXN0ZW5lcik7XG4gIHJldHVybiBzb2NrZXRDb25uO1xufVxuZnVuY3Rpb24gY3JlYXRlJDEoY2hhbm5lbE5hbWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGZpbGxPcHRpb25zV2l0aERlZmF1bHRzKG9wdGlvbnMpO1xuICBjb25zdCB1dWlkID0gcmFuZG9tVG9rZW4oKTtcblxuICAvKipcbiAgICogZU1Jc1xuICAgKiBjb250YWlucyBhbGwgbWVzc2FnZXMgdGhhdCBoYXZlIGJlZW4gZW1pdHRlZCBiZWZvcmVcbiAgICogQHR5cGUge09ibGl2aW91c1NldH1cbiAgICovXG4gIGNvbnN0IGVNSXMgPSBuZXcgT2JsaXZpb3VzU2V0KG9wdGlvbnMuc2VydmVyLnJlbW92ZVRpbWVvdXQpO1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBjaGFubmVsTmFtZSxcbiAgICB1dWlkLFxuICAgIGVNSXMsXG4gICAgLy8gZW1pdHRlZE1lc3NhZ2VzSWRzXG4gICAgc2VydmVyVXJsOiBvcHRpb25zLnNlcnZlci51cmwsXG4gICAgdGltZTogbWljcm9TZWNvbmRzJDUoKVxuICB9O1xuICBpZiAob3B0aW9ucy5zZXJ2ZXIudGltZW91dCkgc3RhdGUudGltZW91dCA9IG9wdGlvbnMuc2VydmVyLnRpbWVvdXQ7XG4gIHNldHVwU29ja2V0Q29ubmVjdGlvbihvcHRpb25zLnNlcnZlci51cmwsIHN0YXRlLCBtc2dPYmogPT4ge1xuICAgIGlmICghc3RhdGUubWVzc2FnZXNDYWxsYmFjaykgcmV0dXJuOyAvLyBubyBsaXN0ZW5lclxuICAgIGlmIChtc2dPYmoudXVpZCA9PT0gc3RhdGUudXVpZCkgcmV0dXJuOyAvLyBvd24gbWVzc2FnZVxuICAgIGlmICghbXNnT2JqLnRva2VuIHx8IHN0YXRlLmVNSXMuaGFzKG1zZ09iai50b2tlbikpIHJldHVybjsgLy8gYWxyZWFkeSBlbWl0dGVkXG4gICAgLy8gaWYgKG1zZ09iai5kYXRhLnRpbWUgJiYgbXNnT2JqLmRhdGEudGltZSA8IHN0YXRlLm1lc3NhZ2VzQ2FsbGJhY2tUaW1lKSByZXR1cm47IC8vIHRvbyBvbGRcblxuICAgIHN0YXRlLmVNSXMuYWRkKG1zZ09iai50b2tlbik7XG4gICAgc3RhdGUubWVzc2FnZXNDYWxsYmFjayhtc2dPYmouZGF0YSk7XG4gIH0pO1xuICBydW5uaW5nQ2hhbm5lbHMuYWRkKGNoYW5uZWxOYW1lKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gY2xvc2UkMShjaGFubmVsU3RhdGUpIHtcbiAgcnVubmluZ0NoYW5uZWxzLmRlbGV0ZShjaGFubmVsU3RhdGUuY2hhbm5lbE5hbWUpO1xuICAvLyBnaXZlIDIgc2VjIGZvciBhbGwgbXNncyB3aGljaCBhcmUgaW4gdHJhbnNpdCB0byBiZSBjb25zdW1lZFxuICAvLyBieSByZWNlaXZlci5cbiAgLy8gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAvLyAgICAgcmVtb3ZlU3RvcmFnZUV2ZW50TGlzdGVuZXIoY2hhbm5lbFN0YXRlKTtcbiAgLy8gICAgIFNPQ0tFVF9DT05OX0lOU1RBTkNFID0gbnVsbDtcbiAgLy8gfSwgMTAwMCk7XG59XG5mdW5jdGlvbiBvbk1lc3NhZ2UkMShjaGFubmVsU3RhdGUsIGZuLCB0aW1lKSB7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrVGltZSA9IHRpbWU7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrID0gZm47XG59XG5mdW5jdGlvbiBjYW5CZVVzZWQkMSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhdmVyYWdlUmVzcG9uc2VUaW1lJDEoKSB7XG4gIGNvbnN0IGRlZmF1bHRUaW1lID0gNTAwO1xuICAvLyBUT0RPOiBNYXliZSBpbmNyZWFzZSBpdCBiYXNlZCBvbiBvcGVyYXRpb25cbiAgcmV0dXJuIGRlZmF1bHRUaW1lO1xufVxudmFyIFNlcnZlck1ldGhvZCA9IHtcbiAgY3JlYXRlOiBjcmVhdGUkMSxcbiAgY2xvc2U6IGNsb3NlJDEsXG4gIG9uTWVzc2FnZTogb25NZXNzYWdlJDEsXG4gIHBvc3RNZXNzYWdlOiBwb3N0TWVzc2FnZSQxLFxuICBjYW5CZVVzZWQ6IGNhbkJlVXNlZCQxLFxuICB0eXBlOiB0eXBlJDEsXG4gIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IGF2ZXJhZ2VSZXNwb25zZVRpbWUkMSxcbiAgbWljcm9TZWNvbmRzOiBtaWNyb1NlY29uZHMkMVxufTtcblxuY29uc3QgbWljcm9TZWNvbmRzID0gbWljcm9TZWNvbmRzJDU7XG5jb25zdCB0eXBlID0gJ3NpbXVsYXRlJztcbmNvbnN0IFNJTVVMQVRFX0NIQU5ORUxTID0gbmV3IFNldCgpO1xuY29uc3QgU0lNVUxBVEVfREVMQVlfVElNRSA9IDU7XG5mdW5jdGlvbiBjcmVhdGUoY2hhbm5lbE5hbWUpIHtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgdGltZTogbWljcm9TZWNvbmRzJDUoKSxcbiAgICBuYW1lOiBjaGFubmVsTmFtZSxcbiAgICBtZXNzYWdlc0NhbGxiYWNrOiBudWxsXG4gIH07XG4gIFNJTVVMQVRFX0NIQU5ORUxTLmFkZChzdGF0ZSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGNsb3NlKGNoYW5uZWxTdGF0ZSkge1xuICBTSU1VTEFURV9DSEFOTkVMUy5kZWxldGUoY2hhbm5lbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHBvc3RNZXNzYWdlKGNoYW5uZWxTdGF0ZSwgbWVzc2FnZUpzb24pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBjb25zdCBjaGFubmVsQXJyYXkgPSBBcnJheS5mcm9tKFNJTVVMQVRFX0NIQU5ORUxTKTtcbiAgICBjaGFubmVsQXJyYXkuZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICAgIGlmIChjaGFubmVsLm5hbWUgPT09IGNoYW5uZWxTdGF0ZS5uYW1lICYmXG4gICAgICAvLyBoYXMgc2FtZSBuYW1lXG4gICAgICBjaGFubmVsICE9PSBjaGFubmVsU3RhdGUgJiZcbiAgICAgIC8vIG5vdCBvd24gY2hhbm5lbFxuICAgICAgISFjaGFubmVsLm1lc3NhZ2VzQ2FsbGJhY2sgJiZcbiAgICAgIC8vIGhhcyBzdWJzY3JpYmVyc1xuICAgICAgY2hhbm5lbC50aW1lIDwgbWVzc2FnZUpzb24udGltZSAvLyBjaGFubmVsIG5vdCBjcmVhdGVkIGFmdGVyIHBvc3RNZXNzYWdlKCkgY2FsbFxuICAgICAgKSB7XG4gICAgICAgIGNoYW5uZWwubWVzc2FnZXNDYWxsYmFjayhtZXNzYWdlSnNvbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzKCk7XG4gIH0sIFNJTVVMQVRFX0RFTEFZX1RJTUUpKTtcbn1cbmZ1bmN0aW9uIG9uTWVzc2FnZShjaGFubmVsU3RhdGUsIGZuKSB7XG4gIGNoYW5uZWxTdGF0ZS5tZXNzYWdlc0NhbGxiYWNrID0gZm47XG59XG5mdW5jdGlvbiBjYW5CZVVzZWQoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXZlcmFnZVJlc3BvbnNlVGltZSgpIHtcbiAgcmV0dXJuIFNJTVVMQVRFX0RFTEFZX1RJTUU7XG59XG52YXIgU2ltdWxhdGVNZXRob2QgPSB7XG4gIGNyZWF0ZSxcbiAgY2xvc2UsXG4gIG9uTWVzc2FnZSxcbiAgcG9zdE1lc3NhZ2UsXG4gIGNhbkJlVXNlZCxcbiAgdHlwZSxcbiAgYXZlcmFnZVJlc3BvbnNlVGltZSxcbiAgbWljcm9TZWNvbmRzXG59O1xuXG4vLyBvcmRlciBpcyBpbXBvcnRhbnRcbmNvbnN0IE1FVEhPRFMgPSBbTmF0aXZlTWV0aG9kLFxuLy8gZmFzdGVzdFxuSW5kZXhlRGJNZXRob2QsIExvY2Fsc3RvcmFnZU1ldGhvZCwgU2VydmVyTWV0aG9kXTtcbmZ1bmN0aW9uIGNob29zZU1ldGhvZChvcHRpb25zKSB7XG4gIGxldCBjaG9vc2VNZXRob2RzID0gW10uY29uY2F0KG9wdGlvbnMubWV0aG9kcywgTUVUSE9EUykuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIC8vIGRpcmVjdGx5IGNob3NlblxuICBpZiAob3B0aW9ucy50eXBlKSB7XG4gICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ3NpbXVsYXRlJykge1xuICAgICAgLy8gb25seSB1c2Ugc2ltdWxhdGUtbWV0aG9kIGlmIGRpcmVjdGx5IGNob3NlblxuICAgICAgcmV0dXJuIFNpbXVsYXRlTWV0aG9kO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSBjaG9vc2VNZXRob2RzLmZpbmQobSA9PiBtLnR5cGUgPT09IG9wdGlvbnMudHlwZSk7XG4gICAgaWYgKCFyZXQpIHRocm93IG5ldyBFcnJvcignbWV0aG9kLXR5cGUgJyArIG9wdGlvbnMudHlwZSArICcgbm90IGZvdW5kJyk7ZWxzZSByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIGlmIG5vIHdlYndvcmtlciBzdXBwb3J0IGlzIG5lZWRlZCxcbiAgICogcmVtb3ZlIGlkYiBmcm9tIHRoZSBsaXN0IHNvIHRoYXQgbG9jYWxzdG9yYWdlIGlzIGJlZW4gY2hvc2VuXG4gICAqL1xuICBpZiAoIW9wdGlvbnMud2ViV29ya2VyU3VwcG9ydCkge1xuICAgIGNob29zZU1ldGhvZHMgPSBjaG9vc2VNZXRob2RzLmZpbHRlcihtID0+IG0udHlwZSAhPT0gJ2lkYicpO1xuICB9XG4gIGNvbnN0IHVzZU1ldGhvZCA9IGNob29zZU1ldGhvZHMuZmluZChtZXRob2QgPT4gbWV0aG9kLmNhbkJlVXNlZChvcHRpb25zKSk7XG4gIGlmICghdXNlTWV0aG9kKSB0aHJvdyBuZXcgRXJyb3IoYE5vIHVzZWFibGUgbWV0aG9kIGZvdW5kIGluICR7SlNPTi5zdHJpbmdpZnkoTUVUSE9EUy5tYXAobSA9PiBtLnR5cGUpKX1gKTtlbHNlIHJldHVybiB1c2VNZXRob2Q7XG59XG5cbi8qKlxuICogQ29udGFpbnMgYWxsIG9wZW4gY2hhbm5lbHMsXG4gKiB1c2VkIGluIHRlc3RzIHRvIGVuc3VyZSBldmVyeXRoaW5nIGlzIGNsb3NlZC5cbiAqL1xuY29uc3QgT1BFTl9CUk9BRENBU1RfQ0hBTk5FTFMgPSBuZXcgU2V0KCk7XG5sZXQgbGFzdElkID0gMDtcbmNvbnN0IEJyb2FkY2FzdENoYW5uZWwkMSA9IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG4gIC8vIGlkZW50aWZpZXIgb2YgdGhlIGNoYW5uZWwgdG8gZGVidWcgc3R1ZmZcbiAgdGhpcy5pZCA9IGxhc3RJZCsrO1xuICBPUEVOX0JST0FEQ0FTVF9DSEFOTkVMUy5hZGQodGhpcyk7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIGlmIChFTkZPUkNFRF9PUFRJT05TKSB7XG4gICAgb3B0aW9ucyA9IEVORk9SQ0VEX09QVElPTlM7XG4gIH1cbiAgdGhpcy5vcHRpb25zID0gZmlsbE9wdGlvbnNXaXRoRGVmYXVsdHMob3B0aW9ucyk7XG4gIHRoaXMubWV0aG9kID0gY2hvb3NlTWV0aG9kKHRoaXMub3B0aW9ucyk7XG5cbiAgLy8gaXNMaXN0ZW5pbmdcbiAgdGhpcy5faUwgPSBmYWxzZTtcblxuICAvKipcbiAgICogX29uTWVzc2FnZUxpc3RlbmVyXG4gICAqIHNldHRpbmcgb25tZXNzYWdlIHR3aWNlLFxuICAgKiB3aWxsIG92ZXJ3cml0ZSB0aGUgZmlyc3QgbGlzdGVuZXJcbiAgICovXG4gIHRoaXMuX29uTUwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBfYWRkRXZlbnRMaXN0ZW5lcnNcbiAgICovXG4gIHRoaXMuX2FkZEVMID0ge1xuICAgIG1lc3NhZ2U6IFtdLFxuICAgIGludGVybmFsOiBbXVxuICB9O1xuXG4gIC8qKlxuICAgKiBVbnNlbmQgbWVzc2FnZSBwcm9taXNlc1xuICAgKiB3aGVyZSB0aGUgc2VuZGluZyBpcyBzdGlsbCBpbiBwcm9ncmVzc1xuICAgKiBAdHlwZSB7U2V0PFByb21pc2U+fVxuICAgKi9cbiAgdGhpcy5fdU1QID0gbmV3IFNldCgpO1xuXG4gIC8qKlxuICAgKiBfYmVmb3JlQ2xvc2VcbiAgICogYXJyYXkgb2YgcHJvbWlzZXMgdGhhdCB3aWxsIGJlIGF3YWl0ZWRcbiAgICogYmVmb3JlIHRoZSBjaGFubmVsIGlzIGNsb3NlZFxuICAgKi9cbiAgdGhpcy5fYmVmQyA9IFtdO1xuXG4gIC8qKlxuICAgKiBfcHJlcGFyZVByb21pc2VcbiAgICovXG4gIHRoaXMuX3ByZXBQID0gbnVsbDtcbiAgX3ByZXBhcmVDaGFubmVsKHRoaXMpO1xufTtcblxuLy8gU1RBVElDU1xuXG4vKipcbiAqIHVzZWQgdG8gaWRlbnRpZnkgaWYgc29tZW9uZSBvdmVyd3JpdGVzXG4gKiB3aW5kb3cuQnJvYWRjYXN0Q2hhbm5lbCB3aXRoIHRoaXNcbiAqIFNlZSBtZXRob2RzL25hdGl2ZS5qc1xuICovXG5Ccm9hZGNhc3RDaGFubmVsJDEuX3B1YmtleSA9IHRydWU7XG5cbi8qKlxuICogaWYgc2V0LCB0aGlzIG1ldGhvZCBpcyBlbmZvcmNlZCxcbiAqIG5vIG1hdGhlciB3aGF0IHRoZSBvcHRpb25zIGFyZVxuICovXG5sZXQgRU5GT1JDRURfT1BUSU9OUztcbmZ1bmN0aW9uIGVuZm9yY2VPcHRpb25zKG9wdGlvbnMpIHtcbiAgRU5GT1JDRURfT1BUSU9OUyA9IG9wdGlvbnM7XG59XG5cbi8vIFBST1RPVFlQRVxuQnJvYWRjYXN0Q2hhbm5lbCQxLnByb3RvdHlwZSA9IHtcbiAgcG9zdE1lc3NhZ2UobXNnKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb2FkY2FzdENoYW5uZWwucG9zdE1lc3NhZ2UoKTogJyArICdDYW5ub3QgcG9zdCBtZXNzYWdlIGFmdGVyIGNoYW5uZWwgaGFzIGNsb3NlZCAnICtcbiAgICAgIC8qKlxuICAgICAgICogSW4gdGhlIHBhc3Qgd2hlbiB0aGlzIGVycm9yIGFwcGVhcmVkLCBpdCB3YXMgcmVhbHkgaGFyZCB0byBkZWJ1Zy5cbiAgICAgICAqIFNvIG5vdyB3ZSBsb2cgdGhlIG1zZyB0b2dldGhlciB3aXRoIHRoZSBlcnJvciBzbyBpdCBhdCBsZWFzdFxuICAgICAgICogZ2l2ZXMgc29tZSBjbHVlIGFib3V0IHdoZXJlIGluIHlvdXIgYXBwbGljYXRpb24gdGhpcyBoYXBwZW5zLlxuICAgICAgICovXG4gICAgICBKU09OLnN0cmluZ2lmeShtc2cpKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wb3N0KHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgfSxcbiAgcG9zdEludGVybmFsKG1zZykge1xuICAgIHJldHVybiBfcG9zdCh0aGlzLCAnaW50ZXJuYWwnLCBtc2cpO1xuICB9LFxuICBzZXQgb25tZXNzYWdlKGZuKSB7XG4gICAgY29uc3QgdGltZSA9IHRoaXMubWV0aG9kLm1pY3JvU2Vjb25kcygpO1xuICAgIGNvbnN0IGxpc3Rlbk9iaiA9IHtcbiAgICAgIHRpbWUsXG4gICAgICBmblxuICAgIH07XG4gICAgX3JlbW92ZUxpc3RlbmVyT2JqZWN0KHRoaXMsICdtZXNzYWdlJywgdGhpcy5fb25NTCk7XG4gICAgaWYgKGZuICYmIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fb25NTCA9IGxpc3Rlbk9iajtcbiAgICAgIF9hZGRMaXN0ZW5lck9iamVjdCh0aGlzLCAnbWVzc2FnZScsIGxpc3Rlbk9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29uTUwgPSBudWxsO1xuICAgIH1cbiAgfSxcbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbikge1xuICAgIGNvbnN0IHRpbWUgPSB0aGlzLm1ldGhvZC5taWNyb1NlY29uZHMoKTtcbiAgICBjb25zdCBsaXN0ZW5PYmogPSB7XG4gICAgICB0aW1lLFxuICAgICAgZm5cbiAgICB9O1xuICAgIF9hZGRMaXN0ZW5lck9iamVjdCh0aGlzLCB0eXBlLCBsaXN0ZW5PYmopO1xuICB9LFxuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy5fYWRkRUxbdHlwZV0uZmluZChvYmogPT4gb2JqLmZuID09PSBmbik7XG4gICAgX3JlbW92ZUxpc3RlbmVyT2JqZWN0KHRoaXMsIHR5cGUsIG9iaik7XG4gIH0sXG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPUEVOX0JST0FEQ0FTVF9DSEFOTkVMUy5kZWxldGUodGhpcyk7XG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIGNvbnN0IGF3YWl0UHJlcGFyZSA9IHRoaXMuX3ByZXBQID8gdGhpcy5fcHJlcFAgOiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7XG4gICAgdGhpcy5fb25NTCA9IG51bGw7XG4gICAgdGhpcy5fYWRkRUwubWVzc2FnZSA9IFtdO1xuICAgIHJldHVybiBhd2FpdFByZXBhcmVcbiAgICAvLyB3YWl0IHVudGlsIGFsbCBjdXJyZW50IHNlbmRpbmcgYXJlIHByb2Nlc3NlZFxuICAgIC50aGVuKCgpID0+IFByb21pc2UuYWxsKEFycmF5LmZyb20odGhpcy5fdU1QKSkpXG4gICAgLy8gcnVuIGJlZm9yZS1jbG9zZSBob29rc1xuICAgIC50aGVuKCgpID0+IFByb21pc2UuYWxsKHRoaXMuX2JlZkMubWFwKGZuID0+IGZuKCkpKSlcbiAgICAvLyBjbG9zZSB0aGUgY2hhbm5lbFxuICAgIC50aGVuKCgpID0+IHRoaXMubWV0aG9kLmNsb3NlKHRoaXMuX3N0YXRlKSk7XG4gIH0sXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZC50eXBlO1xuICB9LFxuICBnZXQgaXNDbG9zZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VkO1xuICB9XG59O1xuXG4vKipcbiAqIFBvc3QgYSBtZXNzYWdlIG92ZXIgdGhlIGNoYW5uZWxcbiAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHJlc29sdmVkIHdoZW4gdGhlIG1lc3NhZ2Ugc2VuZGluZyBpcyBkb25lXG4gKi9cbmZ1bmN0aW9uIF9wb3N0KGJyb2FkY2FzdENoYW5uZWwsIHR5cGUsIG1zZykge1xuICBjb25zdCB0aW1lID0gYnJvYWRjYXN0Q2hhbm5lbC5tZXRob2QubWljcm9TZWNvbmRzKCk7XG4gIGNvbnN0IG1zZ09iaiA9IHtcbiAgICB0aW1lLFxuICAgIHR5cGUsXG4gICAgZGF0YTogbXNnXG4gIH07XG4gIGNvbnN0IGF3YWl0UHJlcGFyZSA9IGJyb2FkY2FzdENoYW5uZWwuX3ByZXBQID8gYnJvYWRjYXN0Q2hhbm5lbC5fcHJlcFAgOiBQUk9NSVNFX1JFU09MVkVEX1ZPSUQ7XG4gIHJldHVybiBhd2FpdFByZXBhcmUudGhlbigoKSA9PiB7XG4gICAgY29uc3Qgc2VuZFByb21pc2UgPSBicm9hZGNhc3RDaGFubmVsLm1ldGhvZC5wb3N0TWVzc2FnZShicm9hZGNhc3RDaGFubmVsLl9zdGF0ZSwgbXNnT2JqKTtcblxuICAgIC8vIGFkZC9yZW1vdmUgdG8gdW5zZW5kIG1lc3NhZ2VzIGxpc3RcbiAgICBicm9hZGNhc3RDaGFubmVsLl91TVAuYWRkKHNlbmRQcm9taXNlKTtcbiAgICBzZW5kUHJvbWlzZS5jYXRjaCgpLnRoZW4oKCkgPT4gYnJvYWRjYXN0Q2hhbm5lbC5fdU1QLmRlbGV0ZShzZW5kUHJvbWlzZSkpO1xuICAgIHJldHVybiBzZW5kUHJvbWlzZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBfcHJlcGFyZUNoYW5uZWwoY2hhbm5lbCkge1xuICBjb25zdCBtYXliZVByb21pc2UgPSBjaGFubmVsLm1ldGhvZC5jcmVhdGUoY2hhbm5lbC5uYW1lLCBjaGFubmVsLm9wdGlvbnMpO1xuICBpZiAoaXNQcm9taXNlKG1heWJlUHJvbWlzZSkpIHtcbiAgICBjaGFubmVsLl9wcmVwUCA9IG1heWJlUHJvbWlzZTtcbiAgICBtYXliZVByb21pc2UudGhlbihzID0+IHtcbiAgICAgIC8vIHVzZWQgaW4gdGVzdHMgdG8gc2ltdWxhdGUgc2xvdyBydW50aW1lXG4gICAgICAvKmlmIChjaGFubmVsLm9wdGlvbnMucHJlcGFyZURlbGF5KSB7XG4gICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgdGhpcy5vcHRpb25zLnByZXBhcmVEZWxheSkpO1xuICAgICAgfSovXG4gICAgICBjaGFubmVsLl9zdGF0ZSA9IHM7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2hhbm5lbC5fc3RhdGUgPSBtYXliZVByb21pc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIF9oYXNNZXNzYWdlTGlzdGVuZXJzKGNoYW5uZWwpIHtcbiAgaWYgKGNoYW5uZWwuX2FkZEVMLm1lc3NhZ2UubGVuZ3RoID4gMCkgcmV0dXJuIHRydWU7XG4gIGlmIChjaGFubmVsLl9hZGRFTC5pbnRlcm5hbC5sZW5ndGggPiAwKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gX2FkZExpc3RlbmVyT2JqZWN0KGNoYW5uZWwsIHR5cGUsIG9iaikge1xuICBjaGFubmVsLl9hZGRFTFt0eXBlXS5wdXNoKG9iaik7XG4gIF9zdGFydExpc3RlbmluZyhjaGFubmVsKTtcbn1cbmZ1bmN0aW9uIF9yZW1vdmVMaXN0ZW5lck9iamVjdChjaGFubmVsLCB0eXBlLCBvYmopIHtcbiAgY2hhbm5lbC5fYWRkRUxbdHlwZV0gPSBjaGFubmVsLl9hZGRFTFt0eXBlXS5maWx0ZXIobyA9PiBvICE9PSBvYmopO1xuICBfc3RvcExpc3RlbmluZyhjaGFubmVsKTtcbn1cbmZ1bmN0aW9uIF9zdGFydExpc3RlbmluZyhjaGFubmVsKSB7XG4gIGlmICghY2hhbm5lbC5faUwgJiYgX2hhc01lc3NhZ2VMaXN0ZW5lcnMoY2hhbm5lbCkpIHtcbiAgICAvLyBzb21lb25lIGlzIGxpc3RlbmluZywgc3RhcnQgc3Vic2NyaWJpbmdcblxuICAgIGNvbnN0IGxpc3RlbmVyRm4gPSBtc2dPYmogPT4ge1xuICAgICAgY2hhbm5lbC5fYWRkRUxbbXNnT2JqLnR5cGVdLmZvckVhY2gobGlzdGVuZXJPYmplY3QgPT4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0dGluZyB0aGUgY3VycmVudCB0aW1lIGluIEphdmFTY3JpcHQgaGFzIG5vIGdvb2QgcHJlY2lzaW9uLlxuICAgICAgICAgKiBTbyBpbnN0ZWFkIG9mIG9ubHkgbGlzdGVuaW5nIHRvIGV2ZW50cyB0aGF0IGhhcHBlbmQgJ2FmdGVyJyB0aGUgbGlzdGVuZXJcbiAgICAgICAgICogd2FzIGFkZGVkLCB3ZSBhbHNvIGxpc3RlbiB0byBldmVudHMgdGhhdCBoYXBwZW5kZWQgMTAwbXMgYmVmb3JlIGl0LlxuICAgICAgICAgKiBUaGlzIGVuc3VyZXMgdGhhdCB3aGVuIGFub3RoZXIgcHJvY2VzcywgbGlrZSBhIFdlYldvcmtlciwgc2VuZHMgZXZlbnRzXG4gICAgICAgICAqIHdlIGRvIG5vdCBtaXNzIHRoZW0gb3V0IGJlY2F1c2UgdGhlaXIgdGltZXN0YW1wIGlzIGEgYml0IG9mZiBjb21wYXJlZCB0byB0aGUgbWFpbiBwcm9jZXNzLlxuICAgICAgICAgKiBOb3QgZG9pbmcgdGhpcyB3b3VsZCBtYWtlIG1lc3NhZ2VzIG1pc3Npbmcgd2hlbiB3ZSBzZW5kIGRhdGEgZGlyZWN0bHkgYWZ0ZXIgc3Vic2NyaWJpbmcgYW5kIGF3YWl0aW5nIGEgcmVzcG9uc2UuXG4gICAgICAgICAqIEBsaW5rIGh0dHBzOi8vam9obnJlc2lnLmNvbS9ibG9nL2FjY3VyYWN5LW9mLWphdmFzY3JpcHQtdGltZS9cbiAgICAgICAgICovXG4gICAgICAgIC8vIGNvbnN0IGh1bmRyZWRNc0luTWljcm8gPSAxMDAgKiAxMDAwO1xuICAgICAgICAvLyBjb25zdCBtaW5NZXNzYWdlVGltZSA9IGxpc3RlbmVyT2JqZWN0LnRpbWUgLSBodW5kcmVkTXNJbk1pY3JvO1xuXG4gICAgICAgIGlmIChtc2dPYmoudGltZSA+PSBsaXN0ZW5lck9iamVjdC50aW1lKSB7XG4gICAgICAgICAgbGlzdGVuZXJPYmplY3QuZm4obXNnT2JqLmRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWwubWV0aG9kLnR5cGUgPT09ICdzZXJ2ZXInKSB7XG4gICAgICAgICAgLy8gc2VydmVyIG1zZyBtaWdodCBsYWcgYmFzZWQgb24gY29ubmVjdGlvbi5cbiAgICAgICAgICBsaXN0ZW5lck9iamVjdC5mbihtc2dPYmouZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdGltZSA9IGNoYW5uZWwubWV0aG9kLm1pY3JvU2Vjb25kcygpO1xuICAgIGlmIChjaGFubmVsLl9wcmVwUCkge1xuICAgICAgY2hhbm5lbC5fcHJlcFAudGhlbigoKSA9PiB7XG4gICAgICAgIGNoYW5uZWwuX2lMID0gdHJ1ZTtcbiAgICAgICAgY2hhbm5lbC5tZXRob2Qub25NZXNzYWdlKGNoYW5uZWwuX3N0YXRlLCBsaXN0ZW5lckZuLCB0aW1lKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFubmVsLl9pTCA9IHRydWU7XG4gICAgICBjaGFubmVsLm1ldGhvZC5vbk1lc3NhZ2UoY2hhbm5lbC5fc3RhdGUsIGxpc3RlbmVyRm4sIHRpbWUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3N0b3BMaXN0ZW5pbmcoY2hhbm5lbCkge1xuICBpZiAoY2hhbm5lbC5faUwgJiYgIV9oYXNNZXNzYWdlTGlzdGVuZXJzKGNoYW5uZWwpKSB7XG4gICAgLy8gbm9vbmUgaXMgbGlzdGVuaW5nLCBzdG9wIHN1YnNjcmliaW5nXG4gICAgY2hhbm5lbC5faUwgPSBmYWxzZTtcbiAgICBjb25zdCB0aW1lID0gY2hhbm5lbC5tZXRob2QubWljcm9TZWNvbmRzKCk7XG4gICAgY2hhbm5lbC5tZXRob2Qub25NZXNzYWdlKGNoYW5uZWwuX3N0YXRlLCBudWxsLCB0aW1lKTtcbiAgfVxufVxuXG5leHBvcnQgeyBCcm9hZGNhc3RDaGFubmVsJDEgYXMgQnJvYWRjYXN0Q2hhbm5lbCwgSW5kZXhlRGJNZXRob2QgYXMgSW5kZXhlZERiTWV0aG9kLCBMb2NhbHN0b3JhZ2VNZXRob2QgYXMgTG9jYWxTdG9yYWdlTWV0aG9kLCBOYXRpdmVNZXRob2QsIE9QRU5fQlJPQURDQVNUX0NIQU5ORUxTLCBTZXJ2ZXJNZXRob2QsIGNob29zZU1ldGhvZCwgZW5mb3JjZU9wdGlvbnMgfTtcbiJdLCJuYW1lcyI6WyJsb2dsZXZlbCIsIk9ibGl2aW91c1NldCIsImlvIiwiZ2V0UHVibGljIiwic2lnbiIsImtlY2NhazI1NiIsImVuY3J5cHREYXRhIiwiZGVjcnlwdERhdGEiLCJpc1Byb21pc2UiLCJvYmoiLCJ0aGVuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJQUk9NSVNFX1JFU09MVkVEX1ZPSUQiLCJzbGVlcCIsInRpbWUiLCJyZXNvbHZlV2l0aCIsInJlcyIsInNldFRpbWVvdXQiLCJyYW5kb21JbnQiLCJtaW4iLCJtYXgiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJyYW5kb21Ub2tlbiIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwibGFzdE1zIiwibWljcm9TZWNvbmRzJDUiLCJyZXQiLCJEYXRlIiwibm93IiwibG9nIiwiZ2V0TG9nZ2VyIiwic2V0TGV2ZWwiLCJtaWNyb1NlY29uZHMkNCIsInR5cGUkNCIsImNyZWF0ZSQ0IiwiY2hhbm5lbE5hbWUiLCJzdGF0ZSIsIm1lc3NhZ2VzQ2FsbGJhY2siLCJiYyIsIkJyb2FkY2FzdENoYW5uZWwiLCJzdWJGbnMiLCJvbm1lc3NhZ2UiLCJtc2ciLCJkYXRhIiwiY2xvc2UkNCIsImNoYW5uZWxTdGF0ZSIsImNsb3NlIiwicG9zdE1lc3NhZ2UkNCIsIm1lc3NhZ2VKc29uIiwicG9zdE1lc3NhZ2UiLCJlcnIiLCJyZWplY3QiLCJvbk1lc3NhZ2UkNCIsImZuIiwiY2FuQmVVc2VkJDQiLCJfcHVia2V5IiwiRXJyb3IiLCJhdmVyYWdlUmVzcG9uc2VUaW1lJDQiLCJOYXRpdmVNZXRob2QiLCJjcmVhdGUiLCJvbk1lc3NhZ2UiLCJjYW5CZVVzZWQiLCJ0eXBlIiwiYXZlcmFnZVJlc3BvbnNlVGltZSIsIm1pY3JvU2Vjb25kcyIsImZpbGxPcHRpb25zV2l0aERlZmF1bHRzIiwib3JpZ2luYWxPcHRpb25zIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwib3B0aW9ucyIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsIndlYldvcmtlclN1cHBvcnQiLCJpZGIiLCJ0dGwiLCJmYWxsYmFja0ludGVydmFsIiwib25jbG9zZSIsImxvY2Fsc3RvcmFnZSIsInJlbW92ZVRpbWVvdXQiLCJzZXJ2ZXIiLCJ1cmwiLCJtZXRob2RzIiwibWljcm9TZWNvbmRzJDMiLCJEQl9QUkVGSVgiLCJPQkpFQ1RfU1RPUkVfSUQiLCJUUkFOU0FDVElPTl9TRVRUSU5HUyIsImR1cmFiaWxpdHkiLCJ0eXBlJDMiLCJnZXRJZGIiLCJpbmRleGVkREIiLCJ3aW5kb3ciLCJtb3pJbmRleGVkREIiLCJ3ZWJraXRJbmRleGVkREIiLCJtc0luZGV4ZWREQiIsImNvbW1pdEluZGV4ZWREQlRyYW5zYWN0aW9uIiwidHgiLCJjb21taXQiLCJjcmVhdGVEYXRhYmFzZSIsIkluZGV4ZWREQiIsImRiTmFtZSIsIm9wZW5SZXF1ZXN0Iiwib3BlbiIsIm9udXBncmFkZW5lZWRlZCIsImV2IiwiZGIiLCJ0YXJnZXQiLCJyZXN1bHQiLCJjcmVhdGVPYmplY3RTdG9yZSIsImtleVBhdGgiLCJhdXRvSW5jcmVtZW50IiwiZGJQcm9taXNlIiwicmVqIiwib25lcnJvciIsIm9uc3VjY2VzcyIsIndyaXRlTWVzc2FnZSIsInJlYWRlclV1aWQiLCJ3cml0ZU9iamVjdCIsInV1aWQiLCJ0cmFuc2FjdGlvbiIsIm9uY29tcGxldGUiLCJvYmplY3RTdG9yZSIsImFkZCIsImdldEFsbE1lc3NhZ2VzIiwib3BlbkN1cnNvciIsImN1cnNvciIsInB1c2giLCJ2YWx1ZSIsImNvbnRpbnVlIiwiZ2V0TWVzc2FnZXNIaWdoZXJUaGFuIiwibGFzdEN1cnNvcklkIiwia2V5UmFuZ2VWYWx1ZSIsIklEQktleVJhbmdlIiwiYm91bmQiLCJJbmZpbml0eSIsImdldEFsbCIsImdldEFsbFJlcXVlc3QiLCJlIiwib3BlbkN1cnNvclJlcXVlc3QiLCJpZCIsInJlbW92ZU1lc3NhZ2VzQnlJZCIsImlkcyIsImFsbCIsIm1hcCIsImRlbGV0ZVJlcXVlc3QiLCJkZWxldGUiLCJnZXRPbGRNZXNzYWdlcyIsIm9sZGVyVGhlbiIsIm1zZ09iayIsImNsZWFuT2xkTWVzc2FnZXMiLCJ0b29PbGQiLCJjcmVhdGUkMyIsImNsb3NlZCIsImVNSXMiLCJ3cml0ZUJsb2NrUHJvbWlzZSIsInJlYWRRdWV1ZVByb21pc2VzIiwiX3JlYWRMb29wIiwicmVhZE5ld01lc3NhZ2VzIiwiX2ZpbHRlck1lc3NhZ2UiLCJtc2dPYmoiLCJoYXMiLCJtZXNzYWdlc0NhbGxiYWNrVGltZSIsIm5ld2VyTWVzc2FnZXMiLCJ1c2VNZXNzYWdlcyIsImZpbHRlciIsInNvcnQiLCJtc2dPYmpBIiwibXNnT2JqQiIsImZvckVhY2giLCJjbG9zZSQzIiwicG9zdE1lc3NhZ2UkMyIsIm9uTWVzc2FnZSQzIiwiY2FuQmVVc2VkJDMiLCJhdmVyYWdlUmVzcG9uc2VUaW1lJDMiLCJJbmRleGVEYk1ldGhvZCIsIm1pY3JvU2Vjb25kcyQyIiwiS0VZX1BSRUZJWCQxIiwidHlwZSQyIiwiZ2V0TG9jYWxTdG9yYWdlIiwibG9jYWxTdG9yYWdlIiwic3RvcmFnZUtleSQxIiwicG9zdE1lc3NhZ2UkMiIsImtleSIsIndyaXRlT2JqIiwidG9rZW4iLCJzZXRJdGVtIiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsIm5ld1ZhbHVlIiwiZGlzcGF0Y2hFdmVudCIsImFkZFN0b3JhZ2VFdmVudExpc3RlbmVyIiwibGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlU3RvcmFnZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY3JlYXRlJDIiLCJjYW5CZVVzZWQkMiIsImNsb3NlJDIiLCJvbk1lc3NhZ2UkMiIsImxzIiwicmVtb3ZlSXRlbSIsImF2ZXJhZ2VSZXNwb25zZVRpbWUkMiIsImRlZmF1bHRUaW1lIiwidXNlckFnZW50IiwibmF2aWdhdG9yIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsIkxvY2Fsc3RvcmFnZU1ldGhvZCIsInN0b3JhZ2VLZXkiLCJtaWNyb1NlY29uZHMkMSIsIktFWV9QUkVGSVgiLCJ0eXBlJDEiLCJTT0NLRVRfQ09OTl9JTlNUQU5DRSIsInJ1bm5pbmdDaGFubmVscyIsIlNldCIsInBvc3RNZXNzYWdlJDEiLCJjaGFubmVsRW5jUHJpdktleSIsIkJ1ZmZlciIsImZyb20iLCJlbmNEYXRhIiwiYm9keSIsInNhbWVPcmlnaW5DaGVjayIsInNhbWVJcENoZWNrIiwic2lnbmF0dXJlIiwidGltZW91dCIsImZldGNoIiwic2VydmVyVXJsIiwibWV0aG9kIiwiaGVhZGVycyIsImNhdGNoIiwiZ2V0U29ja2V0SW5zdGFuY2UiLCJTT0NLRVRfQ09OTiIsInRyYW5zcG9ydHMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJyZWNvbm5lY3Rpb25EZWxheU1heCIsInJlY29ubmVjdGlvbkF0dGVtcHRzIiwib24iLCJvcHRzIiwiZXJyb3IiLCJlbmdpbmUiLCJkZWJ1ZyIsInRyYW5zcG9ydCIsIm5hbWUiLCJvbmNlIiwicmVhc29uIiwiZGlzY29ubmVjdCIsInNldHVwU29ja2V0Q29ubmVjdGlvbiIsInNvY2tldENvbm4iLCJjaGFubmVsUHViS2V5IiwiY29ubmVjdGVkIiwiZW1pdCIsInJlY29ubmVjdCIsInZpc2liaWxpdHlMaXN0ZW5lciIsInZpc2liaWxpdHlTdGF0ZSIsImRlY0RhdGEiLCJpbmZvIiwiY3JlYXRlJDEiLCJjbG9zZSQxIiwib25NZXNzYWdlJDEiLCJjYW5CZVVzZWQkMSIsImF2ZXJhZ2VSZXNwb25zZVRpbWUkMSIsIlNlcnZlck1ldGhvZCIsIlNJTVVMQVRFX0NIQU5ORUxTIiwiU0lNVUxBVEVfREVMQVlfVElNRSIsImNoYW5uZWxBcnJheSIsIkFycmF5IiwiY2hhbm5lbCIsIlNpbXVsYXRlTWV0aG9kIiwiTUVUSE9EUyIsImNob29zZU1ldGhvZCIsImNob29zZU1ldGhvZHMiLCJjb25jYXQiLCJCb29sZWFuIiwiZmluZCIsIm0iLCJ1c2VNZXRob2QiLCJPUEVOX0JST0FEQ0FTVF9DSEFOTkVMUyIsImxhc3RJZCIsIkJyb2FkY2FzdENoYW5uZWwkMSIsIkVORk9SQ0VEX09QVElPTlMiLCJfaUwiLCJfb25NTCIsIl9hZGRFTCIsIm1lc3NhZ2UiLCJpbnRlcm5hbCIsIl91TVAiLCJfYmVmQyIsIl9wcmVwUCIsIl9wcmVwYXJlQ2hhbm5lbCIsImVuZm9yY2VPcHRpb25zIiwicHJvdG90eXBlIiwiX3Bvc3QiLCJwb3N0SW50ZXJuYWwiLCJsaXN0ZW5PYmoiLCJfcmVtb3ZlTGlzdGVuZXJPYmplY3QiLCJfYWRkTGlzdGVuZXJPYmplY3QiLCJhd2FpdFByZXBhcmUiLCJfc3RhdGUiLCJpc0Nsb3NlZCIsImJyb2FkY2FzdENoYW5uZWwiLCJzZW5kUHJvbWlzZSIsIm1heWJlUHJvbWlzZSIsInMiLCJfaGFzTWVzc2FnZUxpc3RlbmVycyIsIl9zdGFydExpc3RlbmluZyIsIm8iLCJfc3RvcExpc3RlbmluZyIsImxpc3RlbmVyRm4iLCJsaXN0ZW5lck9iamVjdCIsIkluZGV4ZWREYk1ldGhvZCIsIkxvY2FsU3RvcmFnZU1ldGhvZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/broadcast-channel/dist/broadcastChannel.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/constants/dist/constants.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@toruslabs/constants/dist/constants.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FND_SERVER: () => (/* binding */ FND_SERVER),\n/* harmony export */   KEY_TYPE: () => (/* binding */ KEY_TYPE),\n/* harmony export */   LEGACY_NETWORKS_ROUTE_MAP: () => (/* binding */ LEGACY_NETWORKS_ROUTE_MAP),\n/* harmony export */   METADATA_MAP: () => (/* binding */ METADATA_MAP),\n/* harmony export */   MULTI_CLUSTER_NETWORKS: () => (/* binding */ MULTI_CLUSTER_NETWORKS),\n/* harmony export */   NETWORK_MAP: () => (/* binding */ NETWORK_MAP),\n/* harmony export */   PROXY_CONTRACT_ADDRESS: () => (/* binding */ PROXY_CONTRACT_ADDRESS),\n/* harmony export */   SESSION_SERVER: () => (/* binding */ SESSION_SERVER),\n/* harmony export */   SIGNER_MAP: () => (/* binding */ SIGNER_MAP),\n/* harmony export */   TORUS_LEGACY_NETWORK: () => (/* binding */ TORUS_LEGACY_NETWORK),\n/* harmony export */   TORUS_SAPPHIRE_NETWORK: () => (/* binding */ TORUS_SAPPHIRE_NETWORK),\n/* harmony export */   abi: () => (/* binding */ abi)\n/* harmony export */ });\nconst TORUS_LEGACY_NETWORK = {\n    MAINNET: \"mainnet\",\n    TESTNET: \"testnet\",\n    CYAN: \"cyan\",\n    AQUA: \"aqua\",\n    CELESTE: \"celeste\"\n};\nconst TORUS_SAPPHIRE_NETWORK = {\n    SAPPHIRE_DEVNET: \"sapphire_devnet\",\n    SAPPHIRE_MAINNET: \"sapphire_mainnet\"\n};\nconst PROXY_CONTRACT_ADDRESS = {\n    [TORUS_LEGACY_NETWORK.MAINNET]: \"0xf20336e16B5182637f09821c27BDe29b0AFcfe80\",\n    [TORUS_LEGACY_NETWORK.TESTNET]: \"0xd084604e5FA387FbC2Da8bAab07fDD6aDED4614A\",\n    [TORUS_LEGACY_NETWORK.CYAN]: \"0x9f072ba19b3370e512aa1b4bfcdaf97283168005\",\n    [TORUS_LEGACY_NETWORK.AQUA]: \"0x29Dea82a0509153b91040ee13cDBba0f03efb625\",\n    [TORUS_LEGACY_NETWORK.CELESTE]: \"0x6Bffb4e89453069E7487f0fa5c9f4a2D771cce6c\"\n};\nconst MULTI_CLUSTER_NETWORKS = [];\nconst LEGACY_NETWORKS_ROUTE_MAP = {\n    [TORUS_LEGACY_NETWORK.AQUA]: {\n        migrationCompleted: true,\n        networkIdentifier: \"aqua\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n    },\n    [TORUS_LEGACY_NETWORK.CELESTE]: {\n        migrationCompleted: true,\n        networkIdentifier: \"celeste\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n    },\n    [TORUS_LEGACY_NETWORK.CYAN]: {\n        migrationCompleted: true,\n        networkIdentifier: \"cyan\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n    },\n    [TORUS_LEGACY_NETWORK.MAINNET]: {\n        migrationCompleted: true,\n        networkIdentifier: \"mainnet\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n    },\n    [TORUS_LEGACY_NETWORK.TESTNET]: {\n        migrationCompleted: true,\n        networkIdentifier: \"teal\",\n        networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET\n    }\n};\nconst NETWORK_MAP = {\n    [TORUS_LEGACY_NETWORK.MAINNET]: \"mainnet\",\n    [TORUS_LEGACY_NETWORK.TESTNET]: \"goerli\",\n    [TORUS_LEGACY_NETWORK.CYAN]: \"polygon-mainnet\",\n    [TORUS_LEGACY_NETWORK.AQUA]: \"polygon-mainnet\",\n    [TORUS_LEGACY_NETWORK.CELESTE]: \"polygon-mainnet\"\n};\nconst SIGNER_MAP = {\n    [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET]: \"https://signer.web3auth.io\",\n    [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET]: \"https://signer.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.MAINNET]: \"https://signer.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.TESTNET]: \"https://signer.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.CYAN]: \"https://signer-polygon.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.AQUA]: \"https://signer-polygon.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.CELESTE]: \"https://signer-polygon.web3auth.io\"\n};\nconst METADATA_MAP = {\n    [TORUS_LEGACY_NETWORK.MAINNET]: \"https://metadata.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.TESTNET]: \"https://metadata.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.CYAN]: \"https://metadata.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.AQUA]: \"https://metadata.web3auth.io\",\n    [TORUS_LEGACY_NETWORK.CELESTE]: \"https://metadata.web3auth.io\"\n};\nconst FND_SERVER = \"https://fnd.web3auth.io\";\nconst SESSION_SERVER = \"https://session.web3auth.io\";\nconst KEY_TYPE = {\n    SECP256K1: \"secp256k1\",\n    ED25519: \"ed25519\"\n};\nconst abi = [\n    {\n        inputs: [\n            {\n                internalType: \"string\",\n                name: \"_verifier\",\n                type: \"string\"\n            },\n            {\n                internalType: \"bytes32\",\n                name: \"hashedVerifierId\",\n                type: \"bytes32\"\n            }\n        ],\n        name: \"getNodeSet\",\n        outputs: [\n            {\n                internalType: \"uint256\",\n                name: \"currentEpoch\",\n                type: \"uint256\"\n            },\n            {\n                internalType: \"string[]\",\n                name: \"torusNodeEndpoints\",\n                type: \"string[]\"\n            },\n            {\n                internalType: \"uint256[]\",\n                name: \"torusNodePubX\",\n                type: \"uint256[]\"\n            },\n            {\n                internalType: \"uint256[]\",\n                name: \"torusNodePubY\",\n                type: \"uint256[]\"\n            },\n            {\n                internalType: \"uint256[]\",\n                name: \"torusIndexes\",\n                type: \"uint256[]\"\n            }\n        ],\n        stateMutability: \"view\",\n        type: \"function\"\n    }\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9jb25zdGFudHMvZGlzdC9jb25zdGFudHMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLHVCQUF1QjtJQUMzQkMsU0FBUztJQUNUQyxTQUFTO0lBQ1RDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxTQUFTO0FBQ1g7QUFDQSxNQUFNQyx5QkFBeUI7SUFDN0JDLGlCQUFpQjtJQUNqQkMsa0JBQWtCO0FBQ3BCO0FBQ0EsTUFBTUMseUJBQXlCO0lBQzdCLENBQUNULHFCQUFxQkMsT0FBTyxDQUFDLEVBQUU7SUFDaEMsQ0FBQ0QscUJBQXFCRSxPQUFPLENBQUMsRUFBRTtJQUNoQyxDQUFDRixxQkFBcUJHLElBQUksQ0FBQyxFQUFFO0lBQzdCLENBQUNILHFCQUFxQkksSUFBSSxDQUFDLEVBQUU7SUFDN0IsQ0FBQ0oscUJBQXFCSyxPQUFPLENBQUMsRUFBRTtBQUNsQztBQUNBLE1BQU1LLHlCQUF5QixFQUk5QjtBQUNELE1BQU1DLDRCQUE0QjtJQUNoQyxDQUFDWCxxQkFBcUJJLElBQUksQ0FBQyxFQUFFO1FBQzNCUSxvQkFBb0I7UUFDcEJDLG1CQUFtQjtRQUNuQkMsbUJBQW1CUix1QkFBdUJFLGdCQUFnQjtJQUM1RDtJQUNBLENBQUNSLHFCQUFxQkssT0FBTyxDQUFDLEVBQUU7UUFDOUJPLG9CQUFvQjtRQUNwQkMsbUJBQW1CO1FBQ25CQyxtQkFBbUJSLHVCQUF1QkUsZ0JBQWdCO0lBQzVEO0lBQ0EsQ0FBQ1IscUJBQXFCRyxJQUFJLENBQUMsRUFBRTtRQUMzQlMsb0JBQW9CO1FBQ3BCQyxtQkFBbUI7UUFDbkJDLG1CQUFtQlIsdUJBQXVCRSxnQkFBZ0I7SUFDNUQ7SUFDQSxDQUFDUixxQkFBcUJDLE9BQU8sQ0FBQyxFQUFFO1FBQzlCVyxvQkFBb0I7UUFDcEJDLG1CQUFtQjtRQUNuQkMsbUJBQW1CUix1QkFBdUJFLGdCQUFnQjtJQUM1RDtJQUNBLENBQUNSLHFCQUFxQkUsT0FBTyxDQUFDLEVBQUU7UUFDOUJVLG9CQUFvQjtRQUNwQkMsbUJBQW1CO1FBQ25CQyxtQkFBbUJSLHVCQUF1QkMsZUFBZTtJQUMzRDtBQUNGO0FBQ0EsTUFBTVEsY0FBYztJQUNsQixDQUFDZixxQkFBcUJDLE9BQU8sQ0FBQyxFQUFFO0lBQ2hDLENBQUNELHFCQUFxQkUsT0FBTyxDQUFDLEVBQUU7SUFDaEMsQ0FBQ0YscUJBQXFCRyxJQUFJLENBQUMsRUFBRTtJQUM3QixDQUFDSCxxQkFBcUJJLElBQUksQ0FBQyxFQUFFO0lBQzdCLENBQUNKLHFCQUFxQkssT0FBTyxDQUFDLEVBQUU7QUFDbEM7QUFDQSxNQUFNVyxhQUFhO0lBQ2pCLENBQUNWLHVCQUF1QkUsZ0JBQWdCLENBQUMsRUFBRTtJQUMzQyxDQUFDRix1QkFBdUJDLGVBQWUsQ0FBQyxFQUFFO0lBQzFDLENBQUNQLHFCQUFxQkMsT0FBTyxDQUFDLEVBQUU7SUFDaEMsQ0FBQ0QscUJBQXFCRSxPQUFPLENBQUMsRUFBRTtJQUNoQyxDQUFDRixxQkFBcUJHLElBQUksQ0FBQyxFQUFFO0lBQzdCLENBQUNILHFCQUFxQkksSUFBSSxDQUFDLEVBQUU7SUFDN0IsQ0FBQ0oscUJBQXFCSyxPQUFPLENBQUMsRUFBRTtBQUNsQztBQUNBLE1BQU1ZLGVBQWU7SUFDbkIsQ0FBQ2pCLHFCQUFxQkMsT0FBTyxDQUFDLEVBQUU7SUFDaEMsQ0FBQ0QscUJBQXFCRSxPQUFPLENBQUMsRUFBRTtJQUNoQyxDQUFDRixxQkFBcUJHLElBQUksQ0FBQyxFQUFFO0lBQzdCLENBQUNILHFCQUFxQkksSUFBSSxDQUFDLEVBQUU7SUFDN0IsQ0FBQ0oscUJBQXFCSyxPQUFPLENBQUMsRUFBRTtBQUNsQztBQUNBLE1BQU1hLGFBQWE7QUFDbkIsTUFBTUMsaUJBQWlCO0FBQ3ZCLE1BQU1DLFdBQVc7SUFDZkMsV0FBVztJQUNYQyxTQUFTO0FBQ1g7QUFFQSxNQUFNQyxNQUFNO0lBQUM7UUFDWEMsUUFBUTtZQUFDO2dCQUNQQyxjQUFjO2dCQUNkQyxNQUFNO2dCQUNOQyxNQUFNO1lBQ1I7WUFBRztnQkFDREYsY0FBYztnQkFDZEMsTUFBTTtnQkFDTkMsTUFBTTtZQUNSO1NBQUU7UUFDRkQsTUFBTTtRQUNORSxTQUFTO1lBQUM7Z0JBQ1JILGNBQWM7Z0JBQ2RDLE1BQU07Z0JBQ05DLE1BQU07WUFDUjtZQUFHO2dCQUNERixjQUFjO2dCQUNkQyxNQUFNO2dCQUNOQyxNQUFNO1lBQ1I7WUFBRztnQkFDREYsY0FBYztnQkFDZEMsTUFBTTtnQkFDTkMsTUFBTTtZQUNSO1lBQUc7Z0JBQ0RGLGNBQWM7Z0JBQ2RDLE1BQU07Z0JBQ05DLE1BQU07WUFDUjtZQUFHO2dCQUNERixjQUFjO2dCQUNkQyxNQUFNO2dCQUNOQyxNQUFNO1lBQ1I7U0FBRTtRQUNGRSxpQkFBaUI7UUFDakJGLE1BQU07SUFDUjtDQUFFO0FBRW1OIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29sLXBvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9jb25zdGFudHMvZGlzdC9jb25zdGFudHMuZXNtLmpzPzNlOWIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVE9SVVNfTEVHQUNZX05FVFdPUksgPSB7XG4gIE1BSU5ORVQ6IFwibWFpbm5ldFwiLFxuICBURVNUTkVUOiBcInRlc3RuZXRcIixcbiAgQ1lBTjogXCJjeWFuXCIsXG4gIEFRVUE6IFwiYXF1YVwiLFxuICBDRUxFU1RFOiBcImNlbGVzdGVcIlxufTtcbmNvbnN0IFRPUlVTX1NBUFBISVJFX05FVFdPUksgPSB7XG4gIFNBUFBISVJFX0RFVk5FVDogXCJzYXBwaGlyZV9kZXZuZXRcIixcbiAgU0FQUEhJUkVfTUFJTk5FVDogXCJzYXBwaGlyZV9tYWlubmV0XCJcbn07XG5jb25zdCBQUk9YWV9DT05UUkFDVF9BRERSRVNTID0ge1xuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuTUFJTk5FVF06IFwiMHhmMjAzMzZlMTZCNTE4MjYzN2YwOTgyMWMyN0JEZTI5YjBBRmNmZTgwXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5URVNUTkVUXTogXCIweGQwODQ2MDRlNUZBMzg3RmJDMkRhOGJBYWIwN2ZERDZhREVENDYxNEFcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNZQU5dOiBcIjB4OWYwNzJiYTE5YjMzNzBlNTEyYWExYjRiZmNkYWY5NzI4MzE2ODAwNVwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQVFVQV06IFwiMHgyOURlYTgyYTA1MDkxNTNiOTEwNDBlZTEzY0RCYmEwZjAzZWZiNjI1XCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DRUxFU1RFXTogXCIweDZCZmZiNGU4OTQ1MzA2OUU3NDg3ZjBmYTVjOWY0YTJENzcxY2NlNmNcIlxufTtcbmNvbnN0IE1VTFRJX0NMVVNURVJfTkVUV09SS1MgPSBbXG4gIC8vIFRPUlVTX0xFR0FDWV9ORVRXT1JLLkFRVUEsXG4gIC8vIFRPUlVTX0xFR0FDWV9ORVRXT1JLLkNFTEVTVEUsXG4gIC8vIFRPUlVTX0xFR0FDWV9ORVRXT1JLLkNZQU4sXG5dO1xuY29uc3QgTEVHQUNZX05FVFdPUktTX1JPVVRFX01BUCA9IHtcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkFRVUFdOiB7XG4gICAgbWlncmF0aW9uQ29tcGxldGVkOiB0cnVlLFxuICAgIG5ldHdvcmtJZGVudGlmaWVyOiBcImFxdWFcIixcbiAgICBuZXR3b3JrTWlncmF0ZWRUbzogVE9SVVNfU0FQUEhJUkVfTkVUV09SSy5TQVBQSElSRV9NQUlOTkVUXG4gIH0sXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DRUxFU1RFXToge1xuICAgIG1pZ3JhdGlvbkNvbXBsZXRlZDogdHJ1ZSxcbiAgICBuZXR3b3JrSWRlbnRpZmllcjogXCJjZWxlc3RlXCIsXG4gICAgbmV0d29ya01pZ3JhdGVkVG86IFRPUlVTX1NBUFBISVJFX05FVFdPUksuU0FQUEhJUkVfTUFJTk5FVFxuICB9LFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ1lBTl06IHtcbiAgICBtaWdyYXRpb25Db21wbGV0ZWQ6IHRydWUsXG4gICAgbmV0d29ya0lkZW50aWZpZXI6IFwiY3lhblwiLFxuICAgIG5ldHdvcmtNaWdyYXRlZFRvOiBUT1JVU19TQVBQSElSRV9ORVRXT1JLLlNBUFBISVJFX01BSU5ORVRcbiAgfSxcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLk1BSU5ORVRdOiB7XG4gICAgbWlncmF0aW9uQ29tcGxldGVkOiB0cnVlLFxuICAgIG5ldHdvcmtJZGVudGlmaWVyOiBcIm1haW5uZXRcIixcbiAgICBuZXR3b3JrTWlncmF0ZWRUbzogVE9SVVNfU0FQUEhJUkVfTkVUV09SSy5TQVBQSElSRV9NQUlOTkVUXG4gIH0sXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5URVNUTkVUXToge1xuICAgIG1pZ3JhdGlvbkNvbXBsZXRlZDogdHJ1ZSxcbiAgICBuZXR3b3JrSWRlbnRpZmllcjogXCJ0ZWFsXCIsXG4gICAgbmV0d29ya01pZ3JhdGVkVG86IFRPUlVTX1NBUFBISVJFX05FVFdPUksuU0FQUEhJUkVfREVWTkVUXG4gIH1cbn07XG5jb25zdCBORVRXT1JLX01BUCA9IHtcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLk1BSU5ORVRdOiBcIm1haW5uZXRcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLlRFU1RORVRdOiBcImdvZXJsaVwiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuQ1lBTl06IFwicG9seWdvbi1tYWlubmV0XCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5BUVVBXTogXCJwb2x5Z29uLW1haW5uZXRcIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLkNFTEVTVEVdOiBcInBvbHlnb24tbWFpbm5ldFwiXG59O1xuY29uc3QgU0lHTkVSX01BUCA9IHtcbiAgW1RPUlVTX1NBUFBISVJFX05FVFdPUksuU0FQUEhJUkVfTUFJTk5FVF06IFwiaHR0cHM6Ly9zaWduZXIud2ViM2F1dGguaW9cIixcbiAgW1RPUlVTX1NBUFBISVJFX05FVFdPUksuU0FQUEhJUkVfREVWTkVUXTogXCJodHRwczovL3NpZ25lci53ZWIzYXV0aC5pb1wiLFxuICBbVE9SVVNfTEVHQUNZX05FVFdPUksuTUFJTk5FVF06IFwiaHR0cHM6Ly9zaWduZXIud2ViM2F1dGguaW9cIixcbiAgW1RPUlVTX0xFR0FDWV9ORVRXT1JLLlRFU1RORVRdOiBcImh0dHBzOi8vc2lnbmVyLndlYjNhdXRoLmlvXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DWUFOXTogXCJodHRwczovL3NpZ25lci1wb2x5Z29uLndlYjNhdXRoLmlvXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5BUVVBXTogXCJodHRwczovL3NpZ25lci1wb2x5Z29uLndlYjNhdXRoLmlvXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DRUxFU1RFXTogXCJodHRwczovL3NpZ25lci1wb2x5Z29uLndlYjNhdXRoLmlvXCJcbn07XG5jb25zdCBNRVRBREFUQV9NQVAgPSB7XG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5NQUlOTkVUXTogXCJodHRwczovL21ldGFkYXRhLndlYjNhdXRoLmlvXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5URVNUTkVUXTogXCJodHRwczovL21ldGFkYXRhLndlYjNhdXRoLmlvXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DWUFOXTogXCJodHRwczovL21ldGFkYXRhLndlYjNhdXRoLmlvXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5BUVVBXTogXCJodHRwczovL21ldGFkYXRhLndlYjNhdXRoLmlvXCIsXG4gIFtUT1JVU19MRUdBQ1lfTkVUV09SSy5DRUxFU1RFXTogXCJodHRwczovL21ldGFkYXRhLndlYjNhdXRoLmlvXCJcbn07XG5jb25zdCBGTkRfU0VSVkVSID0gXCJodHRwczovL2ZuZC53ZWIzYXV0aC5pb1wiO1xuY29uc3QgU0VTU0lPTl9TRVJWRVIgPSBcImh0dHBzOi8vc2Vzc2lvbi53ZWIzYXV0aC5pb1wiO1xuY29uc3QgS0VZX1RZUEUgPSB7XG4gIFNFQ1AyNTZLMTogXCJzZWNwMjU2azFcIixcbiAgRUQyNTUxOTogXCJlZDI1NTE5XCJcbn07XG5cbmNvbnN0IGFiaSA9IFt7XG4gIGlucHV0czogW3tcbiAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgbmFtZTogXCJfdmVyaWZpZXJcIixcbiAgICB0eXBlOiBcInN0cmluZ1wiXG4gIH0sIHtcbiAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgIG5hbWU6IFwiaGFzaGVkVmVyaWZpZXJJZFwiLFxuICAgIHR5cGU6IFwiYnl0ZXMzMlwiXG4gIH1dLFxuICBuYW1lOiBcImdldE5vZGVTZXRcIixcbiAgb3V0cHV0czogW3tcbiAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgIG5hbWU6IFwiY3VycmVudEVwb2NoXCIsXG4gICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgfSwge1xuICAgIGludGVybmFsVHlwZTogXCJzdHJpbmdbXVwiLFxuICAgIG5hbWU6IFwidG9ydXNOb2RlRW5kcG9pbnRzXCIsXG4gICAgdHlwZTogXCJzdHJpbmdbXVwiXG4gIH0sIHtcbiAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NltdXCIsXG4gICAgbmFtZTogXCJ0b3J1c05vZGVQdWJYXCIsXG4gICAgdHlwZTogXCJ1aW50MjU2W11cIlxuICB9LCB7XG4gICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZbXVwiLFxuICAgIG5hbWU6IFwidG9ydXNOb2RlUHViWVwiLFxuICAgIHR5cGU6IFwidWludDI1NltdXCJcbiAgfSwge1xuICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2W11cIixcbiAgICBuYW1lOiBcInRvcnVzSW5kZXhlc1wiLFxuICAgIHR5cGU6IFwidWludDI1NltdXCJcbiAgfV0sXG4gIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gIHR5cGU6IFwiZnVuY3Rpb25cIlxufV07XG5cbmV4cG9ydCB7IEZORF9TRVJWRVIsIEtFWV9UWVBFLCBMRUdBQ1lfTkVUV09SS1NfUk9VVEVfTUFQLCBNRVRBREFUQV9NQVAsIE1VTFRJX0NMVVNURVJfTkVUV09SS1MsIE5FVFdPUktfTUFQLCBQUk9YWV9DT05UUkFDVF9BRERSRVNTLCBTRVNTSU9OX1NFUlZFUiwgU0lHTkVSX01BUCwgVE9SVVNfTEVHQUNZX05FVFdPUkssIFRPUlVTX1NBUFBISVJFX05FVFdPUkssIGFiaSB9O1xuIl0sIm5hbWVzIjpbIlRPUlVTX0xFR0FDWV9ORVRXT1JLIiwiTUFJTk5FVCIsIlRFU1RORVQiLCJDWUFOIiwiQVFVQSIsIkNFTEVTVEUiLCJUT1JVU19TQVBQSElSRV9ORVRXT1JLIiwiU0FQUEhJUkVfREVWTkVUIiwiU0FQUEhJUkVfTUFJTk5FVCIsIlBST1hZX0NPTlRSQUNUX0FERFJFU1MiLCJNVUxUSV9DTFVTVEVSX05FVFdPUktTIiwiTEVHQUNZX05FVFdPUktTX1JPVVRFX01BUCIsIm1pZ3JhdGlvbkNvbXBsZXRlZCIsIm5ldHdvcmtJZGVudGlmaWVyIiwibmV0d29ya01pZ3JhdGVkVG8iLCJORVRXT1JLX01BUCIsIlNJR05FUl9NQVAiLCJNRVRBREFUQV9NQVAiLCJGTkRfU0VSVkVSIiwiU0VTU0lPTl9TRVJWRVIiLCJLRVlfVFlQRSIsIlNFQ1AyNTZLMSIsIkVEMjU1MTkiLCJhYmkiLCJpbnB1dHMiLCJpbnRlcm5hbFR5cGUiLCJuYW1lIiwidHlwZSIsIm91dHB1dHMiLCJzdGF0ZU11dGFiaWxpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/constants/dist/constants.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   derive: () => (/* binding */ derive),\n/* harmony export */   derivePadded: () => (/* binding */ derivePadded),\n/* harmony export */   deriveUnpadded: () => (/* binding */ deriveUnpadded),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   generatePrivate: () => (/* binding */ generatePrivate),\n/* harmony export */   getPublic: () => (/* binding */ getPublic),\n/* harmony export */   getPublicCompressed: () => (/* binding */ getPublicCompressed),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(elliptic__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst ec = new elliptic__WEBPACK_IMPORTED_MODULE_1__.ec(\"secp256k1\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst browserCrypto = global.crypto || global.msCrypto || {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failed\");\n    }\n}\nfunction isScalar(x) {\n    return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n    if (!isScalar(privateKey)) {\n        return false;\n    }\n    return privateKey.compare(ZERO32) > 0 && // > 0\n    privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    let res = 0;\n    for(let i = 0; i < b1.length; i++){\n        res |= b1[i] ^ b2[i]; // jshint ignore:line\n    }\n    return res === 0;\n}\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */ function randomBytes(size) {\n    const arr = new Uint8Array(size);\n    if (typeof browserCrypto.getRandomValues === \"undefined\") {\n        return Buffer.from(crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(size));\n    }\n    browserCrypto.getRandomValues(arr);\n    return Buffer.from(arr);\n}\nasync function sha512(msg) {\n    if (subtle) {\n        const hash = await subtle.digest(\"SHA-512\", msg);\n        const result = new Uint8Array(hash);\n        return result;\n    }\n    const hash = crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash(\"sha512\");\n    const result = hash.update(msg).digest();\n    return new Uint8Array(result);\n}\nfunction getAes(op) {\n    return async function(iv, key, data) {\n        if (subtle) {\n            const importAlgorithm = {\n                name: \"AES-CBC\"\n            };\n            const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [\n                op\n            ]);\n            const encAlgorithm = {\n                name: \"AES-CBC\",\n                iv\n            };\n            const result = await subtle[op](encAlgorithm, cryptoKey, data);\n            return Buffer.from(new Uint8Array(result));\n        } else if (op === \"encrypt\") {\n            const cipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createCipheriv(\"aes-256-cbc\", key, iv);\n            const firstChunk = cipher.update(data);\n            const secondChunk = cipher.final();\n            return Buffer.concat([\n                firstChunk,\n                secondChunk\n            ]);\n        } else if (op === \"decrypt\") {\n            const decipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createDecipheriv(\"aes-256-cbc\", key, iv);\n            const firstChunk = decipher.update(data);\n            const secondChunk = decipher.final();\n            return Buffer.concat([\n                firstChunk,\n                secondChunk\n            ]);\n        }\n        throw new Error(`Unsupported operation: ${op}`);\n    };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n    if (subtle) {\n        const importAlgorithm = {\n            name: \"HMAC\",\n            hash: {\n                name: \"SHA-256\"\n            }\n        };\n        const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\n            \"sign\",\n            \"verify\"\n        ]);\n        const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n        const result = Buffer.from(new Uint8Array(sig));\n        return result;\n    }\n    const hmac = crypto__WEBPACK_IMPORTED_MODULE_0___default().createHmac(\"sha256\", Buffer.from(key));\n    hmac.update(msg);\n    const result = hmac.digest();\n    return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n    const expectedSig = await hmacSha256Sign(key, msg);\n    return equalConstTime(expectedSig, sig);\n}\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n */ const generatePrivate = function() {\n    let privateKey = randomBytes(32);\n    while(!isValidPrivateKey(privateKey)){\n        privateKey = randomBytes(32);\n    }\n    return privateKey;\n};\nconst getPublic = function(privateKey) {\n    // This function has sync API so we throw an error immediately.\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    // XXX(Kagami): `elliptic.utils.encode` returns array for every\n    // encoding except `hex`.\n    return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"array\"));\n};\n/**\n * Get compressed version of public key.\n */ const getPublicCompressed = function(privateKey) {\n    // jshint ignore:line\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    // See https://github.com/wanderer/secp256k1-node/issues/46\n    const compressed = true;\n    return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"array\"));\n};\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nconst sign = async function(privateKey, msg) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    return Buffer.from(ec.sign(msg, privateKey, {\n        canonical: true\n    }).toDER());\n};\nconst verify = async function(publicKey, msg, sig) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n    if (publicKey.length === 65) {\n        assert(publicKey[0] === 4, \"Bad public key\");\n    }\n    if (publicKey.length === 33) {\n        assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    if (ec.verify(msg, sig, publicKey)) {\n        return null;\n    }\n    throw new Error(\"Bad signature\");\n};\nconst derive = async function(privateKeyA, publicKeyB) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65) {\n        assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33) {\n        assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    const keyA = ec.keyFromPrivate(privateKeyA);\n    const keyB = ec.keyFromPublic(publicKeyB);\n    const Px = keyA.derive(keyB.getPublic()); // BN instance\n    return Buffer.from(Px.toArray());\n};\nconst deriveUnpadded = derive;\nconst derivePadded = async function(privateKeyA, publicKeyB) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65) {\n        assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33) {\n        assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    const keyA = ec.keyFromPrivate(privateKeyA);\n    const keyB = ec.keyFromPublic(publicKeyB);\n    const Px = keyA.derive(keyB.getPublic()); // BN instance\n    return Buffer.from(Px.toString(16, 64), \"hex\");\n};\nconst encrypt = async function(publicKeyTo, msg, opts) {\n    opts = opts || {};\n    let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    // There is a very unlikely possibility that it is not a valid key\n    while(!isValidPrivateKey(ephemPrivateKey)){\n        ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n    const ephemPublicKey = getPublic(ephemPrivateKey);\n    const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n    const hash = await sha512(Px);\n    const iv = opts.iv || randomBytes(16);\n    const encryptionKey = hash.slice(0, 32);\n    const macKey = hash.slice(32);\n    const data = await aesCbcEncrypt(iv, Buffer.from(encryptionKey), msg);\n    const ciphertext = data;\n    const dataToMac = Buffer.concat([\n        iv,\n        ephemPublicKey,\n        ciphertext\n    ]);\n    const mac = await hmacSha256Sign(Buffer.from(macKey), dataToMac);\n    return {\n        iv,\n        ephemPublicKey,\n        ciphertext,\n        mac\n    };\n};\nconst decrypt = async function(privateKey, opts, _padding) {\n    const padding = _padding !== null && _padding !== void 0 ? _padding : false;\n    const deriveLocal = padding ? derivePadded : deriveUnpadded;\n    const Px = await deriveLocal(privateKey, opts.ephemPublicKey);\n    const hash = await sha512(Px);\n    const encryptionKey = hash.slice(0, 32);\n    const macKey = hash.slice(32);\n    const dataToMac = Buffer.concat([\n        opts.iv,\n        opts.ephemPublicKey,\n        opts.ciphertext\n    ]);\n    const macGood = await hmacSha256Verify(Buffer.from(macKey), dataToMac, opts.mac);\n    if (!macGood && padding === false) {\n        return decrypt(privateKey, opts, true);\n    } else if (!macGood && padding === true) {\n        throw new Error(\"bad MAC after trying padded\");\n    }\n    const msg = await aesCbcDecrypt(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);\n    return Buffer.from(new Uint8Array(msg));\n};\n //# sourceMappingURL=eccrypto.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9lY2NyeXB0by9kaXN0L2VjY3J5cHRvLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFnQztBQUNNO0FBRXRDLE1BQU1DLEtBQUssSUFBSUMsd0NBQUlBLENBQUM7QUFDcEIsOERBQThEO0FBQzlELE1BQU1DLGdCQUFnQkMsT0FBT0MsTUFBTSxJQUFJRCxPQUFPRSxRQUFRLElBQUksQ0FBQztBQUMzRCw4REFBOEQ7QUFDOUQsTUFBTUMsU0FBU0osY0FBY0ksTUFBTSxJQUFJSixjQUFjSyxZQUFZO0FBQ2pFLE1BQU1DLGlCQUFpQkMsT0FBT0MsSUFBSSxDQUFDLG9FQUFvRTtBQUN2RyxNQUFNQyxTQUFTRixPQUFPRyxLQUFLLENBQUMsSUFBSTtBQUNoQyxTQUFTQyxPQUFPQyxTQUFTLEVBQUVDLE9BQU87SUFDaEMsSUFBSSxDQUFDRCxXQUFXO1FBQ2QsTUFBTSxJQUFJRSxNQUFNRCxXQUFXO0lBQzdCO0FBQ0Y7QUFDQSxTQUFTRSxTQUFTQyxDQUFDO0lBQ2pCLE9BQU9ULE9BQU9VLFFBQVEsQ0FBQ0QsTUFBTUEsRUFBRUUsTUFBTSxLQUFLO0FBQzVDO0FBQ0EsU0FBU0Msa0JBQWtCQyxVQUFVO0lBQ25DLElBQUksQ0FBQ0wsU0FBU0ssYUFBYTtRQUN6QixPQUFPO0lBQ1Q7SUFDQSxPQUFPQSxXQUFXQyxPQUFPLENBQUNaLFVBQVUsS0FDcEMsTUFBTTtJQUNOVyxXQUFXQyxPQUFPLENBQUNmLGtCQUFrQixHQUFHLE1BQU07QUFDaEQ7QUFFQSxrRUFBa0U7QUFDbEUsU0FBU2dCLGVBQWVDLEVBQUUsRUFBRUMsRUFBRTtJQUM1QixJQUFJRCxHQUFHTCxNQUFNLEtBQUtNLEdBQUdOLE1BQU0sRUFBRTtRQUMzQixPQUFPO0lBQ1Q7SUFDQSxJQUFJTyxNQUFNO0lBQ1YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILEdBQUdMLE1BQU0sRUFBRVEsSUFBSztRQUNsQ0QsT0FBT0YsRUFBRSxD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VSxnQkFBZ0J6RCxLQUFLMEQsS0FBSyxDQUFDLEdBQUc7SUFDcEMsTUFBTUMsU0FBUzNELEtBQUswRCxLQUFLLENBQUM7SUFDMUIsTUFBTUcsWUFBWXhGLE9BQU8rQyxNQUFNLENBQUM7UUFBQ2tDLEtBQUsvQyxFQUFFO1FBQUUrQyxLQUFLRSxjQUFjO1FBQUVGLEtBQUtNLFVBQVU7S0FBQztJQUMvRSxNQUFNTyxVQUFVLE1BQU1yQyxpQkFBaUJ6RCxPQUFPQyxJQUFJLENBQUNxRixTQUFTRSxXQUFXUCxLQUFLUSxHQUFHO0lBQy9FLElBQUksQ0FBQ0ssV0FBV0YsWUFBWSxPQUFPO1FBQ2pDLE9BQU9GLFFBQVE3RSxZQUFZb0UsTUFBTTtJQUNuQyxPQUFPLElBQUksQ0FBQ2EsV0FBV0YsWUFBWSxNQUFNO1FBQ3ZDLE1BQU0sSUFBSXJGLE1BQU07SUFDbEI7SUFDQSxNQUFNbUIsTUFBTSxNQUFNeUIsY0FBYzhCLEtBQUsvQyxFQUFFLEVBQUVsQyxPQUFPQyxJQUFJLENBQUNtRixnQkFBZ0JILEtBQUtNLFVBQVU7SUFDcEYsT0FBT3ZGLE9BQU9DLElBQUksQ0FBQyxJQUFJc0IsV0FBV0c7QUFDcEM7QUFFaUksQ0FDakksd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29sLXBvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9lY2NyeXB0by9kaXN0L2VjY3J5cHRvLmVzbS5qcz9mNTNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBub2RlQ3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBlYyBhcyBlYyQxIH0gZnJvbSAnZWxsaXB0aWMnO1xuXG5jb25zdCBlYyA9IG5ldyBlYyQxKFwic2VjcDI1NmsxXCIpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGJyb3dzZXJDcnlwdG8gPSBnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0byB8fCB7fTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBzdWJ0bGUgPSBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fCBicm93c2VyQ3J5cHRvLndlYmtpdFN1YnRsZTtcbmNvbnN0IEVDX0dST1VQX09SREVSID0gQnVmZmVyLmZyb20oXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxXCIsIFwiaGV4XCIpO1xuY29uc3QgWkVSTzMyID0gQnVmZmVyLmFsbG9jKDMyLCAwKTtcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCBcIkFzc2VydGlvbiBmYWlsZWRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzU2NhbGFyKHgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcih4KSAmJiB4Lmxlbmd0aCA9PT0gMzI7XG59XG5mdW5jdGlvbiBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gIGlmICghaXNTY2FsYXIocHJpdmF0ZUtleSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHByaXZhdGVLZXkuY29tcGFyZShaRVJPMzIpID4gMCAmJlxuICAvLyA+IDBcbiAgcHJpdmF0ZUtleS5jb21wYXJlKEVDX0dST1VQX09SREVSKSA8IDA7IC8vIDwgR1xufVxuXG4vLyBDb21wYXJlIHR3byBidWZmZXJzIGluIGNvbnN0YW50IHRpbWUgdG8gcHJldmVudCB0aW1pbmcgYXR0YWNrcy5cbmZ1bmN0aW9uIGVxdWFsQ29uc3RUaW1lKGIxLCBiMikge1xuICBpZiAoYjEubGVuZ3RoICE9PSBiMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IHJlcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspIHtcbiAgICByZXMgfD0gYjFbaV0gXiBiMltpXTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIH1cblxuICByZXR1cm4gcmVzID09PSAwO1xufVxuXG4vKiBUaGlzIG11c3QgY2hlY2sgaWYgd2UncmUgaW4gdGhlIGJyb3dzZXIgb3Jcbm5vdCwgc2luY2UgdGhlIGZ1bmN0aW9ucyBhcmUgZGlmZmVyZW50IGFuZCBkb2VzXG5ub3QgY29udmVydCB1c2luZyBicm93c2VyaWZ5ICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhzaXplKSB7XG4gIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICBpZiAodHlwZW9mIGJyb3dzZXJDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5vZGVDcnlwdG8ucmFuZG9tQnl0ZXMoc2l6ZSkpO1xuICB9XG4gIGJyb3dzZXJDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gIHJldHVybiBCdWZmZXIuZnJvbShhcnIpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2hhNTEyKG1zZykge1xuICBpZiAoc3VidGxlKSB7XG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IHN1YnRsZS5kaWdlc3QoXCJTSEEtNTEyXCIsIG1zZyk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGFzaCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25zdCBoYXNoID0gbm9kZUNyeXB0by5jcmVhdGVIYXNoKFwic2hhNTEyXCIpO1xuICBjb25zdCByZXN1bHQgPSBoYXNoLnVwZGF0ZShtc2cpLmRpZ2VzdCgpO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbn1cbmZ1bmN0aW9uIGdldEFlcyhvcCkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKGl2LCBrZXksIGRhdGEpIHtcbiAgICBpZiAoc3VidGxlKSB7XG4gICAgICBjb25zdCBpbXBvcnRBbGdvcml0aG0gPSB7XG4gICAgICAgIG5hbWU6IFwiQUVTLUNCQ1wiXG4gICAgICB9O1xuICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBrZXksIGltcG9ydEFsZ29yaXRobSwgZmFsc2UsIFtvcF0pO1xuICAgICAgY29uc3QgZW5jQWxnb3JpdGhtID0ge1xuICAgICAgICBuYW1lOiBcIkFFUy1DQkNcIixcbiAgICAgICAgaXZcbiAgICAgIH07XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdWJ0bGVbb3BdKGVuY0FsZ29yaXRobSwgY3J5cHRvS2V5LCBkYXRhKTtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcbiAgICB9IGVsc2UgaWYgKG9wID09PSBcImVuY3J5cHRcIikge1xuICAgICAgY29uc3QgY2lwaGVyID0gbm9kZUNyeXB0by5jcmVhdGVDaXBoZXJpdihcImFlcy0yNTYtY2JjXCIsIGtleSwgaXYpO1xuICAgICAgY29uc3QgZmlyc3RDaHVuayA9IGNpcGhlci51cGRhdGUoZGF0YSk7XG4gICAgICBjb25zdCBzZWNvbmRDaHVuayA9IGNpcGhlci5maW5hbCgpO1xuICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2ZpcnN0Q2h1bmssIHNlY29uZENodW5rXSk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gXCJkZWNyeXB0XCIpIHtcbiAgICAgIGNvbnN0IGRlY2lwaGVyID0gbm9kZUNyeXB0by5jcmVhdGVEZWNpcGhlcml2KFwiYWVzLTI1Ni1jYmNcIiwga2V5LCBpdik7XG4gICAgICBjb25zdCBmaXJzdENodW5rID0gZGVjaXBoZXIudXBkYXRlKGRhdGEpO1xuICAgICAgY29uc3Qgc2Vjb25kQ2h1bmsgPSBkZWNpcGhlci5maW5hbCgpO1xuICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2ZpcnN0Q2h1bmssIHNlY29uZENodW5rXSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgb3BlcmF0aW9uOiAke29wfWApO1xuICB9O1xufVxuY29uc3QgYWVzQ2JjRW5jcnlwdCA9IGdldEFlcyhcImVuY3J5cHRcIik7XG5jb25zdCBhZXNDYmNEZWNyeXB0ID0gZ2V0QWVzKFwiZGVjcnlwdFwiKTtcbmFzeW5jIGZ1bmN0aW9uIGhtYWNTaGEyNTZTaWduKGtleSwgbXNnKSB7XG4gIGlmIChzdWJ0bGUpIHtcbiAgICBjb25zdCBpbXBvcnRBbGdvcml0aG0gPSB7XG4gICAgICBuYW1lOiBcIkhNQUNcIixcbiAgICAgIGhhc2g6IHtcbiAgICAgICAgbmFtZTogXCJTSEEtMjU2XCJcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IHN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgbmV3IFVpbnQ4QXJyYXkoa2V5KSwgaW1wb3J0QWxnb3JpdGhtLCBmYWxzZSwgW1wic2lnblwiLCBcInZlcmlmeVwiXSk7XG4gICAgY29uc3Qgc2lnID0gYXdhaXQgc3VidGxlLnNpZ24oXCJITUFDXCIsIGNyeXB0b0tleSwgbXNnKTtcbiAgICBjb25zdCByZXN1bHQgPSBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShzaWcpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbnN0IGhtYWMgPSBub2RlQ3J5cHRvLmNyZWF0ZUhtYWMoXCJzaGEyNTZcIiwgQnVmZmVyLmZyb20oa2V5KSk7XG4gIGhtYWMudXBkYXRlKG1zZyk7XG4gIGNvbnN0IHJlc3VsdCA9IGhtYWMuZGlnZXN0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5hc3luYyBmdW5jdGlvbiBobWFjU2hhMjU2VmVyaWZ5KGtleSwgbXNnLCBzaWcpIHtcbiAgY29uc3QgZXhwZWN0ZWRTaWcgPSBhd2FpdCBobWFjU2hhMjU2U2lnbihrZXksIG1zZyk7XG4gIHJldHVybiBlcXVhbENvbnN0VGltZShleHBlY3RlZFNpZywgc2lnKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG5ldyB2YWxpZCBwcml2YXRlIGtleS4gV2lsbCB1c2UgdGhlIHdpbmRvdy5jcnlwdG8gb3Igd2luZG93Lm1zQ3J5cHRvIGFzIHNvdXJjZVxuICogZGVwZW5kaW5nIG9uIHlvdXIgYnJvd3Nlci5cbiAqL1xuY29uc3QgZ2VuZXJhdGVQcml2YXRlID0gZnVuY3Rpb24gKCkge1xuICBsZXQgcHJpdmF0ZUtleSA9IHJhbmRvbUJ5dGVzKDMyKTtcbiAgd2hpbGUgKCFpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSkge1xuICAgIHByaXZhdGVLZXkgPSByYW5kb21CeXRlcygzMik7XG4gIH1cbiAgcmV0dXJuIHByaXZhdGVLZXk7XG59O1xuY29uc3QgZ2V0UHVibGljID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgc3luYyBBUEkgc28gd2UgdGhyb3cgYW4gZXJyb3IgaW1tZWRpYXRlbHkuXG4gIGFzc2VydChwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIsIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICAvLyBYWFgoS2FnYW1pKTogYGVsbGlwdGljLnV0aWxzLmVuY29kZWAgcmV0dXJucyBhcnJheSBmb3IgZXZlcnlcbiAgLy8gZW5jb2RpbmcgZXhjZXB0IGBoZXhgLlxuICByZXR1cm4gQnVmZmVyLmZyb20oZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleSkuZ2V0UHVibGljKFwiYXJyYXlcIikpO1xufTtcblxuLyoqXG4gKiBHZXQgY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHB1YmxpYyBrZXkuXG4gKi9cbmNvbnN0IGdldFB1YmxpY0NvbXByZXNzZWQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2FuZGVyZXIvc2VjcDI1NmsxLW5vZGUvaXNzdWVzLzQ2XG4gIGNvbnN0IGNvbXByZXNzZWQgPSB0cnVlO1xuICByZXR1cm4gQnVmZmVyLmZyb20oZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleSkuZ2V0UHVibGljKGNvbXByZXNzZWQsIFwiYXJyYXlcIikpO1xufTtcblxuLy8gTk9URShLYWdhbWkpOiBXZSBkb24ndCB1c2UgcHJvbWlzZSBzaGltIGluIEJyb3dzZXIgaW1wbGVtZW50YXRpb25cbi8vIGJlY2F1c2UgaXQncyBzdXBwb3J0ZWQgbmF0aXZlbHkgaW4gbmV3IGJyb3dzZXJzIChzZWVcbi8vIDxodHRwOi8vY2FuaXVzZS5jb20vI2ZlYXQ9cHJvbWlzZXM+KSBhbmQgd2UgY2FuIHVzZSBvbmx5IG5ldyBicm93c2Vyc1xuLy8gYmVjYXVzZSBvZiB0aGUgV2ViQ3J5cHRvQVBJIChzZWVcbi8vIDxodHRwOi8vY2FuaXVzZS5jb20vI2ZlYXQ9Y3J5cHRvZ3JhcGh5PikuXG5jb25zdCBzaWduID0gYXN5bmMgZnVuY3Rpb24gKHByaXZhdGVLZXksIG1zZykge1xuICBhc3NlcnQocHJpdmF0ZUtleS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KG1zZy5sZW5ndGggPiAwLCBcIk1lc3NhZ2Ugc2hvdWxkIG5vdCBiZSBlbXB0eVwiKTtcbiAgYXNzZXJ0KG1zZy5sZW5ndGggPD0gMzIsIFwiTWVzc2FnZSBpcyB0b28gbG9uZ1wiKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVjLnNpZ24obXNnLCBwcml2YXRlS2V5LCB7XG4gICAgY2Fub25pY2FsOiB0cnVlXG4gIH0pLnRvREVSKCkpO1xufTtcbmNvbnN0IHZlcmlmeSA9IGFzeW5jIGZ1bmN0aW9uIChwdWJsaWNLZXksIG1zZywgc2lnKSB7XG4gIGFzc2VydChwdWJsaWNLZXkubGVuZ3RoID09PSA2NSB8fCBwdWJsaWNLZXkubGVuZ3RoID09PSAzMywgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDY1KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleVswXSA9PT0gNCwgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gMzMpIHtcbiAgICBhc3NlcnQocHVibGljS2V5WzBdID09PSAyIHx8IHB1YmxpY0tleVswXSA9PT0gMywgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgfVxuICBhc3NlcnQobXNnLmxlbmd0aCA+IDAsIFwiTWVzc2FnZSBzaG91bGQgbm90IGJlIGVtcHR5XCIpO1xuICBhc3NlcnQobXNnLmxlbmd0aCA8PSAzMiwgXCJNZXNzYWdlIGlzIHRvbyBsb25nXCIpO1xuICBpZiAoZWMudmVyaWZ5KG1zZywgc2lnLCBwdWJsaWNLZXkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIHNpZ25hdHVyZVwiKTtcbn07XG5jb25zdCBkZXJpdmUgPSBhc3luYyBmdW5jdGlvbiAocHJpdmF0ZUtleUEsIHB1YmxpY0tleUIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihwcml2YXRlS2V5QSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKHB1YmxpY0tleUIpLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICBhc3NlcnQocHJpdmF0ZUtleUEubGVuZ3RoID09PSAzMiwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5QSksIFwiQmFkIHByaXZhdGUga2V5XCIpO1xuICBhc3NlcnQocHVibGljS2V5Qi5sZW5ndGggPT09IDY1IHx8IHB1YmxpY0tleUIubGVuZ3RoID09PSAzMywgXCJCYWQgcHVibGljIGtleVwiKTtcbiAgaWYgKHB1YmxpY0tleUIubGVuZ3RoID09PSA2NSkge1xuICAgIGFzc2VydChwdWJsaWNLZXlCWzBdID09PSA0LCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGlmIChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gMzMpIHtcbiAgICBhc3NlcnQocHVibGljS2V5QlswXSA9PT0gMiB8fCBwdWJsaWNLZXlCWzBdID09PSAzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICB9XG4gIGNvbnN0IGtleUEgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5QSk7XG4gIGNvbnN0IGtleUIgPSBlYy5rZXlGcm9tUHVibGljKHB1YmxpY0tleUIpO1xuICBjb25zdCBQeCA9IGtleUEuZGVyaXZlKGtleUIuZ2V0UHVibGljKCkpOyAvLyBCTiBpbnN0YW5jZVxuICByZXR1cm4gQnVmZmVyLmZyb20oUHgudG9BcnJheSgpKTtcbn07XG5jb25zdCBkZXJpdmVVbnBhZGRlZCA9IGRlcml2ZTtcbmNvbnN0IGRlcml2ZVBhZGRlZCA9IGFzeW5jIGZ1bmN0aW9uIChwcml2YXRlS2V5QSwgcHVibGljS2V5Qikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKHByaXZhdGVLZXlBKSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChCdWZmZXIuaXNCdWZmZXIocHVibGljS2V5QiksIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIGFzc2VydChwcml2YXRlS2V5QS5sZW5ndGggPT09IDMyLCBcIkJhZCBwcml2YXRlIGtleVwiKTtcbiAgYXNzZXJ0KGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXlBKSwgXCJCYWQgcHJpdmF0ZSBrZXlcIik7XG4gIGFzc2VydChwdWJsaWNLZXlCLmxlbmd0aCA9PT0gNjUgfHwgcHVibGljS2V5Qi5sZW5ndGggPT09IDMzLCBcIkJhZCBwdWJsaWMga2V5XCIpO1xuICBpZiAocHVibGljS2V5Qi5sZW5ndGggPT09IDY1KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleUJbMF0gPT09IDQsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgaWYgKHB1YmxpY0tleUIubGVuZ3RoID09PSAzMykge1xuICAgIGFzc2VydChwdWJsaWNLZXlCWzBdID09PSAyIHx8IHB1YmxpY0tleUJbMF0gPT09IDMsIFwiQmFkIHB1YmxpYyBrZXlcIik7XG4gIH1cbiAgY29uc3Qga2V5QSA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXlBKTtcbiAgY29uc3Qga2V5QiA9IGVjLmtleUZyb21QdWJsaWMocHVibGljS2V5Qik7XG4gIGNvbnN0IFB4ID0ga2V5QS5kZXJpdmUoa2V5Qi5nZXRQdWJsaWMoKSk7IC8vIEJOIGluc3RhbmNlXG4gIHJldHVybiBCdWZmZXIuZnJvbShQeC50b1N0cmluZygxNiwgNjQpLCBcImhleFwiKTtcbn07XG5jb25zdCBlbmNyeXB0ID0gYXN5bmMgZnVuY3Rpb24gKHB1YmxpY0tleVRvLCBtc2csIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIGxldCBlcGhlbVByaXZhdGVLZXkgPSBvcHRzLmVwaGVtUHJpdmF0ZUtleSB8fCByYW5kb21CeXRlcygzMik7XG4gIC8vIFRoZXJlIGlzIGEgdmVyeSB1bmxpa2VseSBwb3NzaWJpbGl0eSB0aGF0IGl0IGlzIG5vdCBhIHZhbGlkIGtleVxuICB3aGlsZSAoIWlzVmFsaWRQcml2YXRlS2V5KGVwaGVtUHJpdmF0ZUtleSkpIHtcbiAgICBlcGhlbVByaXZhdGVLZXkgPSBvcHRzLmVwaGVtUHJpdmF0ZUtleSB8fCByYW5kb21CeXRlcygzMik7XG4gIH1cbiAgY29uc3QgZXBoZW1QdWJsaWNLZXkgPSBnZXRQdWJsaWMoZXBoZW1Qcml2YXRlS2V5KTtcbiAgY29uc3QgUHggPSBhd2FpdCBkZXJpdmVVbnBhZGRlZChlcGhlbVByaXZhdGVLZXksIHB1YmxpY0tleVRvKTtcbiAgY29uc3QgaGFzaCA9IGF3YWl0IHNoYTUxMihQeCk7XG4gIGNvbnN0IGl2ID0gb3B0cy5pdiB8fCByYW5kb21CeXRlcygxNik7XG4gIGNvbnN0IGVuY3J5cHRpb25LZXkgPSBoYXNoLnNsaWNlKDAsIDMyKTtcbiAgY29uc3QgbWFjS2V5ID0gaGFzaC5zbGljZSgzMik7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBhZXNDYmNFbmNyeXB0KGl2LCBCdWZmZXIuZnJvbShlbmNyeXB0aW9uS2V5KSwgbXNnKTtcbiAgY29uc3QgY2lwaGVydGV4dCA9IGRhdGE7XG4gIGNvbnN0IGRhdGFUb01hYyA9IEJ1ZmZlci5jb25jYXQoW2l2LCBlcGhlbVB1YmxpY0tleSwgY2lwaGVydGV4dF0pO1xuICBjb25zdCBtYWMgPSBhd2FpdCBobWFjU2hhMjU2U2lnbihCdWZmZXIuZnJvbShtYWNLZXkpLCBkYXRhVG9NYWMpO1xuICByZXR1cm4ge1xuICAgIGl2LFxuICAgIGVwaGVtUHVibGljS2V5LFxuICAgIGNpcGhlcnRleHQsXG4gICAgbWFjXG4gIH07XG59O1xuY29uc3QgZGVjcnlwdCA9IGFzeW5jIGZ1bmN0aW9uIChwcml2YXRlS2V5LCBvcHRzLCBfcGFkZGluZykge1xuICBjb25zdCBwYWRkaW5nID0gX3BhZGRpbmcgIT09IG51bGwgJiYgX3BhZGRpbmcgIT09IHZvaWQgMCA/IF9wYWRkaW5nIDogZmFsc2U7XG4gIGNvbnN0IGRlcml2ZUxvY2FsID0gcGFkZGluZyA/IGRlcml2ZVBhZGRlZCA6IGRlcml2ZVVucGFkZGVkO1xuICBjb25zdCBQeCA9IGF3YWl0IGRlcml2ZUxvY2FsKHByaXZhdGVLZXksIG9wdHMuZXBoZW1QdWJsaWNLZXkpO1xuICBjb25zdCBoYXNoID0gYXdhaXQgc2hhNTEyKFB4KTtcbiAgY29uc3QgZW5jcnlwdGlvbktleSA9IGhhc2guc2xpY2UoMCwgMzIpO1xuICBjb25zdCBtYWNLZXkgPSBoYXNoLnNsaWNlKDMyKTtcbiAgY29uc3QgZGF0YVRvTWFjID0gQnVmZmVyLmNvbmNhdChbb3B0cy5pdiwgb3B0cy5lcGhlbVB1YmxpY0tleSwgb3B0cy5jaXBoZXJ0ZXh0XSk7XG4gIGNvbnN0IG1hY0dvb2QgPSBhd2FpdCBobWFjU2hhMjU2VmVyaWZ5KEJ1ZmZlci5mcm9tKG1hY0tleSksIGRhdGFUb01hYywgb3B0cy5tYWMpO1xuICBpZiAoIW1hY0dvb2QgJiYgcGFkZGluZyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZGVjcnlwdChwcml2YXRlS2V5LCBvcHRzLCB0cnVlKTtcbiAgfSBlbHNlIGlmICghbWFjR29vZCAmJiBwYWRkaW5nID09PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIE1BQyBhZnRlciB0cnlpbmcgcGFkZGVkXCIpO1xuICB9XG4gIGNvbnN0IG1zZyA9IGF3YWl0IGFlc0NiY0RlY3J5cHQob3B0cy5pdiwgQnVmZmVyLmZyb20oZW5jcnlwdGlvbktleSksIG9wdHMuY2lwaGVydGV4dCk7XG4gIHJldHVybiBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShtc2cpKTtcbn07XG5cbmV4cG9ydCB7IGRlY3J5cHQsIGRlcml2ZSwgZGVyaXZlUGFkZGVkLCBkZXJpdmVVbnBhZGRlZCwgZW5jcnlwdCwgZ2VuZXJhdGVQcml2YXRlLCBnZXRQdWJsaWMsIGdldFB1YmxpY0NvbXByZXNzZWQsIHNpZ24sIHZlcmlmeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWNjcnlwdG8uZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIm5vZGVDcnlwdG8iLCJlYyIsImVjJDEiLCJicm93c2VyQ3J5cHRvIiwiZ2xvYmFsIiwiY3J5cHRvIiwibXNDcnlwdG8iLCJzdWJ0bGUiLCJ3ZWJraXRTdWJ0bGUiLCJFQ19HUk9VUF9PUkRFUiIsIkJ1ZmZlciIsImZyb20iLCJaRVJPMzIiLCJhbGxvYyIsImFzc2VydCIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJFcnJvciIsImlzU2NhbGFyIiwieCIsImlzQnVmZmVyIiwibGVuZ3RoIiwiaXNWYWxpZFByaXZhdGVLZXkiLCJwcml2YXRlS2V5IiwiY29tcGFyZSIsImVxdWFsQ29uc3RUaW1lIiwiYjEiLCJiMiIsInJlcyIsImkiLCJyYW5kb21CeXRlcyIsInNpemUiLCJhcnIiLCJVaW50OEFycmF5IiwiZ2V0UmFuZG9tVmFsdWVzIiwic2hhNTEyIiwibXNnIiwiaGFzaCIsImRpZ2VzdCIsInJlc3VsdCIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJnZXRBZXMiLCJvcCIsIml2Iiwia2V5IiwiZGF0YSIsImltcG9ydEFsZ29yaXRobSIsIm5hbWUiLCJjcnlwdG9LZXkiLCJpbXBvcnRLZXkiLCJlbmNBbGdvcml0aG0iLCJjaXBoZXIiLCJjcmVhdGVDaXBoZXJpdiIsImZpcnN0Q2h1bmsiLCJzZWNvbmRDaHVuayIsImZpbmFsIiwiY29uY2F0IiwiZGVjaXBoZXIiLCJjcmVhdGVEZWNpcGhlcml2IiwiYWVzQ2JjRW5jcnlwdCIsImFlc0NiY0RlY3J5cHQiLCJobWFjU2hhMjU2U2lnbiIsInNpZyIsInNpZ24iLCJobWFjIiwiY3JlYXRlSG1hYyIsImhtYWNTaGEyNTZWZXJpZnkiLCJleHBlY3RlZFNpZyIsImdlbmVyYXRlUHJpdmF0ZSIsImdldFB1YmxpYyIsImtleUZyb21Qcml2YXRlIiwiZ2V0UHVibGljQ29tcHJlc3NlZCIsImNvbXByZXNzZWQiLCJjYW5vbmljYWwiLCJ0b0RFUiIsInZlcmlmeSIsInB1YmxpY0tleSIsImRlcml2ZSIsInByaXZhdGVLZXlBIiwicHVibGljS2V5QiIsImtleUEiLCJrZXlCIiwia2V5RnJvbVB1YmxpYyIsIlB4IiwidG9BcnJheSIsImRlcml2ZVVucGFkZGVkIiwiZGVyaXZlUGFkZGVkIiwidG9TdHJpbmciLCJlbmNyeXB0IiwicHVibGljS2V5VG8iLCJvcHRzIiwiZXBoZW1Qcml2YXRlS2V5IiwiZXBoZW1QdWJsaWNLZXkiLCJlbmNyeXB0aW9uS2V5Iiwic2xpY2UiLCJtYWNLZXkiLCJjaXBoZXJ0ZXh0IiwiZGF0YVRvTWFjIiwibWFjIiwiZGVjcnlwdCIsIl9wYWRkaW5nIiwicGFkZGluZyIsImRlcml2ZUxvY2FsIiwibWFjR29vZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearAPIKey: () => (/* binding */ clearAPIKey),\n/* harmony export */   clearEmbedHost: () => (/* binding */ clearEmbedHost),\n/* harmony export */   enableSentryTracing: () => (/* binding */ enableSentryTracing),\n/* harmony export */   gatewayAuthHeader: () => (/* binding */ gatewayAuthHeader),\n/* harmony export */   gatewayEmbedHostHeader: () => (/* binding */ gatewayEmbedHostHeader),\n/* harmony export */   generateJsonRPCObject: () => (/* binding */ generateJsonRPCObject),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getAPIKey: () => (/* binding */ getAPIKey),\n/* harmony export */   getEmbedHost: () => (/* binding */ getEmbedHost),\n/* harmony export */   patch: () => (/* binding */ patch),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   promiseRace: () => (/* binding */ promiseRace),\n/* harmony export */   promiseTimeout: () => (/* binding */ promiseTimeout),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   setAPIKey: () => (/* binding */ setAPIKey),\n/* harmony export */   setEmbedHost: () => (/* binding */ setEmbedHost),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.merge */ \"(ssr)/./node_modules/lodash.merge/index.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst log = loglevel__WEBPACK_IMPORTED_MODULE_2___default().getLogger(\"http-helpers\");\nlog.setLevel(loglevel__WEBPACK_IMPORTED_MODULE_2__.levels.INFO);\nlet apiKey = \"torus-default\";\nlet embedHost = \"\";\n// #region API Keys\nconst gatewayAuthHeader = \"x-api-key\";\nconst gatewayEmbedHostHeader = \"x-embed-host\";\nlet sentry = null;\nconst tracingOrigins = [];\nconst tracingPaths = [];\nfunction enableSentryTracing(_sentry, _tracingOrigins, _tracingPaths) {\n    sentry = _sentry;\n    tracingOrigins.push(..._tracingOrigins);\n    tracingPaths.push(..._tracingPaths);\n}\nfunction setEmbedHost(embedHost_) {\n    embedHost = embedHost_;\n}\nfunction clearEmbedHost() {\n    embedHost = \"\";\n}\nfunction getEmbedHost() {\n    return embedHost;\n}\nfunction setAPIKey(apiKey_) {\n    apiKey = apiKey_;\n}\nfunction clearAPIKey() {\n    apiKey = \"torus-default\";\n}\nfunction getAPIKey() {\n    return apiKey;\n}\n// #endregion\nfunction setLogLevel(level) {\n    log.setLevel(level);\n}\nasync function fetchAndTrace(url, init) {\n    let _url = null;\n    try {\n        _url = new URL(url);\n    } catch (error) {}\n    if (sentry && _url && (tracingOrigins.includes(_url.origin) || tracingPaths.includes(_url.pathname))) {\n        const transaction = sentry.startTransaction({\n            name: url\n        });\n        const span = transaction.startChild({\n            op: \"http\"\n        }); // This function returns a Span\n        const response = await fetch(url, init);\n        span.finish(); // Remember that only finished spans will be sent with the transaction\n        transaction.finish(); // Finishing the transaction will send it to Sentry\n        return response;\n    }\n    return fetch(url, init);\n}\nfunction getApiKeyHeaders() {\n    const headers = {};\n    if (apiKey) headers[gatewayAuthHeader] = apiKey;\n    if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;\n    return headers;\n}\nfunction debugLogResponse(response) {\n    log.info(`Response: ${response.status} ${response.statusText}`);\n    log.info(`Url: ${response.url}`);\n}\nfunction logTracingHeader(response) {\n    const tracingHeader = response.headers.get(\"x-web3-correlation-id\");\n    if (tracingHeader) log.info(`Request tracing with traceID = ${tracingHeader}`);\n}\nconst promiseTimeout = async (ms, promise)=>{\n    let timeoutFunc = null;\n    try {\n        const timeout = new Promise((_resolve, reject)=>{\n            timeoutFunc = setTimeout(()=>{\n                reject(new Error(`Timed out in ${ms}ms`));\n            }, ms);\n        });\n        const result = await Promise.race([\n            promise,\n            timeout\n        ]);\n        // promise.race will return the first resolved promise\n        // then we clear the timeout\n        if (timeoutFunc != null) {\n            clearTimeout(timeoutFunc);\n        }\n        return result;\n    } catch (err) {\n        // clear the timeout\n        if (timeoutFunc != null) {\n            clearTimeout(timeoutFunc);\n        }\n        // rethrow the original error\n        throw err;\n    }\n};\nconst get = async function(url) {\n    let options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {}\n    };\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"GET\"\n    });\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        const responseContentType = response.headers.get(\"content-type\");\n        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst post = function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"POST\"\n    });\n    // deep merge changes the structure of form data and url encoded data ,\n    // so we should not deepmerge body data\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    return promiseTimeout(customOptions.timeout || 60000, fetchAndTrace(url, options).then((response)=>{\n        if (customOptions.logTracingHeader) {\n            logTracingHeader(response);\n        }\n        if (response.ok) {\n            const responseContentType = response.headers.get(\"content-type\");\n            if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n                return response.json();\n            }\n            return response.text();\n        }\n        debugLogResponse(response);\n        throw response;\n    }));\n};\nconst patch = async function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"PATCH\"\n    });\n    // deep merge changes the structure of form data and url encoded data ,\n    // so we should not deepmerge body data\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        const responseContentType = response.headers.get(\"content-type\");\n        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst put = async function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"PUT\"\n    });\n    // deep merge changes the structure of form data and url encoded data ,\n    // so we should not deepmerge body data\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        const responseContentType = response.headers.get(\"content-type\");\n        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst remove = async function(url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n        mode: \"cors\",\n        headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\"\n        }\n    };\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    if (customOptions.useAPIKey) {\n        defaultOptions.headers = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n    const options = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options_, {\n        method: \"DELETE\"\n    });\n    if (customOptions.isUrlEncodedData) {\n        // for multipart request browser/client will add multipart content type\n        // along with multipart boundary , so for multipart request send\n        // content-type: undefined or send with multipart boundary if already known\n        options.body = data;\n        // If url encoded data, this must not be the content type\n        if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n        options.body = JSON.stringify(data);\n    }\n    const response = await fetchAndTrace(url, options);\n    if (response.ok) {\n        const responseContentType = response.headers.get(\"content-type\");\n        if (responseContentType !== null && responseContentType !== void 0 && responseContentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        return response.text();\n    }\n    debugLogResponse(response);\n    throw response;\n};\nconst generateJsonRPCObject = (method, parameters)=>({\n        jsonrpc: \"2.0\",\n        method,\n        id: 10,\n        params: parameters\n    });\nconst promiseRace = function(url, options) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n    return Promise.race([\n        get(url, options),\n        new Promise((_resolve, reject)=>{\n            setTimeout(()=>{\n                reject(new Error(\"timed out\"));\n            }, timeout);\n        })\n    ]);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9odHRwLWhlbHBlcnMvZGlzdC9odHRwSGVscGVycy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlFO0FBQ2hDO0FBQ1c7QUFFNUMsTUFBTUksTUFBTUYseURBQWtCLENBQUM7QUFDL0JFLElBQUlFLFFBQVEsQ0FBQ0gsNENBQU1BLENBQUNJLElBQUk7QUFDeEIsSUFBSUMsU0FBUztBQUNiLElBQUlDLFlBQVk7QUFFaEIsbUJBQW1CO0FBQ25CLE1BQU1DLG9CQUFvQjtBQUMxQixNQUFNQyx5QkFBeUI7QUFDL0IsSUFBSUMsU0FBUztBQUNiLE1BQU1DLGlCQUFpQixFQUFFO0FBQ3pCLE1BQU1DLGVBQWUsRUFBRTtBQUN2QixTQUFTQyxvQkFBb0JDLE9BQU8sRUFBRUMsZUFBZSxFQUFFQyxhQUFhO0lBQ2xFTixTQUFTSTtJQUNUSCxlQUFlTSxJQUFJLElBQUlGO0lBQ3ZCSCxhQUFhSyxJQUFJLElBQUlEO0FBQ3ZCO0FBQ0EsU0FBU0UsYUFBYUMsVUFBVTtJQUM5QlosWUFBWVk7QUFDZDtBQUNBLFNBQVNDO0lBQ1BiLFlBQVk7QUFDZDtBQUNBLFNBQVNjO0lBQ1AsT0FBT2Q7QUFDVDtBQUNBLFNBQVNlLFVBQVVDLE9BQU87SUFDeEJqQixTQUFTaUI7QUFDWDtBQUNBLFNBQVNDO0lBQ1BsQixTQUFTO0FBQ1g7QUFDQSxTQUFTbUI7SUFDUCxPQUFPbkI7QUFDVDtBQUVBLGFBQWE7QUFFYixTQUFTb0IsWUFBWUMsS0FBSztJQUN4QnpCLElBQUlFLFFBQVEsQ0FBQ3VCO0FBQ2Y7QUFDQSxlQUFlQyxjQUFjQyxHQUFHLEVBQUVDLElBQUk7SUFDcEMsSUFBSUMsT0FBTztJQUNYLElBQUk7UUFDRkEsT0FBTyxJQUFJQyxJQUFJSDtJQUNqQixFQUFFLE9BQU9JLE9BQU8sQ0FBQztJQUNqQixJQUFJdkIsVUFBVXFCLFFBQVNwQixDQUFBQSxlQUFldUIsUUFBUSxDQUFDSCxLQUFL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R0FBRyxDQUFDO1FBQ2pELElBQUkwQix3QkFBd0IsUUFBUUEsd0JBQXdCLEtBQUssS0FBS0Esb0JBQW9COUMsUUFBUSxDQUFDLHFCQUFxQjtZQUN0SCxPQUFPUyxTQUFTc0MsSUFBSTtRQUN0QjtRQUNBLE9BQU90QyxTQUFTdUMsSUFBSTtJQUN0QjtJQUNBbEMsaUJBQWlCTDtJQUNqQixNQUFNQTtBQUNSO0FBQ0EsTUFBTWtELHdCQUF3QixDQUFDZixRQUFRZ0IsYUFBZ0I7UUFDckRDLFNBQVM7UUFDVGpCO1FBQ0FrQixJQUFJO1FBQ0pDLFFBQVFIO0lBQ1Y7QUFDQSxNQUFNSSxjQUFjLFNBQVVyRSxHQUFHLEVBQUVnRCxPQUFPO0lBQ3hDLElBQUlsQixVQUFVVyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNsRixPQUFPVixRQUFRTSxJQUFJLENBQUM7UUFBQ1osSUFBSXpCLEtBQUtnRDtRQUFVLElBQUlqQixRQUFRLENBQUNDLFVBQVVDO1lBQzdEQyxXQUFXO2dCQUNURCxPQUFPLElBQUlFLE1BQU07WUFDbkIsR0FBR0w7UUFDTDtLQUFHO0FBQ0w7QUFFeVAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb2wtcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL2h0dHAtaGVscGVycy9kaXN0L2h0dHBIZWxwZXJzLmVzbS5qcz80NjJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMic7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoLm1lcmdlJztcbmltcG9ydCBsb2dMZXZlbCwgeyBsZXZlbHMgfSBmcm9tICdsb2dsZXZlbCc7XG5cbmNvbnN0IGxvZyA9IGxvZ0xldmVsLmdldExvZ2dlcihcImh0dHAtaGVscGVyc1wiKTtcbmxvZy5zZXRMZXZlbChsZXZlbHMuSU5GTyk7XG5sZXQgYXBpS2V5ID0gXCJ0b3J1cy1kZWZhdWx0XCI7XG5sZXQgZW1iZWRIb3N0ID0gXCJcIjtcblxuLy8gI3JlZ2lvbiBBUEkgS2V5c1xuY29uc3QgZ2F0ZXdheUF1dGhIZWFkZXIgPSBcIngtYXBpLWtleVwiO1xuY29uc3QgZ2F0ZXdheUVtYmVkSG9zdEhlYWRlciA9IFwieC1lbWJlZC1ob3N0XCI7XG5sZXQgc2VudHJ5ID0gbnVsbDtcbmNvbnN0IHRyYWNpbmdPcmlnaW5zID0gW107XG5jb25zdCB0cmFjaW5nUGF0aHMgPSBbXTtcbmZ1bmN0aW9uIGVuYWJsZVNlbnRyeVRyYWNpbmcoX3NlbnRyeSwgX3RyYWNpbmdPcmlnaW5zLCBfdHJhY2luZ1BhdGhzKSB7XG4gIHNlbnRyeSA9IF9zZW50cnk7XG4gIHRyYWNpbmdPcmlnaW5zLnB1c2goLi4uX3RyYWNpbmdPcmlnaW5zKTtcbiAgdHJhY2luZ1BhdGhzLnB1c2goLi4uX3RyYWNpbmdQYXRocyk7XG59XG5mdW5jdGlvbiBzZXRFbWJlZEhvc3QoZW1iZWRIb3N0Xykge1xuICBlbWJlZEhvc3QgPSBlbWJlZEhvc3RfO1xufVxuZnVuY3Rpb24gY2xlYXJFbWJlZEhvc3QoKSB7XG4gIGVtYmVkSG9zdCA9IFwiXCI7XG59XG5mdW5jdGlvbiBnZXRFbWJlZEhvc3QoKSB7XG4gIHJldHVybiBlbWJlZEhvc3Q7XG59XG5mdW5jdGlvbiBzZXRBUElLZXkoYXBpS2V5Xykge1xuICBhcGlLZXkgPSBhcGlLZXlfO1xufVxuZnVuY3Rpb24gY2xlYXJBUElLZXkoKSB7XG4gIGFwaUtleSA9IFwidG9ydXMtZGVmYXVsdFwiO1xufVxuZnVuY3Rpb24gZ2V0QVBJS2V5KCkge1xuICByZXR1cm4gYXBpS2V5O1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gIGxvZy5zZXRMZXZlbChsZXZlbCk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEFuZFRyYWNlKHVybCwgaW5pdCkge1xuICBsZXQgX3VybCA9IG51bGw7XG4gIHRyeSB7XG4gICAgX3VybCA9IG5ldyBVUkwodXJsKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gIGlmIChzZW50cnkgJiYgX3VybCAmJiAodHJhY2luZ09yaWdpbnMuaW5jbHVkZXMoX3VybC5vcmlnaW4pIHx8IHRyYWNpbmdQYXRocy5pbmNsdWRlcyhfdXJsLnBhdGhuYW1lKSkpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHNlbnRyeS5zdGFydFRyYW5zYWN0aW9uKHtcbiAgICAgIG5hbWU6IHVybFxuICAgIH0pO1xuICAgIGNvbnN0IHNwYW4gPSB0cmFuc2FjdGlvbi5zdGFydENoaWxkKHtcbiAgICAgIG9wOiBcImh0dHBcIlxuICAgIH0pOyAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBTcGFuXG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgaW5pdCk7XG4gICAgc3Bhbi5maW5pc2goKTsgLy8gUmVtZW1iZXIgdGhhdCBvbmx5IGZpbmlzaGVkIHNwYW5zIHdpbGwgYmUgc2VudCB3aXRoIHRoZSB0cmFuc2FjdGlvblxuXG4gICAgdHJhbnNhY3Rpb24uZmluaXNoKCk7IC8vIEZpbmlzaGluZyB0aGUgdHJhbnNhY3Rpb24gd2lsbCBzZW5kIGl0IHRvIFNlbnRyeVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIHJldHVybiBmZXRjaCh1cmwsIGluaXQpO1xufVxuZnVuY3Rpb24gZ2V0QXBpS2V5SGVhZGVycygpIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAoYXBpS2V5KSBoZWFkZXJzW2dhdGV3YXlBdXRoSGVhZGVyXSA9IGFwaUtleTtcbiAgaWYgKGVtYmVkSG9zdCkgaGVhZGVyc1tnYXRld2F5RW1iZWRIb3N0SGVhZGVyXSA9IGVtYmVkSG9zdDtcbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIGxvZy5pbmZvKGBSZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgbG9nLmluZm8oYFVybDogJHtyZXNwb25zZS51cmx9YCk7XG59XG5mdW5jdGlvbiBsb2dUcmFjaW5nSGVhZGVyKHJlc3BvbnNlKSB7XG4gIGNvbnN0IHRyYWNpbmdIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtd2ViMy1jb3JyZWxhdGlvbi1pZFwiKTtcbiAgaWYgKHRyYWNpbmdIZWFkZXIpIGxvZy5pbmZvKGBSZXF1ZXN0IHRyYWNpbmcgd2l0aCB0cmFjZUlEID0gJHt0cmFjaW5nSGVhZGVyfWApO1xufVxuY29uc3QgcHJvbWlzZVRpbWVvdXQgPSBhc3luYyAobXMsIHByb21pc2UpID0+IHtcbiAgbGV0IHRpbWVvdXRGdW5jID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBjb25zdCB0aW1lb3V0ID0gbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRpbWVvdXRGdW5jID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFRpbWVkIG91dCBpbiAke21zfW1zYCkpO1xuICAgICAgfSwgbXMpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZW91dF0pO1xuICAgIC8vIHByb21pc2UucmFjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcmVzb2x2ZWQgcHJvbWlzZVxuICAgIC8vIHRoZW4gd2UgY2xlYXIgdGhlIHRpbWVvdXRcbiAgICBpZiAodGltZW91dEZ1bmMgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRGdW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gY2xlYXIgdGhlIHRpbWVvdXRcbiAgICBpZiAodGltZW91dEZ1bmMgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRGdW5jKTtcbiAgICB9XG4gICAgLy8gcmV0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3JcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn07XG5jb25zdCBnZXQgPSBhc3luYyBmdW5jdGlvbiAodXJsKSB7XG4gIGxldCBvcHRpb25zXyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBjdXN0b21PcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgaGVhZGVyczoge31cbiAgfTtcbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyksIGdldEFwaUtleUhlYWRlcnMoKSk7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zXywge1xuICAgIG1ldGhvZDogXCJHRVRcIlxuICB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEFuZFRyYWNlKHVybCwgb3B0aW9ucyk7XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICBpZiAocmVzcG9uc2VDb250ZW50VHlwZSAhPT0gbnVsbCAmJiByZXNwb25zZUNvbnRlbnRUeXBlICE9PSB2b2lkIDAgJiYgcmVzcG9uc2VDb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XG4gIHRocm93IHJlc3BvbnNlO1xufTtcbmNvbnN0IHBvc3QgPSBmdW5jdGlvbiAodXJsKSB7XG4gIGxldCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdGlvbnNfID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgbGV0IGN1c3RvbU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgIH1cbiAgfTtcbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyksIGdldEFwaUtleUhlYWRlcnMoKSk7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zXywge1xuICAgIG1ldGhvZDogXCJQT1NUXCJcbiAgfSk7XG5cbiAgLy8gZGVlcCBtZXJnZSBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmUgb2YgZm9ybSBkYXRhIGFuZCB1cmwgZW5jb2RlZCBkYXRhICxcbiAgLy8gc28gd2Ugc2hvdWxkIG5vdCBkZWVwbWVyZ2UgYm9keSBkYXRhXG4gIGlmIChjdXN0b21PcHRpb25zLmlzVXJsRW5jb2RlZERhdGEpIHtcbiAgICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAgIC8vIGFsb25nIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5ICwgc28gZm9yIG11bHRpcGFydCByZXF1ZXN0IHNlbmRcbiAgICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgICBvcHRpb25zLmJvZHkgPSBkYXRhO1xuICAgIC8vIElmIHVybCBlbmNvZGVkIGRhdGEsIHRoaXMgbXVzdCBub3QgYmUgdGhlIGNvbnRlbnQgdHlwZVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPT09IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKSBkZWxldGUgb3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICB9XG4gIHJldHVybiBwcm9taXNlVGltZW91dChjdXN0b21PcHRpb25zLnRpbWVvdXQgfHwgNjAwMDAsIGZldGNoQW5kVHJhY2UodXJsLCBvcHRpb25zKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICBpZiAoY3VzdG9tT3B0aW9ucy5sb2dUcmFjaW5nSGVhZGVyKSB7XG4gICAgICBsb2dUcmFjaW5nSGVhZGVyKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCByZXNwb25zZUNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XG4gICAgICBpZiAocmVzcG9uc2VDb250ZW50VHlwZSAhPT0gbnVsbCAmJiByZXNwb25zZUNvbnRlbnRUeXBlICE9PSB2b2lkIDAgJiYgcmVzcG9uc2VDb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgfVxuICAgIGRlYnVnTG9nUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIHRocm93IHJlc3BvbnNlO1xuICB9KSk7XG59O1xuY29uc3QgcGF0Y2ggPSBhc3luYyBmdW5jdGlvbiAodXJsKSB7XG4gIGxldCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgbGV0IG9wdGlvbnNfID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgbGV0IGN1c3RvbU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgIH1cbiAgfTtcbiAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAvLyBjb250ZW50LXR5cGU6IHVuZGVmaW5lZCBvciBzZW5kIHdpdGggbXVsdGlwYXJ0IGJvdW5kYXJ5IGlmIGFscmVhZHkga25vd25cbiAgaWYgKGN1c3RvbU9wdGlvbnMudXNlQVBJS2V5KSB7XG4gICAgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMuaGVhZGVycyksIGdldEFwaUtleUhlYWRlcnMoKSk7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zXywge1xuICAgIG1ldGhvZDogXCJQQVRDSFwiXG4gIH0pO1xuICAvLyBkZWVwIG1lcmdlIGNoYW5nZXMgdGhlIHN0cnVjdHVyZSBvZiBmb3JtIGRhdGEgYW5kIHVybCBlbmNvZGVkIGRhdGEgLFxuICAvLyBzbyB3ZSBzaG91bGQgbm90IGRlZXBtZXJnZSBib2R5IGRhdGFcbiAgaWYgKGN1c3RvbU9wdGlvbnMuaXNVcmxFbmNvZGVkRGF0YSkge1xuICAgIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gICAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAgIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICAgIG9wdGlvbnMuYm9keSA9IGRhdGE7XG4gICAgLy8gSWYgdXJsIGVuY29kZWQgZGF0YSwgdGhpcyBtdXN0IG5vdCBiZSB0aGUgY29udGVudCB0eXBlXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpIGRlbGV0ZSBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEFuZFRyYWNlKHVybCwgb3B0aW9ucyk7XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICBpZiAocmVzcG9uc2VDb250ZW50VHlwZSAhPT0gbnVsbCAmJiByZXNwb25zZUNvbnRlbnRUeXBlICE9PSB2b2lkIDAgJiYgcmVzcG9uc2VDb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XG4gIHRocm93IHJlc3BvbnNlO1xufTtcbmNvbnN0IHB1dCA9IGFzeW5jIGZ1bmN0aW9uICh1cmwpIHtcbiAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0aW9uc18gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBsZXQgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9O1xuICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICBpZiAoY3VzdG9tT3B0aW9ucy51c2VBUElLZXkpIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnNfLCB7XG4gICAgbWV0aG9kOiBcIlBVVFwiXG4gIH0pO1xuICAvLyBkZWVwIG1lcmdlIGNoYW5nZXMgdGhlIHN0cnVjdHVyZSBvZiBmb3JtIGRhdGEgYW5kIHVybCBlbmNvZGVkIGRhdGEgLFxuICAvLyBzbyB3ZSBzaG91bGQgbm90IGRlZXBtZXJnZSBib2R5IGRhdGFcbiAgaWYgKGN1c3RvbU9wdGlvbnMuaXNVcmxFbmNvZGVkRGF0YSkge1xuICAgIC8vIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBicm93c2VyL2NsaWVudCB3aWxsIGFkZCBtdWx0aXBhcnQgY29udGVudCB0eXBlXG4gICAgLy8gYWxvbmcgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgLCBzbyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3Qgc2VuZFxuICAgIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICAgIG9wdGlvbnMuYm9keSA9IGRhdGE7XG4gICAgLy8gSWYgdXJsIGVuY29kZWQgZGF0YSwgdGhpcyBtdXN0IG5vdCBiZSB0aGUgY29udGVudCB0eXBlXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpIGRlbGV0ZSBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEFuZFRyYWNlKHVybCwgb3B0aW9ucyk7XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIGNvbnN0IHJlc3BvbnNlQ29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICBpZiAocmVzcG9uc2VDb250ZW50VHlwZSAhPT0gbnVsbCAmJiByZXNwb25zZUNvbnRlbnRUeXBlICE9PSB2b2lkIDAgJiYgcmVzcG9uc2VDb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gIH1cbiAgZGVidWdMb2dSZXNwb25zZShyZXNwb25zZSk7XG4gIHRocm93IHJlc3BvbnNlO1xufTtcbmNvbnN0IHJlbW92ZSA9IGFzeW5jIGZ1bmN0aW9uICh1cmwpIHtcbiAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBsZXQgb3B0aW9uc18gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBsZXQgY3VzdG9tT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9O1xuICAvLyBmb3IgbXVsdGlwYXJ0IHJlcXVlc3QgYnJvd3Nlci9jbGllbnQgd2lsbCBhZGQgbXVsdGlwYXJ0IGNvbnRlbnQgdHlwZVxuICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gIC8vIGNvbnRlbnQtdHlwZTogdW5kZWZpbmVkIG9yIHNlbmQgd2l0aCBtdWx0aXBhcnQgYm91bmRhcnkgaWYgYWxyZWFkeSBrbm93blxuICBpZiAoY3VzdG9tT3B0aW9ucy51c2VBUElLZXkpIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucy5oZWFkZXJzKSwgZ2V0QXBpS2V5SGVhZGVycygpKTtcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnNfLCB7XG4gICAgbWV0aG9kOiBcIkRFTEVURVwiXG4gIH0pO1xuICBpZiAoY3VzdG9tT3B0aW9ucy5pc1VybEVuY29kZWREYXRhKSB7XG4gICAgLy8gZm9yIG11bHRpcGFydCByZXF1ZXN0IGJyb3dzZXIvY2xpZW50IHdpbGwgYWRkIG11bHRpcGFydCBjb250ZW50IHR5cGVcbiAgICAvLyBhbG9uZyB3aXRoIG11bHRpcGFydCBib3VuZGFyeSAsIHNvIGZvciBtdWx0aXBhcnQgcmVxdWVzdCBzZW5kXG4gICAgLy8gY29udGVudC10eXBlOiB1bmRlZmluZWQgb3Igc2VuZCB3aXRoIG11bHRpcGFydCBib3VuZGFyeSBpZiBhbHJlYWR5IGtub3duXG4gICAgb3B0aW9ucy5ib2R5ID0gZGF0YTtcbiAgICAvLyBJZiB1cmwgZW5jb2RlZCBkYXRhLCB0aGlzIG11c3Qgbm90IGJlIHRoZSBjb250ZW50IHR5cGVcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID09PSBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIikgZGVsZXRlIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQW5kVHJhY2UodXJsLCBvcHRpb25zKTtcbiAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgY29uc3QgcmVzcG9uc2VDb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgIGlmIChyZXNwb25zZUNvbnRlbnRUeXBlICE9PSBudWxsICYmIHJlc3BvbnNlQ29udGVudFR5cGUgIT09IHZvaWQgMCAmJiByZXNwb25zZUNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxuICBkZWJ1Z0xvZ1Jlc3BvbnNlKHJlc3BvbnNlKTtcbiAgdGhyb3cgcmVzcG9uc2U7XG59O1xuY29uc3QgZ2VuZXJhdGVKc29uUlBDT2JqZWN0ID0gKG1ldGhvZCwgcGFyYW1ldGVycykgPT4gKHtcbiAganNvbnJwYzogXCIyLjBcIixcbiAgbWV0aG9kLFxuICBpZDogMTAsXG4gIHBhcmFtczogcGFyYW1ldGVyc1xufSk7XG5jb25zdCBwcm9taXNlUmFjZSA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgbGV0IHRpbWVvdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDYwMDAwO1xuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtnZXQodXJsLCBvcHRpb25zKSwgbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJ0aW1lZCBvdXRcIikpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9KV0pO1xufTtcblxuZXhwb3J0IHsgY2xlYXJBUElLZXksIGNsZWFyRW1iZWRIb3N0LCBlbmFibGVTZW50cnlUcmFjaW5nLCBnYXRld2F5QXV0aEhlYWRlciwgZ2F0ZXdheUVtYmVkSG9zdEhlYWRlciwgZ2VuZXJhdGVKc29uUlBDT2JqZWN0LCBnZXQsIGdldEFQSUtleSwgZ2V0RW1iZWRIb3N0LCBwYXRjaCwgcG9zdCwgcHJvbWlzZVJhY2UsIHByb21pc2VUaW1lb3V0LCBwdXQsIHJlbW92ZSwgc2V0QVBJS2V5LCBzZXRFbWJlZEhvc3QsIHNldExvZ0xldmVsIH07XG4iXSwibmFtZXMiOlsiX29iamVjdFNwcmVhZCIsIm1lcmdlIiwibG9nTGV2ZWwiLCJsZXZlbHMiLCJsb2ciLCJnZXRMb2dnZXIiLCJzZXRMZXZlbCIsIklORk8iLCJhcGlLZXkiLCJlbWJlZEhvc3QiLCJnYXRld2F5QXV0aEhlYWRlciIsImdhdGV3YXlFbWJlZEhvc3RIZWFkZXIiLCJzZW50cnkiLCJ0cmFjaW5nT3JpZ2lucyIsInRyYWNpbmdQYXRocyIsImVuYWJsZVNlbnRyeVRyYWNpbmciLCJfc2VudHJ5IiwiX3RyYWNpbmdPcmlnaW5zIiwiX3RyYWNpbmdQYXRocyIsInB1c2giLCJzZXRFbWJlZEhvc3QiLCJlbWJlZEhvc3RfIiwiY2xlYXJFbWJlZEhvc3QiLCJnZXRFbWJlZEhvc3QiLCJzZXRBUElLZXkiLCJhcGlLZXlfIiwiY2xlYXJBUElLZXkiLCJnZXRBUElLZXkiLCJzZXRMb2dMZXZlbCIsImxldmVsIiwiZmV0Y2hBbmRUcmFjZSIsInVybCIsImluaXQiLCJfdXJsIiwiVVJMIiwiZXJyb3IiLCJpbmNsdWRlcyIsIm9yaWdpbiIsInBhdGhuYW1lIiwidHJhbnNhY3Rpb24iLCJzdGFydFRyYW5zYWN0aW9uIiwibmFtZSIsInNwYW4iLCJzdGFydENoaWxkIiwib3AiLCJyZXNwb25zZSIsImZldGNoIiwiZmluaXNoIiwiZ2V0QXBpS2V5SGVhZGVycyIsImhlYWRlcnMiLCJkZWJ1Z0xvZ1Jlc3BvbnNlIiwiaW5mbyIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJsb2dUcmFjaW5nSGVhZGVyIiwidHJhY2luZ0hlYWRlciIsImdldCIsInByb21pc2VUaW1lb3V0IiwibXMiLCJwcm9taXNlIiwidGltZW91dEZ1bmMiLCJ0aW1lb3V0IiwiUHJvbWlzZSIsIl9yZXNvbHZlIiwicmVqZWN0Iiwic2V0VGltZW91dCIsIkVycm9yIiwicmVzdWx0IiwicmFjZSIsImNsZWFyVGltZW91dCIsImVyciIsIm9wdGlvbnNfIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiY3VzdG9tT3B0aW9ucyIsImRlZmF1bHRPcHRpb25zIiwibW9kZSIsInVzZUFQSUtleSIsIm9wdGlvbnMiLCJtZXRob2QiLCJvayIsInJlc3BvbnNlQ29udGVudFR5cGUiLCJqc29uIiwidGV4dCIsInBvc3QiLCJkYXRhIiwiaXNVcmxFbmNvZGVkRGF0YSIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwidGhlbiIsInBhdGNoIiwicHV0IiwicmVtb3ZlIiwiZ2VuZXJhdGVKc29uUlBDT2JqZWN0IiwicGFyYW1ldGVycyIsImpzb25ycGMiLCJpZCIsInBhcmFtcyIsInByb21pc2VSYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decryptData: () => (/* binding */ decryptData),\n/* harmony export */   \"default\": () => (/* binding */ MetadataStorageLayer),\n/* harmony export */   ec: () => (/* binding */ ec),\n/* harmony export */   encParamsBufToHex: () => (/* binding */ encParamsBufToHex),\n/* harmony export */   encParamsHexToBuf: () => (/* binding */ encParamsHexToBuf),\n/* harmony export */   encryptAndSetData: () => (/* binding */ encryptAndSetData),\n/* harmony export */   encryptData: () => (/* binding */ encryptData),\n/* harmony export */   getAndDecryptData: () => (/* binding */ getAndDecryptData),\n/* harmony export */   getDeviceShare: () => (/* binding */ getDeviceShare),\n/* harmony export */   getTorusShare: () => (/* binding */ getTorusShare),\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   setDeviceShare: () => (/* binding */ setDeviceShare),\n/* harmony export */   setTorusShare: () => (/* binding */ setTorusShare)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! json-stable-stringify */ \"(ssr)/./node_modules/json-stable-stringify/index.js\");\n/* harmony import */ var json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(elliptic__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var ethereum_cryptography_keccak__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/ethereum-cryptography/esm/keccak.js\");\n/* harmony import */ var _toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @toruslabs/eccrypto */ \"(ssr)/./node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js\");\n\n\n\n\n\n\n\nfunction keccak256(a) {\n    return Buffer.from((0,ethereum_cryptography_keccak__WEBPACK_IMPORTED_MODULE_5__.keccak256)(a));\n}\nconst ec = new elliptic__WEBPACK_IMPORTED_MODULE_4__.ec(\"secp256k1\");\nclass MetadataStorageLayer {\n    // ms\n    constructor(){\n        let metadataHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"https://metadata.tor.us\";\n        let serverTimeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"metadataHost\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"serverTimeOffset\", void 0);\n        this.metadataHost = metadataHost;\n        this.serverTimeOffset = serverTimeOffset;\n    }\n    static setAPIKey(apiKey) {\n        (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.setAPIKey)(apiKey);\n    }\n    static setEmbedHost(embedHost) {\n        (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.setEmbedHost)(embedHost);\n    }\n    generateMetadataParams(message, privateKeyHex) {\n        var _sig$recoveryParam$to, _sig$recoveryParam;\n        const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n        const setData = {\n            data: message,\n            timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16)\n        };\n        const sig = key.sign(keccak256(Buffer.from(json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default()(setData), \"utf8\")));\n        return {\n            pub_key_X: key.getPublic().getX().toString(16, 64),\n            pub_key_Y: key.getPublic().getY().toString(16, 64),\n            set_data: setData,\n            signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + ((_sig$recoveryParam$to = (_sig$recoveryParam = sig.recoveryParam) === null || _sig$recoveryParam === void 0 ? void 0 : _sig$recoveryParam.toString(16).padStart(2, \"0\").slice(-2)) !== null && _sig$recoveryParam$to !== void 0 ? _sig$recoveryParam$to : \"00\"), \"hex\").toString(\"base64\")\n        };\n    }\n    generatePubKeyParams(privateKeyHex) {\n        const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n        return {\n            pub_key_X: key.getPublic().getX().toString(16, 64),\n            pub_key_Y: key.getPublic().getY().toString(16, 64)\n        };\n    }\n    async setMetadata(data, namespace, options) {\n        const params = namespace !== null ? _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, data), {}, {\n            namespace\n        }) : data;\n        const metadataResponse = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.post)(`${this.metadataHost}/set`, params, options, {\n            useAPIKey: true\n        });\n        return metadataResponse.message;\n    }\n    async getMetadata(pubKey, namespace, options) {\n        const params = namespace !== null ? _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, pubKey), {}, {\n            namespace\n        }) : pubKey;\n        const metadataResponse = await (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_2__.post)(`${this.metadataHost}/get`, params, options, {\n            useAPIKey: true\n        });\n        return metadataResponse.message;\n    }\n}\nconst WEBAUTHN_TORUS_SHARE = \"webauthn_torus_share\";\nconst WEBAUTHN_DEVICE_SHARE = \"webauthn_device_share\";\nfunction encParamsHexToBuf(encParamsHex) {\n    return {\n        iv: Buffer.from(encParamsHex.iv, \"hex\"),\n        ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, \"hex\"),\n        ciphertext: Buffer.from(encParamsHex.ciphertext, \"hex\"),\n        mac: Buffer.from(encParamsHex.mac, \"hex\")\n    };\n}\nfunction encParamsBufToHex(encParams) {\n    return {\n        iv: Buffer.from(encParams.iv).toString(\"hex\"),\n        ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString(\"hex\"),\n        ciphertext: Buffer.from(encParams.ciphertext).toString(\"hex\"),\n        mac: Buffer.from(encParams.mac).toString(\"hex\")\n    };\n}\nasync function encryptData(privKeyHex, d) {\n    const serializedDec = JSON.stringify(d);\n    const serializedBuf = Buffer.from(serializedDec, \"utf-8\");\n    const encParams = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.encrypt)((0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.getPublic)(Buffer.from(privKeyHex, \"hex\")), serializedBuf);\n    const encParamsHex = encParamsBufToHex(encParams);\n    const sData = JSON.stringify(encParamsHex);\n    return sData;\n}\nasync function decryptData(privKeyHex, d) {\n    const encParamsHex = JSON.parse(d);\n    const encParams = encParamsHexToBuf(encParamsHex);\n    const keyPair = ec.keyFromPrivate(privKeyHex);\n    const serializedBuf = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.decrypt)(Buffer.from(keyPair.getPrivate().toString(\"hex\", 64), \"hex\"), encParams);\n    const serializedDec = serializedBuf.toString(\"utf-8\");\n    const data = JSON.parse(serializedDec);\n    return data;\n}\nasync function getAndDecryptData(m, privKeyHex, namespace) {\n    const keyPair = ec.keyFromPrivate(privKeyHex, \"hex\");\n    const pubKey = keyPair.getPublic();\n    const serializedData = await m.getMetadata({\n        pub_key_X: pubKey.getX().toString(16, 64),\n        pub_key_Y: pubKey.getY().toString(16, 64)\n    }, namespace);\n    if (!serializedData) {\n        return null;\n    }\n    const data = await decryptData(privKeyHex, serializedData);\n    return data;\n}\nasync function encryptAndSetData(m, privKeyHex, d, namespace) {\n    const sData = await encryptData(privKeyHex, d);\n    const metadataParams = m.generateMetadataParams(sData, privKeyHex);\n    await m.setMetadata(metadataParams, namespace);\n}\nasync function setTorusShare(m, webAuthnPubKey, webAuthnRefHex, subspace, subspaceData) {\n    const refKeyPair = ec.keyFromPrivate(webAuthnRefHex);\n    const privKey = refKeyPair.getPrivate();\n    const pubKey = ec.keyFromPublic({\n        x: webAuthnPubKey.pub_key_X,\n        y: webAuthnPubKey.pub_key_Y\n    });\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n    let d = {};\n    if (data) d = data;\n    const serializedSubspaceData = JSON.stringify(subspaceData);\n    const serializedSubspaceDataBuf = Buffer.from(serializedSubspaceData, \"utf-8\");\n    const encSubspaceData = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.encrypt)(Buffer.from(pubKey.getPublic(\"hex\"), \"hex\"), serializedSubspaceDataBuf);\n    const encSubspaceDataHex = encParamsBufToHex(encSubspaceData);\n    d[subspace] = encSubspaceDataHex;\n    await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_TORUS_SHARE);\n}\nasync function setDeviceShare(m, webAuthnRefHex, subspace, subspaceData) {\n    const keyPair = ec.keyFromPrivate(webAuthnRefHex);\n    const privKey = keyPair.getPrivate();\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n    let d = {};\n    if (data) d = data;\n    d[subspace] = subspaceData;\n    await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_DEVICE_SHARE);\n}\nasync function getTorusShare(m, webAuthnKeyHex, webAuthnRefHex, subspace) {\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n    if (!data) return null;\n    const encParamsHex = data[subspace];\n    if (!encParamsHex) return null;\n    const encParams = encParamsHexToBuf(encParamsHex);\n    const keyPair = ec.keyFromPrivate(webAuthnKeyHex);\n    const privKey = keyPair.getPrivate();\n    const serializedSubspaceDataBuf = await (0,_toruslabs_eccrypto__WEBPACK_IMPORTED_MODULE_6__.decrypt)(Buffer.from(privKey.toString(\"hex\", 64), \"hex\"), encParams);\n    const serializedSubspaceData = serializedSubspaceDataBuf.toString(\"utf-8\");\n    const subspaceData = JSON.parse(serializedSubspaceData);\n    return subspaceData;\n}\nasync function getDeviceShare(m, webAuthnRefHex, subspace) {\n    const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n    if (data) return data[subspace];\n    return null;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9tZXRhZGF0YS1oZWxwZXJzL2Rpc3QvbWV0YWRhdGFIZWxwZXJzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUU7QUFDRztBQUNJO0FBQzFCO0FBQ1I7QUFDa0M7QUFDTjtBQUVsRSxTQUFTUSxVQUFVSyxDQUFDO0lBQ2xCLE9BQU9DLE9BQU9DLElBQUksQ0FBQ04sdUVBQVdBLENBQUNJO0FBQ2pDO0FBQ0EsTUFBTVAsS0FBSyxJQUFJQyx3Q0FBSUEsQ0FBQztBQUVwQixNQUFNUztJQUNKLEtBQUs7SUFFTEMsYUFBYztRQUNaLElBQUlDLGVBQWVDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3ZGLElBQUlHLG1CQUFtQkgsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDM0ZsQiw0RUFBZUEsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLEtBQUs7UUFDM0NBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxvQkFBb0IsS0FBSztRQUMvQyxJQUFJLENBQUNpQixZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ0ksZ0JBQWdCLEdBQUdBO0lBQzFCO0lBQ0EsT0FBT3BCLFVBQVVxQixNQUFNLEVBQUU7UUFDdkJyQixrRUFBU0EsQ0FBQ3FCO0lBQ1o7SUFDQSxPQUFPcEIsYUFBYXFCLFNBQVMsRUFBRTtRQUM3QnJCLHFFQUFZQSxDQUFDcUI7SUFDZjtJQUNBQyx1QkFBdUJDLE9BQU8sRUFBRUMsYUFBYSxFQUFFO1FBQzdDLElBQUlDLHVCQUF1QkM7UUFDM0IsTUFBTUMsTUFBTXhCLEdBQUd5QixjQUFjLENBQUNKLGVBQWU7UUFDN0MsTUFBTUssVUFBVTtZQUNkQyxNQUFNUDtZQUNOUSxXQUFXQyxLQUFLQyxLQUFLLENB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QUFNcUQsZUFBZWhCLEtBQUtJLEtBQUssQ0FBQ2tCO0lBQ2hDLE9BQU9OO0FBQ1Q7QUFDQSxlQUFlYSxlQUFlckIsQ0FBQyxFQUFFTSxjQUFjLEVBQUVDLFFBQVE7SUFDdkQsTUFBTTFELE9BQU8sTUFBTWtELGtCQUFrQkMsR0FBR00sZ0JBQWdCM0I7SUFDeEQsSUFBSTlCLE1BQU0sT0FBT0EsSUFBSSxDQUFDMEQsU0FBUztJQUMvQixPQUFPO0FBQ1Q7QUFFOE4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb2wtcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL21ldGFkYXRhLWhlbHBlcnMvZGlzdC9tZXRhZGF0YUhlbHBlcnMuZXNtLmpzPzQ1YjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJztcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eSc7XG5pbXBvcnQgeyBzZXRBUElLZXksIHNldEVtYmVkSG9zdCwgcG9zdCB9IGZyb20gJ0B0b3J1c2xhYnMvaHR0cC1oZWxwZXJzJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnanNvbi1zdGFibGUtc3RyaW5naWZ5JztcbmltcG9ydCB7IGVjIGFzIGVjJDEgfSBmcm9tICdlbGxpcHRpYyc7XG5pbXBvcnQgeyBrZWNjYWsyNTYgYXMga2VjY2FrMjU2JDEgfSBmcm9tICdldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrJztcbmltcG9ydCB7IGVuY3J5cHQsIGdldFB1YmxpYywgZGVjcnlwdCB9IGZyb20gJ0B0b3J1c2xhYnMvZWNjcnlwdG8nO1xuXG5mdW5jdGlvbiBrZWNjYWsyNTYoYSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oa2VjY2FrMjU2JDEoYSkpO1xufVxuY29uc3QgZWMgPSBuZXcgZWMkMShcInNlY3AyNTZrMVwiKTtcblxuY2xhc3MgTWV0YWRhdGFTdG9yYWdlTGF5ZXIge1xuICAvLyBtc1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBtZXRhZGF0YUhvc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFwiaHR0cHM6Ly9tZXRhZGF0YS50b3IudXNcIjtcbiAgICBsZXQgc2VydmVyVGltZU9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YUhvc3RcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXJ2ZXJUaW1lT2Zmc2V0XCIsIHZvaWQgMCk7XG4gICAgdGhpcy5tZXRhZGF0YUhvc3QgPSBtZXRhZGF0YUhvc3Q7XG4gICAgdGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0ID0gc2VydmVyVGltZU9mZnNldDtcbiAgfVxuICBzdGF0aWMgc2V0QVBJS2V5KGFwaUtleSkge1xuICAgIHNldEFQSUtleShhcGlLZXkpO1xuICB9XG4gIHN0YXRpYyBzZXRFbWJlZEhvc3QoZW1iZWRIb3N0KSB7XG4gICAgc2V0RW1iZWRIb3N0KGVtYmVkSG9zdCk7XG4gIH1cbiAgZ2VuZXJhdGVNZXRhZGF0YVBhcmFtcyhtZXNzYWdlLCBwcml2YXRlS2V5SGV4KSB7XG4gICAgdmFyIF9zaWckcmVjb3ZlcnlQYXJhbSR0bywgX3NpZyRyZWNvdmVyeVBhcmFtO1xuICAgIGNvbnN0IGtleSA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXlIZXgsIFwiaGV4XCIpO1xuICAgIGNvbnN0IHNldERhdGEgPSB7XG4gICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgdGltZXN0YW1wOiBNYXRoLmZsb29yKHRoaXMuc2VydmVyVGltZU9mZnNldCArIERhdGUubm93KCkgLyAxMDAwKS50b1N0cmluZygxNilcbiAgICB9O1xuICAgIGNvbnN0IHNpZyA9IGtleS5zaWduKGtlY2NhazI1NihCdWZmZXIuZnJvbShzdHJpbmdpZnkoc2V0RGF0YSksIFwidXRmOFwiKSkpO1xuICAgIHJldHVybiB7XG4gICAgICBwdWJfa2V5X1g6IGtleS5nZXRQdWJsaWMoKS5nZXRYKCkudG9TdHJpbmcoMTYsIDY0KSxcbiAgICAgIHB1Yl9rZXlfWToga2V5LmdldFB1YmxpYygpLmdldFkoKS50b1N0cmluZygxNiwgNjQpLFxuICAgICAgc2V0X2RhdGE6IHNldERhdGEsXG4gICAgICBzaWduYXR1cmU6IEJ1ZmZlci5mcm9tKHNpZy5yLnRvU3RyaW5nKDE2LCA2NCkgKyBzaWcucy50b1N0cmluZygxNiwgNjQpICsgKChfc2lnJHJlY292ZXJ5UGFyYW0kdG8gPSAoX3NpZyRyZWNvdmVyeVBhcmFtID0gc2lnLnJlY292ZXJ5UGFyYW0pID09PSBudWxsIHx8IF9zaWckcmVjb3ZlcnlQYXJhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NpZyRyZWNvdmVyeVBhcmFtLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikuc2xpY2UoLTIpKSAhPT0gbnVsbCAmJiBfc2lnJHJlY292ZXJ5UGFyYW0kdG8gIT09IHZvaWQgMCA/IF9zaWckcmVjb3ZlcnlQYXJhbSR0byA6IFwiMDBcIiksIFwiaGV4XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpXG4gICAgfTtcbiAgfVxuICBnZW5lcmF0ZVB1YktleVBhcmFtcyhwcml2YXRlS2V5SGV4KSB7XG4gICAgY29uc3Qga2V5ID0gZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleUhleCwgXCJoZXhcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1Yl9rZXlfWDoga2V5LmdldFB1YmxpYygpLmdldFgoKS50b1N0cmluZygxNiwgNjQpLFxuICAgICAgcHViX2tleV9ZOiBrZXkuZ2V0UHVibGljKCkuZ2V0WSgpLnRvU3RyaW5nKDE2LCA2NClcbiAgICB9O1xuICB9XG4gIGFzeW5jIHNldE1ldGFkYXRhKGRhdGEsIG5hbWVzcGFjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5hbWVzcGFjZSAhPT0gbnVsbCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGF0YSksIHt9LCB7XG4gICAgICBuYW1lc3BhY2VcbiAgICB9KSA6IGRhdGE7XG4gICAgY29uc3QgbWV0YWRhdGFSZXNwb25zZSA9IGF3YWl0IHBvc3QoYCR7dGhpcy5tZXRhZGF0YUhvc3R9L3NldGAsIHBhcmFtcywgb3B0aW9ucywge1xuICAgICAgdXNlQVBJS2V5OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhUmVzcG9uc2UubWVzc2FnZTtcbiAgfVxuICBhc3luYyBnZXRNZXRhZGF0YShwdWJLZXksIG5hbWVzcGFjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5hbWVzcGFjZSAhPT0gbnVsbCA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHViS2V5KSwge30sIHtcbiAgICAgIG5hbWVzcGFjZVxuICAgIH0pIDogcHViS2V5O1xuICAgIGNvbnN0IG1ldGFkYXRhUmVzcG9uc2UgPSBhd2FpdCBwb3N0KGAke3RoaXMubWV0YWRhdGFIb3N0fS9nZXRgLCBwYXJhbXMsIG9wdGlvbnMsIHtcbiAgICAgIHVzZUFQSUtleTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBtZXRhZGF0YVJlc3BvbnNlLm1lc3NhZ2U7XG4gIH1cbn1cblxuY29uc3QgV0VCQVVUSE5fVE9SVVNfU0hBUkUgPSBcIndlYmF1dGhuX3RvcnVzX3NoYXJlXCI7XG5jb25zdCBXRUJBVVRITl9ERVZJQ0VfU0hBUkUgPSBcIndlYmF1dGhuX2RldmljZV9zaGFyZVwiO1xuZnVuY3Rpb24gZW5jUGFyYW1zSGV4VG9CdWYoZW5jUGFyYW1zSGV4KSB7XG4gIHJldHVybiB7XG4gICAgaXY6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtc0hleC5pdiwgXCJoZXhcIiksXG4gICAgZXBoZW1QdWJsaWNLZXk6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtc0hleC5lcGhlbVB1YmxpY0tleSwgXCJoZXhcIiksXG4gICAgY2lwaGVydGV4dDogQnVmZmVyLmZyb20oZW5jUGFyYW1zSGV4LmNpcGhlcnRleHQsIFwiaGV4XCIpLFxuICAgIG1hYzogQnVmZmVyLmZyb20oZW5jUGFyYW1zSGV4Lm1hYywgXCJoZXhcIilcbiAgfTtcbn1cbmZ1bmN0aW9uIGVuY1BhcmFtc0J1ZlRvSGV4KGVuY1BhcmFtcykge1xuICByZXR1cm4ge1xuICAgIGl2OiBCdWZmZXIuZnJvbShlbmNQYXJhbXMuaXYpLnRvU3RyaW5nKFwiaGV4XCIpLFxuICAgIGVwaGVtUHVibGljS2V5OiBCdWZmZXIuZnJvbShlbmNQYXJhbXMuZXBoZW1QdWJsaWNLZXkpLnRvU3RyaW5nKFwiaGV4XCIpLFxuICAgIGNpcGhlcnRleHQ6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtcy5jaXBoZXJ0ZXh0KS50b1N0cmluZyhcImhleFwiKSxcbiAgICBtYWM6IEJ1ZmZlci5mcm9tKGVuY1BhcmFtcy5tYWMpLnRvU3RyaW5nKFwiaGV4XCIpXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0RGF0YShwcml2S2V5SGV4LCBkKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWREZWMgPSBKU09OLnN0cmluZ2lmeShkKTtcbiAgY29uc3Qgc2VyaWFsaXplZEJ1ZiA9IEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWREZWMsIFwidXRmLThcIik7XG4gIGNvbnN0IGVuY1BhcmFtcyA9IGF3YWl0IGVuY3J5cHQoZ2V0UHVibGljKEJ1ZmZlci5mcm9tKHByaXZLZXlIZXgsIFwiaGV4XCIpKSwgc2VyaWFsaXplZEJ1Zik7XG4gIGNvbnN0IGVuY1BhcmFtc0hleCA9IGVuY1BhcmFtc0J1ZlRvSGV4KGVuY1BhcmFtcyk7XG4gIGNvbnN0IHNEYXRhID0gSlNPTi5zdHJpbmdpZnkoZW5jUGFyYW1zSGV4KTtcbiAgcmV0dXJuIHNEYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdERhdGEocHJpdktleUhleCwgZCkge1xuICBjb25zdCBlbmNQYXJhbXNIZXggPSBKU09OLnBhcnNlKGQpO1xuICBjb25zdCBlbmNQYXJhbXMgPSBlbmNQYXJhbXNIZXhUb0J1ZihlbmNQYXJhbXNIZXgpO1xuICBjb25zdCBrZXlQYWlyID0gZWMua2V5RnJvbVByaXZhdGUocHJpdktleUhleCk7XG4gIGNvbnN0IHNlcmlhbGl6ZWRCdWYgPSBhd2FpdCBkZWNyeXB0KEJ1ZmZlci5mcm9tKGtleVBhaXIuZ2V0UHJpdmF0ZSgpLnRvU3RyaW5nKFwiaGV4XCIsIDY0KSwgXCJoZXhcIiksIGVuY1BhcmFtcyk7XG4gIGNvbnN0IHNlcmlhbGl6ZWREZWMgPSBzZXJpYWxpemVkQnVmLnRvU3RyaW5nKFwidXRmLThcIik7XG4gIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWREZWMpO1xuICByZXR1cm4gZGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFuZERlY3J5cHREYXRhKG0sIHByaXZLZXlIZXgsIG5hbWVzcGFjZSkge1xuICBjb25zdCBrZXlQYWlyID0gZWMua2V5RnJvbVByaXZhdGUocHJpdktleUhleCwgXCJoZXhcIik7XG4gIGNvbnN0IHB1YktleSA9IGtleVBhaXIuZ2V0UHVibGljKCk7XG4gIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gYXdhaXQgbS5nZXRNZXRhZGF0YSh7XG4gICAgcHViX2tleV9YOiBwdWJLZXkuZ2V0WCgpLnRvU3RyaW5nKDE2LCA2NCksXG4gICAgcHViX2tleV9ZOiBwdWJLZXkuZ2V0WSgpLnRvU3RyaW5nKDE2LCA2NClcbiAgfSwgbmFtZXNwYWNlKTtcbiAgaWYgKCFzZXJpYWxpemVkRGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBkZWNyeXB0RGF0YShwcml2S2V5SGV4LCBzZXJpYWxpemVkRGF0YSk7XG4gIHJldHVybiBkYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdEFuZFNldERhdGEobSwgcHJpdktleUhleCwgZCwgbmFtZXNwYWNlKSB7XG4gIGNvbnN0IHNEYXRhID0gYXdhaXQgZW5jcnlwdERhdGEocHJpdktleUhleCwgZCk7XG4gIGNvbnN0IG1ldGFkYXRhUGFyYW1zID0gbS5nZW5lcmF0ZU1ldGFkYXRhUGFyYW1zKHNEYXRhLCBwcml2S2V5SGV4KTtcbiAgYXdhaXQgbS5zZXRNZXRhZGF0YShtZXRhZGF0YVBhcmFtcywgbmFtZXNwYWNlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNldFRvcnVzU2hhcmUobSwgd2ViQXV0aG5QdWJLZXksIHdlYkF1dGhuUmVmSGV4LCBzdWJzcGFjZSwgc3Vic3BhY2VEYXRhKSB7XG4gIGNvbnN0IHJlZktleVBhaXIgPSBlYy5rZXlGcm9tUHJpdmF0ZSh3ZWJBdXRoblJlZkhleCk7XG4gIGNvbnN0IHByaXZLZXkgPSByZWZLZXlQYWlyLmdldFByaXZhdGUoKTtcbiAgY29uc3QgcHViS2V5ID0gZWMua2V5RnJvbVB1YmxpYyh7XG4gICAgeDogd2ViQXV0aG5QdWJLZXkucHViX2tleV9YLFxuICAgIHk6IHdlYkF1dGhuUHViS2V5LnB1Yl9rZXlfWVxuICB9KTtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGdldEFuZERlY3J5cHREYXRhKG0sIHdlYkF1dGhuUmVmSGV4LCBXRUJBVVRITl9UT1JVU19TSEFSRSk7XG4gIGxldCBkID0ge307XG4gIGlmIChkYXRhKSBkID0gZGF0YTtcbiAgY29uc3Qgc2VyaWFsaXplZFN1YnNwYWNlRGF0YSA9IEpTT04uc3RyaW5naWZ5KHN1YnNwYWNlRGF0YSk7XG4gIGNvbnN0IHNlcmlhbGl6ZWRTdWJzcGFjZURhdGFCdWYgPSBCdWZmZXIuZnJvbShzZXJpYWxpemVkU3Vic3BhY2VEYXRhLCBcInV0Zi04XCIpO1xuICBjb25zdCBlbmNTdWJzcGFjZURhdGEgPSBhd2FpdCBlbmNyeXB0KEJ1ZmZlci5mcm9tKHB1YktleS5nZXRQdWJsaWMoXCJoZXhcIiksIFwiaGV4XCIpLCBzZXJpYWxpemVkU3Vic3BhY2VEYXRhQnVmKTtcbiAgY29uc3QgZW5jU3Vic3BhY2VEYXRhSGV4ID0gZW5jUGFyYW1zQnVmVG9IZXgoZW5jU3Vic3BhY2VEYXRhKTtcbiAgZFtzdWJzcGFjZV0gPSBlbmNTdWJzcGFjZURhdGFIZXg7XG4gIGF3YWl0IGVuY3J5cHRBbmRTZXREYXRhKG0sIHByaXZLZXkudG9TdHJpbmcoXCJoZXhcIiwgNjQpLCBkLCBXRUJBVVRITl9UT1JVU19TSEFSRSk7XG59XG5hc3luYyBmdW5jdGlvbiBzZXREZXZpY2VTaGFyZShtLCB3ZWJBdXRoblJlZkhleCwgc3Vic3BhY2UsIHN1YnNwYWNlRGF0YSkge1xuICBjb25zdCBrZXlQYWlyID0gZWMua2V5RnJvbVByaXZhdGUod2ViQXV0aG5SZWZIZXgpO1xuICBjb25zdCBwcml2S2V5ID0ga2V5UGFpci5nZXRQcml2YXRlKCk7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRBbmREZWNyeXB0RGF0YShtLCB3ZWJBdXRoblJlZkhleCwgV0VCQVVUSE5fREVWSUNFX1NIQVJFKTtcbiAgbGV0IGQgPSB7fTtcbiAgaWYgKGRhdGEpIGQgPSBkYXRhO1xuICBkW3N1YnNwYWNlXSA9IHN1YnNwYWNlRGF0YTtcbiAgYXdhaXQgZW5jcnlwdEFuZFNldERhdGEobSwgcHJpdktleS50b1N0cmluZyhcImhleFwiLCA2NCksIGQsIFdFQkFVVEhOX0RFVklDRV9TSEFSRSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRUb3J1c1NoYXJlKG0sIHdlYkF1dGhuS2V5SGV4LCB3ZWJBdXRoblJlZkhleCwgc3Vic3BhY2UpIHtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IGdldEFuZERlY3J5cHREYXRhKG0sIHdlYkF1dGhuUmVmSGV4LCBXRUJBVVRITl9UT1JVU19TSEFSRSk7XG4gIGlmICghZGF0YSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGVuY1BhcmFtc0hleCA9IGRhdGFbc3Vic3BhY2VdO1xuICBpZiAoIWVuY1BhcmFtc0hleCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGVuY1BhcmFtcyA9IGVuY1BhcmFtc0hleFRvQnVmKGVuY1BhcmFtc0hleCk7XG4gIGNvbnN0IGtleVBhaXIgPSBlYy5rZXlGcm9tUHJpdmF0ZSh3ZWJBdXRobktleUhleCk7XG4gIGNvbnN0IHByaXZLZXkgPSBrZXlQYWlyLmdldFByaXZhdGUoKTtcbiAgY29uc3Qgc2VyaWFsaXplZFN1YnNwYWNlRGF0YUJ1ZiA9IGF3YWl0IGRlY3J5cHQoQnVmZmVyLmZyb20ocHJpdktleS50b1N0cmluZyhcImhleFwiLCA2NCksIFwiaGV4XCIpLCBlbmNQYXJhbXMpO1xuICBjb25zdCBzZXJpYWxpemVkU3Vic3BhY2VEYXRhID0gc2VyaWFsaXplZFN1YnNwYWNlRGF0YUJ1Zi50b1N0cmluZyhcInV0Zi04XCIpO1xuICBjb25zdCBzdWJzcGFjZURhdGEgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWRTdWJzcGFjZURhdGEpO1xuICByZXR1cm4gc3Vic3BhY2VEYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0RGV2aWNlU2hhcmUobSwgd2ViQXV0aG5SZWZIZXgsIHN1YnNwYWNlKSB7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRBbmREZWNyeXB0RGF0YShtLCB3ZWJBdXRoblJlZkhleCwgV0VCQVVUSE5fREVWSUNFX1NIQVJFKTtcbiAgaWYgKGRhdGEpIHJldHVybiBkYXRhW3N1YnNwYWNlXTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IGRlY3J5cHREYXRhLCBNZXRhZGF0YVN0b3JhZ2VMYXllciBhcyBkZWZhdWx0LCBlYywgZW5jUGFyYW1zQnVmVG9IZXgsIGVuY1BhcmFtc0hleFRvQnVmLCBlbmNyeXB0QW5kU2V0RGF0YSwgZW5jcnlwdERhdGEsIGdldEFuZERlY3J5cHREYXRhLCBnZXREZXZpY2VTaGFyZSwgZ2V0VG9ydXNTaGFyZSwga2VjY2FrMjU2LCBzZXREZXZpY2VTaGFyZSwgc2V0VG9ydXNTaGFyZSB9O1xuIl0sIm5hbWVzIjpbIl9vYmplY3RTcHJlYWQiLCJfZGVmaW5lUHJvcGVydHkiLCJzZXRBUElLZXkiLCJzZXRFbWJlZEhvc3QiLCJwb3N0Iiwic3RyaW5naWZ5IiwiZWMiLCJlYyQxIiwia2VjY2FrMjU2Iiwia2VjY2FrMjU2JDEiLCJlbmNyeXB0IiwiZ2V0UHVibGljIiwiZGVjcnlwdCIsImEiLCJCdWZmZXIiLCJmcm9tIiwiTWV0YWRhdGFTdG9yYWdlTGF5ZXIiLCJjb25zdHJ1Y3RvciIsIm1ldGFkYXRhSG9zdCIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsInNlcnZlclRpbWVPZmZzZXQiLCJhcGlLZXkiLCJlbWJlZEhvc3QiLCJnZW5lcmF0ZU1ldGFkYXRhUGFyYW1zIiwibWVzc2FnZSIsInByaXZhdGVLZXlIZXgiLCJfc2lnJHJlY292ZXJ5UGFyYW0kdG8iLCJfc2lnJHJlY292ZXJ5UGFyYW0iLCJrZXkiLCJrZXlGcm9tUHJpdmF0ZSIsInNldERhdGEiLCJkYXRhIiwidGltZXN0YW1wIiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsIm5vdyIsInRvU3RyaW5nIiwic2lnIiwic2lnbiIsInB1Yl9rZXlfWCIsImdldFgiLCJwdWJfa2V5X1kiLCJnZXRZIiwic2V0X2RhdGEiLCJzaWduYXR1cmUiLCJyIiwicyIsInJlY292ZXJ5UGFyYW0iLCJwYWRTdGFydCIsInNsaWNlIiwiZ2VuZXJhdGVQdWJLZXlQYXJhbXMiLCJzZXRNZXRhZGF0YSIsIm5hbWVzcGFjZSIsIm9wdGlvbnMiLCJwYXJhbXMiLCJtZXRhZGF0YVJlc3BvbnNlIiwidXNlQVBJS2V5IiwiZ2V0TWV0YWRhdGEiLCJwdWJLZXkiLCJXRUJBVVRITl9UT1JVU19TSEFSRSIsIldFQkFVVEhOX0RFVklDRV9TSEFSRSIsImVuY1BhcmFtc0hleFRvQnVmIiwiZW5jUGFyYW1zSGV4IiwiaXYiLCJlcGhlbVB1YmxpY0tleSIsImNpcGhlcnRleHQiLCJtYWMiLCJlbmNQYXJhbXNCdWZUb0hleCIsImVuY1BhcmFtcyIsImVuY3J5cHREYXRhIiwicHJpdktleUhleCIsImQiLCJzZXJpYWxpemVkRGVjIiwiSlNPTiIsInNlcmlhbGl6ZWRCdWYiLCJzRGF0YSIsImRlY3J5cHREYXRhIiwicGFyc2UiLCJrZXlQYWlyIiwiZ2V0UHJpdmF0ZSIsImdldEFuZERlY3J5cHREYXRhIiwibSIsInNlcmlhbGl6ZWREYXRhIiwiZW5jcnlwdEFuZFNldERhdGEiLCJtZXRhZGF0YVBhcmFtcyIsInNldFRvcnVzU2hhcmUiLCJ3ZWJBdXRoblB1YktleSIsIndlYkF1dGhuUmVmSGV4Iiwic3Vic3BhY2UiLCJzdWJzcGFjZURhdGEiLCJyZWZLZXlQYWlyIiwicHJpdktleSIsImtleUZyb21QdWJsaWMiLCJ4IiwieSIsInNlcmlhbGl6ZWRTdWJzcGFjZURhdGEiLCJzZXJpYWxpemVkU3Vic3BhY2VEYXRhQnVmIiwiZW5jU3Vic3BhY2VEYXRhIiwiZW5jU3Vic3BhY2VEYXRhSGV4Iiwic2V0RGV2aWNlU2hhcmUiLCJnZXRUb3J1c1NoYXJlIiwid2ViQXV0aG5LZXlIZXgiLCJnZXREZXZpY2VTaGFyZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/metadata-helpers/dist/metadataHelpers.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePostMessageStream: () => (/* binding */ BasePostMessageStream),\n/* harmony export */   EthereumProviderError: () => (/* binding */ EthereumProviderError),\n/* harmony export */   IGNORE_SUBSTREAM: () => (/* binding */ IGNORE_SUBSTREAM),\n/* harmony export */   JRPCEngine: () => (/* binding */ JRPCEngine),\n/* harmony export */   JSON_RPC_SERVER_ERROR_MESSAGE: () => (/* binding */ JSON_RPC_SERVER_ERROR_MESSAGE),\n/* harmony export */   JsonRpcError: () => (/* binding */ JsonRpcError),\n/* harmony export */   ObjectMultiplex: () => (/* binding */ ObjectMultiplex),\n/* harmony export */   PostMessageStream: () => (/* binding */ PostMessageStream),\n/* harmony export */   SafeEventEmitter: () => (/* binding */ SafeEventEmitter),\n/* harmony export */   SerializableError: () => (/* binding */ SerializableError),\n/* harmony export */   Substream: () => (/* binding */ Substream),\n/* harmony export */   createAsyncMiddleware: () => (/* binding */ createAsyncMiddleware),\n/* harmony export */   createEngineStream: () => (/* binding */ createEngineStream),\n/* harmony export */   createErrorMiddleware: () => (/* binding */ createErrorMiddleware),\n/* harmony export */   createIdRemapMiddleware: () => (/* binding */ createIdRemapMiddleware),\n/* harmony export */   createLoggerMiddleware: () => (/* binding */ createLoggerMiddleware),\n/* harmony export */   createScaffoldMiddleware: () => (/* binding */ createScaffoldMiddleware),\n/* harmony export */   createStreamMiddleware: () => (/* binding */ createStreamMiddleware),\n/* harmony export */   dataHasCause: () => (/* binding */ dataHasCause),\n/* harmony export */   errorCodes: () => (/* binding */ errorCodes),\n/* harmony export */   errorValues: () => (/* binding */ errorValues),\n/* harmony export */   getMessageFromCode: () => (/* binding */ getMessageFromCode),\n/* harmony export */   getRpcPromiseCallback: () => (/* binding */ getRpcPromiseCallback),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isValidCode: () => (/* binding */ isValidCode),\n/* harmony export */   isValidString: () => (/* binding */ isValidString),\n/* harmony export */   mergeMiddleware: () => (/* binding */ mergeMiddleware),\n/* harmony export */   providerAsMiddleware: () => (/* binding */ providerAsMiddleware),\n/* harmony export */   providerErrors: () => (/* binding */ providerErrors),\n/* harmony export */   providerFromEngine: () => (/* binding */ providerFromEngine),\n/* harmony export */   providerFromMiddleware: () => (/* binding */ providerFromMiddleware),\n/* harmony export */   rpcErrors: () => (/* binding */ rpcErrors),\n/* harmony export */   serializeCause: () => (/* binding */ serializeCause),\n/* harmony export */   serializeError: () => (/* binding */ serializeError),\n/* harmony export */   setupMultiplex: () => (/* binding */ setupMultiplex)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var readable_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! readable-stream */ \"(ssr)/./node_modules/readable-stream/lib/ours/index.js\");\n/* harmony import */ var readable_stream__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(readable_stream__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-safe-stringify */ \"(ssr)/./node_modules/fast-safe-stringify/index.js\");\n/* harmony import */ var fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var end_of_stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! end-of-stream */ \"(ssr)/./node_modules/end-of-stream/index.js\");\n/* harmony import */ var end_of_stream__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(end_of_stream__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! once */ \"(ssr)/./node_modules/once/once.js\");\n/* harmony import */ var once__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(once__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! pump */ \"(ssr)/./node_modules/pump/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_7__);\n\n\n\n\n\n\n\n\nfunction noop() {\n    return undefined;\n}\nconst SYN = \"SYN\";\nconst ACK = \"ACK\";\nconst BRK = \"BRK\";\nclass BasePostMessageStream extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(_ref){\n        let { name, target, targetWindow = window, targetOrigin = \"*\" } = _ref;\n        super({\n            objectMode: true\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_init\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_haveSyn\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_name\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_target\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_targetWindow\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_targetOrigin\", void 0);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_onMessage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_synIntervalId\", void 0);\n        if (!name || !target) {\n            throw new Error(\"Invalid input.\");\n        }\n        this._init = false;\n        this._haveSyn = false;\n        this._name = name;\n        this._target = target; // target origin\n        this._targetWindow = targetWindow;\n        this._targetOrigin = targetOrigin;\n        this._onMessage = this.onMessage.bind(this);\n        this._synIntervalId = null;\n        window.addEventListener(\"message\", this._onMessage, false);\n        this._handShake();\n    }\n    _break() {\n        this.cork();\n        this._write(BRK, null, noop);\n        this._haveSyn = false;\n        this._init = false;\n    }\n    _handShake() {\n        this._write(SYN, null, noop);\n        this.cork();\n    }\n    _onData(data) {\n        if (!this._init) {\n            // listen for handshake\n            if (data === SYN) {\n                this._haveSyn = true;\n                this._write(ACK, null, noop);\n            } else if (data === ACK) {\n                this._init = true;\n                if (!this._haveSyn) {\n                    this._write(ACK, null, noop);\n                }\n                this.uncork();\n            }\n        } else if (data === BRK) {\n            this._break();\n        } else {\n            // forward message\n            try {\n                this.push(data);\n            } catch (err) {\n                this.emit(\"error\", err);\n            }\n        }\n    }\n    _postMessage(data) {\n        const originConstraint = this._targetOrigin;\n        this._targetWindow.postMessage({\n            target: this._target,\n            data\n        }, originConstraint);\n    }\n    onMessage(event) {\n        const message = event.data;\n        // validate message\n        if (this._targetOrigin !== \"*\" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || typeof message !== \"object\" || message.target !== this._name || !message.data) {\n            return;\n        }\n        this._onData(message.data);\n    }\n    _read() {\n        return undefined;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _write(data, _, cb) {\n        this._postMessage(data);\n        cb();\n    }\n    _destroy() {\n        window.removeEventListener(\"message\", this._onMessage, false);\n    }\n}\nconst errorCodes = {\n    rpc: {\n        invalidInput: -32000,\n        resourceNotFound: -32001,\n        resourceUnavailable: -32002,\n        transactionRejected: -32003,\n        methodNotSupported: -32004,\n        limitExceeded: -32005,\n        parse: -32700,\n        invalidRequest: -32600,\n        methodNotFound: -32601,\n        invalidParams: -32602,\n        internal: -32603\n    },\n    provider: {\n        userRejectedRequest: 4001,\n        unauthorized: 4100,\n        unsupportedMethod: 4200,\n        disconnected: 4900,\n        chainDisconnected: 4901\n    }\n};\nconst errorValues = {\n    \"-32700\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n    },\n    \"-32600\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The JSON sent is not a valid Request object.\"\n    },\n    \"-32601\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The method does not exist / is not available.\"\n    },\n    \"-32602\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid method parameter(s).\"\n    },\n    \"-32603\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Internal JSON-RPC error.\"\n    },\n    \"-32000\": {\n        standard: \"EIP-1474\",\n        message: \"Invalid input.\"\n    },\n    \"-32001\": {\n        standard: \"EIP-1474\",\n        message: \"Resource not found.\"\n    },\n    \"-32002\": {\n        standard: \"EIP-1474\",\n        message: \"Resource unavailable.\"\n    },\n    \"-32003\": {\n        standard: \"EIP-1474\",\n        message: \"Transaction rejected.\"\n    },\n    \"-32004\": {\n        standard: \"EIP-1474\",\n        message: \"Method not supported.\"\n    },\n    \"-32005\": {\n        standard: \"EIP-1474\",\n        message: \"Request limit exceeded.\"\n    },\n    \"4001\": {\n        standard: \"EIP-1193\",\n        message: \"User rejected the request.\"\n    },\n    \"4100\": {\n        standard: \"EIP-1193\",\n        message: \"The requested account and/or method has not been authorized by the user.\"\n    },\n    \"4200\": {\n        standard: \"EIP-1193\",\n        message: \"The requested method is not supported by this Ethereum provider.\"\n    },\n    \"4900\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from all chains.\"\n    },\n    \"4901\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from the specified chain.\"\n    }\n};\nconst FALLBACK_ERROR_CODE = errorCodes.rpc.internal;\nconst FALLBACK_MESSAGE = \"Unspecified error message. This is a bug, please report it.\";\nconst JSON_RPC_SERVER_ERROR_MESSAGE = \"Unspecified server error.\";\n/**\n * Returns whether the given code is valid.\n * A code is valid if it is an integer.\n *\n * @param code - The error code.\n * @returns Whether the given code is valid.\n */ function isValidCode(code) {\n    return Number.isInteger(code);\n}\nfunction isValidString(value) {\n    return typeof value === \"string\" && value.length > 0;\n}\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */ function isObject(value) {\n    return Boolean(value) && typeof value === \"object\" && !Array.isArray(value);\n}\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */ function isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while(Object.getPrototypeOf(proto) !== null){\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    } catch (_) {\n        return false;\n    }\n}\n/**\n * Check if the given code is a valid JSON-RPC server error code.\n *\n * @param code - The error code.\n * @returns Whether the given code is a valid JSON-RPC server error code.\n */ function isJsonRpcServerError(code) {\n    return code >= -32099 && code <= -32000;\n}\nfunction isJsonRpcError(value) {\n    const castValue = value;\n    if (!castValue) return false;\n    if (!isValidCode(castValue.code) || !isValidString(castValue.message)) return false;\n    if (castValue.stack && !isValidString(castValue.stack)) return false;\n    return true;\n}\n/**\n * Gets the message for a given code, or a fallback message if the code has\n * no corresponding message.\n *\n * @param code - The error code.\n * @param fallbackMessage - The fallback message to use if the code has no\n * corresponding message.\n * @returns The message for the given code, or the fallback message if the code\n * has no corresponding message.\n */ function getMessageFromCode(code) {\n    let fallbackMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FALLBACK_MESSAGE;\n    if (isValidCode(code)) {\n        const codeString = code.toString();\n        if (Object.hasOwn(errorValues, codeString)) {\n            return errorValues[codeString].message;\n        }\n        if (isJsonRpcServerError(code)) {\n            return JSON_RPC_SERVER_ERROR_MESSAGE;\n        }\n    }\n    return fallbackMessage;\n}\nconst FALLBACK_ERROR = {\n    code: FALLBACK_ERROR_CODE,\n    message: getMessageFromCode(FALLBACK_ERROR_CODE)\n};\nfunction isValidJson(str) {\n    try {\n        JSON.parse(JSON.stringify(str, (strKey, strVal)=>{\n            if (strKey === \"__proto__\" || strKey === \"constructor\") {\n                throw new Error(\"Not valid json\");\n            }\n            if (typeof strVal === \"function\" || typeof strVal === \"symbol\") {\n                throw new Error(\"Not valid json\");\n            }\n            return strVal;\n        }), (propKey, propValue)=>{\n            // Strip __proto__ and constructor properties to prevent prototype pollution.\n            if (propKey === \"__proto__\" || propKey === \"constructor\") {\n                return undefined;\n            }\n            return propValue;\n        });\n    // this means, it's a valid json so far\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\n/**\n * Extracts all JSON-serializable properties from an object.\n *\n * @param object - The object in question.\n * @returns An object containing all the JSON-serializable properties.\n */ function serializeObject(object) {\n    return Object.getOwnPropertyNames(object).reduce((acc, key)=>{\n        const value = object[key];\n        if (isValidJson(value)) {\n            acc[key] = value;\n        }\n        return acc;\n    }, {});\n}\n/**\n * Serializes an unknown error to be used as the `cause` in a fallback error.\n *\n * @param error - The unknown error.\n * @returns A JSON-serializable object containing as much information about the original error as possible.\n */ function serializeCause(error) {\n    if (Array.isArray(error)) {\n        return error.map((entry)=>{\n            if (isValidJson(entry)) {\n                return entry;\n            } else if (isObject(entry)) {\n                return serializeObject(entry);\n            }\n            return null;\n        });\n    } else if (isObject(error)) {\n        return serializeObject(error);\n    }\n    if (isValidJson(error)) {\n        return error;\n    }\n    return null;\n}\n/**\n * Construct a JSON-serializable object given an error and a JSON serializable `fallbackError`\n *\n * @param error - The error in question.\n * @param fallbackError - A JSON serializable fallback error.\n * @returns A JSON serializable error object.\n */ function buildError(error, fallbackError) {\n    // If an error specifies a `serialize` function, we call it and return the result.\n    if (error && typeof error === \"object\" && \"serialize\" in error && typeof error.serialize === \"function\") {\n        return error.serialize();\n    }\n    if (isJsonRpcError(error)) {\n        return error;\n    }\n    // If the error does not match the JsonRpcError type, use the fallback error, but try to include the original error as `cause`.\n    const cause = serializeCause(error);\n    const fallbackWithCause = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, fallbackError), {}, {\n        data: {\n            cause\n        }\n    });\n    return fallbackWithCause;\n}\n/**\n * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n * If the given error is not fully compatible, it will be preserved on the\n * returned object's data.cause property.\n *\n * @param error - The error to serialize.\n * @param options - Options bag.\n * @param options.fallbackError - The error to return if the given error is\n * not compatible. Should be a JSON serializable value.\n * @param options.shouldIncludeStack - Whether to include the error's stack\n * on the returned object.\n * @returns The serialized error.\n */ function serializeError(error) {\n    let { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!isJsonRpcError(fallbackError)) {\n        throw new Error(\"Must provide fallback error with integer number code and string message.\");\n    }\n    const serialized = buildError(error, fallbackError);\n    if (!shouldIncludeStack) {\n        delete serialized.stack;\n    }\n    return serialized;\n}\n/**\n * Returns true if supplied error data has a usable `cause` property; false otherwise.\n *\n * @param data - Optional data to validate.\n * @returns Whether cause property is present and an object.\n */ function dataHasCause(data) {\n    return isObject(data) && Object.hasOwn(data, \"cause\") && isObject(data.cause);\n}\n/**\n * Check if the given code is a valid JSON-RPC error code.\n *\n * @param code - The code to check.\n * @returns Whether the code is valid.\n */ function isValidEthProviderCode(code) {\n    return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\n/**\n * A JSON replacer function that omits circular references.\n *\n * @param _ - The key being replaced.\n * @param value - The value being replaced.\n * @returns The value to use in place of the original value.\n */ function stringifyReplacer(_, value) {\n    if (value === \"[Circular]\") {\n        return undefined;\n    }\n    return value;\n}\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP-1474.\n *\n * Permits any integer error code.\n */ class JsonRpcError extends Error {\n    constructor(code, message, data){\n        if (!Number.isInteger(code)) {\n            throw new Error('\"code\" must be an integer.');\n        }\n        if (!message || typeof message !== \"string\") {\n            throw new Error('\"message\" must be a non-empty string.');\n        }\n        if (dataHasCause(data)) {\n            super(message, {\n                cause: data.cause\n            });\n            // Browser backwards-compatibility fallback\n            // The `cause` definition can be removed when tsconfig lib and/or target have changed to >=es2022\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"cause\", void 0);\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"data\", void 0);\n            if (!Object.hasOwn(this, \"cause\")) {\n                Object.assign(this, {\n                    cause: data.cause\n                });\n            }\n        } else {\n            super(message);\n            // The `cause` definition can be removed when tsconfig lib and/or target have changed to >=es2022\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"cause\", void 0);\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n            _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"data\", void 0);\n        }\n        if (data !== undefined) {\n            this.data = data;\n        }\n        this.code = code;\n        this.cause = data === null || data === void 0 ? void 0 : data.cause;\n    }\n    /**\n   * Get the error as JSON-serializable object.\n   *\n   * @returns A plain object with all public class properties.\n   */ serialize() {\n        const serialized = {\n            code: this.code,\n            message: this.message\n        };\n        if (this.data !== undefined) {\n            // `this.data` is not guaranteed to be a plain object, but this simplifies\n            // the type guard below. We can safely cast it because we know it's a\n            // JSON-serializable value.\n            serialized.data = this.data;\n            if (isPlainObject(this.data)) {\n                serialized.data.cause = serializeCause(this.data.cause);\n            }\n        }\n        if (this.stack) {\n            serialized.stack = this.stack;\n        }\n        return serialized;\n    }\n    /**\n   * Get a string representation of the serialized error, omitting any circular\n   * references.\n   *\n   * @returns A string representation of the serialized error.\n   */ toString() {\n        return fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2___default()(this.serialize(), stringifyReplacer, 2);\n    }\n}\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */ class EthereumProviderError extends JsonRpcError {\n    /**\n   * Create an Ethereum Provider JSON-RPC error.\n   *\n   * @param code - The JSON-RPC error code. Must be an integer in the\n   * `1000 <= n <= 4999` range.\n   * @param message - The JSON-RPC error message.\n   * @param data - Optional data to include in the error.\n   */ constructor(code, message, data){\n        if (!isValidEthProviderCode(code)) {\n            throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n        }\n        super(code, message, data);\n    }\n}\n/**\n * Get an error message and optional data from an options bag.\n *\n * @param arg - The error message or options bag.\n * @returns A tuple containing the error message and optional data.\n */ function parseOpts(arg) {\n    if (arg) {\n        if (typeof arg === \"string\") {\n            return [\n                arg\n            ];\n        } else if (typeof arg === \"object\" && !Array.isArray(arg)) {\n            const { message, data } = arg;\n            if (message && typeof message !== \"string\") {\n                throw new Error(\"Must specify string message.\");\n            }\n            return [\n                message !== null && message !== void 0 ? message : undefined,\n                data\n            ];\n        }\n    }\n    return [];\n}\n/**\n * Get a generic JSON-RPC error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link JsonRpcError} class.\n */ function getJsonRpcError(code, arg) {\n    const [message, data] = parseOpts(arg);\n    return new JsonRpcError(code, message !== null && message !== void 0 ? message : getMessageFromCode(code), data);\n}\n/**\n * Get an Ethereum Provider error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link EthereumProviderError} class.\n */ function getEthProviderError(code, arg) {\n    const [message, data] = parseOpts(arg);\n    return new EthereumProviderError(code, message !== null && message !== void 0 ? message : getMessageFromCode(code), data);\n}\nconst rpcErrors = {\n    /**\n   * Get a JSON RPC 2.0 Parse (-32700) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ parse: (arg)=>getJsonRpcError(errorCodes.rpc.parse, arg),\n    /**\n   * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ invalidRequest: (arg)=>getJsonRpcError(errorCodes.rpc.invalidRequest, arg),\n    /**\n   * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ invalidParams: (arg)=>getJsonRpcError(errorCodes.rpc.invalidParams, arg),\n    /**\n   * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ methodNotFound: (arg)=>getJsonRpcError(errorCodes.rpc.methodNotFound, arg),\n    /**\n   * Get a JSON RPC 2.0 Internal (-32603) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ internal: (arg)=>getJsonRpcError(errorCodes.rpc.internal, arg),\n    /**\n   * Get a JSON RPC 2.0 Server error.\n   * Permits integer error codes in the [ -32099 <= -32005 ] range.\n   * Codes -32000 through -32004 are reserved by EIP-1474.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ server: (opts)=>{\n        if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n            throw new Error(\"Ethereum RPC Server errors must provide single object argument.\");\n        }\n        const { code } = opts;\n        if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n            throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n        }\n        return getJsonRpcError(code, opts);\n    },\n    /**\n   * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ invalidInput: (arg)=>getJsonRpcError(errorCodes.rpc.invalidInput, arg),\n    /**\n   * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ resourceNotFound: (arg)=>getJsonRpcError(errorCodes.rpc.resourceNotFound, arg),\n    /**\n   * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ resourceUnavailable: (arg)=>getJsonRpcError(errorCodes.rpc.resourceUnavailable, arg),\n    /**\n   * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ transactionRejected: (arg)=>getJsonRpcError(errorCodes.rpc.transactionRejected, arg),\n    /**\n   * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ methodNotSupported: (arg)=>getJsonRpcError(errorCodes.rpc.methodNotSupported, arg),\n    /**\n   * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */ limitExceeded: (arg)=>getJsonRpcError(errorCodes.rpc.limitExceeded, arg)\n};\nconst providerErrors = {\n    /**\n   * Get an Ethereum Provider User Rejected Request (4001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ userRejectedRequest: (arg)=>{\n        return getEthProviderError(errorCodes.provider.userRejectedRequest, arg);\n    },\n    /**\n   * Get an Ethereum Provider Unauthorized (4100) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ unauthorized: (arg)=>{\n        return getEthProviderError(errorCodes.provider.unauthorized, arg);\n    },\n    /**\n   * Get an Ethereum Provider Unsupported Method (4200) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ unsupportedMethod: (arg)=>{\n        return getEthProviderError(errorCodes.provider.unsupportedMethod, arg);\n    },\n    /**\n   * Get an Ethereum Provider Not Connected (4900) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ disconnected: (arg)=>{\n        return getEthProviderError(errorCodes.provider.disconnected, arg);\n    },\n    /**\n   * Get an Ethereum Provider Chain Not Connected (4901) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ chainDisconnected: (arg)=>{\n        return getEthProviderError(errorCodes.provider.chainDisconnected, arg);\n    },\n    /**\n   * Get a custom Ethereum Provider error.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */ custom: (opts)=>{\n        if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n            throw new Error(\"Ethereum Provider custom errors must provide single object argument.\");\n        }\n        const { code, message, data } = opts;\n        if (!message || typeof message !== \"string\") {\n            throw new Error('\"message\" must be a nonempty string');\n        }\n        return new EthereumProviderError(code, message, data);\n    }\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */ function safeApply(handler, context, args) {\n    try {\n        Reflect.apply(handler, context, args);\n    } catch (err) {\n        // Throw error after timeout so as not to interrupt the stack\n        setTimeout(()=>{\n            throw err;\n        });\n    }\n}\nfunction arrayClone(arr) {\n    const n = arr.length;\n    const copy = new Array(n);\n    for(let i = 0; i < n; i += 1){\n        copy[i] = arr[i];\n    }\n    return copy;\n}\nclass SafeEventEmitter extends events__WEBPACK_IMPORTED_MODULE_4__.EventEmitter {\n    emit(type) {\n        let doError = type === \"error\";\n        const events = this._events;\n        if (events !== undefined) {\n            doError = doError && events.error === undefined;\n        } else if (!doError) {\n            return false;\n        }\n        // If there is no 'error' event listener then throw.\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        if (doError) {\n            let er;\n            if (args.length > 0) {\n                [er] = args;\n            }\n            if (er instanceof Error) {\n                // Note: The comments on the `throw` lines are intentional, they show\n                // up in Node's output if this results in an unhandled exception.\n                throw er; // Unhandled 'error' event\n            }\n            // At least give some kind of context to the user\n            const err = new Error(`Unhandled error.${er ? ` (${er.message})` : \"\"}`);\n            err.context = er;\n            throw err; // Unhandled 'error' event\n        }\n        const handler = events[type];\n        if (handler === undefined) {\n            return false;\n        }\n        if (typeof handler === \"function\") {\n            safeApply(handler, this, args);\n        } else {\n            const len = handler.length;\n            const listeners = arrayClone(handler);\n            for(let i = 0; i < len; i += 1){\n                safeApply(listeners[i], this, args);\n            }\n        }\n        return true;\n    }\n}\nclass SerializableError extends Error {\n    constructor(_ref){\n        let { code, message, data } = _ref;\n        if (!Number.isInteger(code)) {\n            throw new Error(\"code must be an integer\");\n        }\n        if (!message || typeof message !== \"string\") {\n            throw new Error(\"message must be string\");\n        }\n        super(message);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"code\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"data\", void 0);\n        this.code = code;\n        if (data !== undefined) {\n            this.data = data;\n        }\n    }\n    toString() {\n        return fast_safe_stringify__WEBPACK_IMPORTED_MODULE_2___default()({\n            code: this.code,\n            message: this.message,\n            data: this.data,\n            stack: this.stack\n        });\n    }\n}\nconst getRpcPromiseCallback = function(resolve, reject) {\n    let unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return (error, response)=>{\n        if (error || response.error) {\n            reject(error || response.error);\n        } else if (!unwrapResult || Array.isArray(response)) {\n            resolve(response);\n        } else {\n            resolve(response.result);\n        }\n    };\n};\nfunction createErrorMiddleware(log) {\n    return (req, res, next, end)=>{\n        try {\n            // json-rpc-engine will terminate the request when it notices this error\n            if (typeof req.method !== \"string\" || !req.method) {\n                res.error = new SerializableError({\n                    code: -32603,\n                    message: \"invalid method\"\n                });\n                end();\n                return;\n            }\n            next((done)=>{\n                const { error } = res;\n                if (!error) {\n                    return done();\n                }\n                log.error(`OpenLogin - RPC Error: ${error.message}`, error);\n                return done();\n            });\n        } catch (error) {\n            log.error(`OpenLogin - RPC Error thrown: ${error.message}`, error);\n            res.error = new SerializableError({\n                code: -32603,\n                message: error.message\n            });\n            end();\n        }\n    };\n}\nfunction createStreamMiddleware() {\n    const idMap = {};\n    function readNoop() {\n        return false;\n    }\n    const events = new SafeEventEmitter();\n    function processResponse(res) {\n        const context = idMap[res.id];\n        if (!context) {\n            throw new Error(`StreamMiddleware - Unknown response id \"${res.id}\"`);\n        }\n        delete idMap[res.id];\n        // copy whole res onto original res\n        Object.assign(context.res, res);\n        // run callback on empty stack,\n        // prevent internal stream-handler from catching errors\n        setTimeout(context.end);\n    }\n    function processNotification(res) {\n        events.emit(\"notification\", res);\n    }\n    function processMessage(res, _encoding, cb) {\n        let err;\n        try {\n            const isNotification = !res.id;\n            if (isNotification) {\n                processNotification(res);\n            } else {\n                processResponse(res);\n            }\n        } catch (_err) {\n            err = _err;\n        }\n        // continue processing stream\n        cb(err);\n    }\n    const stream = new readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex({\n        objectMode: true,\n        read: readNoop,\n        write: processMessage\n    });\n    const middleware = (req, res, next, end)=>{\n        // write req to stream\n        stream.push(req);\n        // register request on id map\n        idMap[req.id] = {\n            req,\n            res,\n            next,\n            end\n        };\n    };\n    return {\n        events,\n        middleware,\n        stream\n    };\n}\nfunction createScaffoldMiddleware(handlers) {\n    return (req, res, next, end)=>{\n        const handler = handlers[req.method];\n        // if no handler, return\n        if (handler === undefined) {\n            return next();\n        }\n        // if handler is fn, call as middleware\n        if (typeof handler === \"function\") {\n            return handler(req, res, next, end);\n        }\n        // if handler is some other value, use as result\n        res.result = handler;\n        return end();\n    };\n}\nfunction createIdRemapMiddleware() {\n    return (req, res, next, _end)=>{\n        const originalId = req.id;\n        const newId = Math.random().toString(36).slice(2);\n        req.id = newId;\n        res.id = newId;\n        next((done)=>{\n            req.id = originalId;\n            res.id = originalId;\n            done();\n        });\n    };\n}\nfunction createLoggerMiddleware(logger) {\n    return (req, res, next, _)=>{\n        logger.debug(\"REQ\", req, \"RES\", res);\n        next();\n    };\n}\nfunction createAsyncMiddleware(asyncMiddleware) {\n    return async (req, res, next, end)=>{\n        // nextPromise is the key to the implementation\n        // it is resolved by the return handler passed to the\n        // \"next\" function\n        let resolveNextPromise;\n        const nextPromise = new Promise((resolve)=>{\n            resolveNextPromise = resolve;\n        });\n        let returnHandlerCallback = null;\n        let nextWasCalled = false;\n        // This will be called by the consumer's async middleware.\n        const asyncNext = async ()=>{\n            nextWasCalled = true;\n            // We pass a return handler to next(). When it is called by the engine,\n            // the consumer's async middleware will resume executing.\n            next((runReturnHandlersCallback)=>{\n                // This callback comes from JRPCEngine._runReturnHandlers\n                returnHandlerCallback = runReturnHandlersCallback;\n                resolveNextPromise();\n            });\n            await nextPromise;\n        };\n        try {\n            await asyncMiddleware(req, res, asyncNext);\n            if (nextWasCalled) {\n                await nextPromise; // we must wait until the return handler is called\n                returnHandlerCallback(null);\n            } else {\n                end(null);\n            }\n        } catch (err) {\n            const error = err;\n            if (returnHandlerCallback) {\n                returnHandlerCallback(error);\n            } else {\n                end(error);\n            }\n        }\n    };\n}\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */ class JRPCEngine extends SafeEventEmitter {\n    constructor(){\n        super();\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_middleware\", void 0);\n        this._middleware = [];\n    }\n    /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */ static async _runAllMiddleware(req, res, middlewareStack) {\n        const returnHandlers = [];\n        let error = null;\n        let isComplete = false;\n        // Go down stack of middleware, call and collect optional returnHandlers\n        for (const middleware of middlewareStack){\n            [error, isComplete] = await JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\n            if (isComplete) {\n                break;\n            }\n        }\n        return [\n            error,\n            isComplete,\n            returnHandlers.reverse()\n        ];\n    }\n    /**\n   * Runs an individual middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * and a boolean indicating whether the request should end.\n   */ static _runMiddleware(req, res, middleware, returnHandlers) {\n        return new Promise((resolve)=>{\n            const end = (err)=>{\n                const error = err || res.error;\n                if (error) {\n                    if (typeof error === \"object\" && Object.keys(error).includes(\"stack\") === false) error.stack = \"Stack trace is not available.\";\n                    res.error = serializeError(error, {\n                        shouldIncludeStack: true,\n                        fallbackError: {\n                            message: (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString()),\n                            code: (error === null || error === void 0 ? void 0 : error.code) || -32603,\n                            stack: (error === null || error === void 0 ? void 0 : error.stack) || \"Stack trace is not available.\",\n                            data: (error === null || error === void 0 ? void 0 : error.data) || (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString())\n                        }\n                    });\n                }\n                // True indicates that the request should end\n                resolve([\n                    error,\n                    true\n                ]);\n            };\n            const next = (returnHandler)=>{\n                if (res.error) {\n                    end(res.error);\n                } else {\n                    if (returnHandler) {\n                        if (typeof returnHandler !== \"function\") {\n                            end(new SerializableError({\n                                code: -32603,\n                                message: \"JRPCEngine: 'next' return handlers must be functions\"\n                            }));\n                        }\n                        returnHandlers.push(returnHandler);\n                    }\n                    // False indicates that the request should not end\n                    resolve([\n                        null,\n                        false\n                    ]);\n                }\n            };\n            try {\n                middleware(req, res, next, end);\n            } catch (error) {\n                end(error);\n            }\n        });\n    }\n    /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   */ static async _runReturnHandlers(handlers) {\n        for (const handler of handlers){\n            await new Promise((resolve, reject)=>{\n                handler((err)=>err ? reject(err) : resolve());\n            });\n        }\n    }\n    /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   */ static _checkForCompletion(_req, res, isComplete) {\n        if (!(\"result\" in res) && !(\"error\" in res)) {\n            throw new SerializableError({\n                code: -32603,\n                message: \"Response has no error or result for request\"\n            });\n        }\n        if (!isComplete) {\n            throw new SerializableError({\n                code: -32603,\n                message: \"Nothing ended request\"\n            });\n        }\n    }\n    /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */ push(middleware) {\n        this._middleware.push(middleware);\n    }\n    /**\n   * Handle a JSON-RPC request, and return a response.\n   *\n   * @param request - The request to handle.\n   * @param callback - An error-first callback that will receive the response.\n   */ /**\n   * Handle an array of JSON-RPC requests, and return an array of responses.\n   *\n   * @param request - The requests to handle.\n   * @param callback - An error-first callback that will receive the array of\n   * responses.\n   */ /**\n   * Handle a JSON-RPC request, and return a response.\n   *\n   * @param request - The request to handle.\n   * @returns A promise that resolves with the response, or rejects with an\n   * error.\n   */ /**\n   * Handle an array of JSON-RPC requests, and return an array of responses.\n   *\n   * @param request - The requests to handle.\n   * @returns A promise that resolves with the array of responses, or rejects\n   * with an error.\n   */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    handle(req, cb) {\n        if (cb && typeof cb !== \"function\") {\n            throw new Error('\"callback\" must be a function if provided.');\n        }\n        if (Array.isArray(req)) {\n            if (cb) {\n                return this._handleBatch(req, cb);\n            }\n            return this._handleBatch(req);\n        }\n        if (cb) {\n            return this._handle(req, cb);\n        }\n        return this._promiseHandle(req);\n    }\n    /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */ asMiddleware() {\n        return async (req, res, next, end)=>{\n            try {\n                const [middlewareError, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n                if (isComplete) {\n                    await JRPCEngine._runReturnHandlers(returnHandlers);\n                    return end(middlewareError);\n                }\n                return next(async (handlerCallback)=>{\n                    try {\n                        await JRPCEngine._runReturnHandlers(returnHandlers);\n                    } catch (error) {\n                        return handlerCallback(error);\n                    }\n                    return handlerCallback();\n                });\n            } catch (error) {\n                return end(error);\n            }\n        };\n    }\n    /**\n   * Like _handle, but for batch requests.\n   */ /**\n   * Like _handle, but for batch requests.\n   */ async _handleBatch(reqs, cb) {\n        // The order here is important\n        try {\n            // 2. Wait for all requests to finish, or throw on some kind of fatal\n            // error\n            const responses = await Promise.all(// 1. Begin executing each request in the order received\n            reqs.map(this._promiseHandle.bind(this)));\n            // 3. Return batch response\n            if (cb) {\n                return cb(null, responses);\n            }\n            return responses;\n        } catch (error) {\n            if (cb) {\n                return cb(error);\n            }\n            throw error;\n        }\n    }\n    /**\n   * A promise-wrapped _handle.\n   */ _promiseHandle(req) {\n        return new Promise((resolve, reject)=>{\n            this._handle(req, (_err, res)=>{\n                // There will always be a response, and it will always have any error\n                // that is caught and propagated.\n                if (_err && res === undefined) {\n                    reject(_err);\n                } else resolve(res);\n            }).catch(reject);\n        });\n    }\n    /**\n   * Ensures that the request object is valid, processes it, and passes any\n   * error and the response object to the given callback.\n   *\n   * Does not reject.\n   */ async _handle(callerReq, cb) {\n        if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== \"object\") {\n            const error = new SerializableError({\n                code: -32603,\n                message: \"request must be plain object\"\n            });\n            return cb(error, {\n                id: undefined,\n                jsonrpc: \"2.0\",\n                error\n            });\n        }\n        if (typeof callerReq.method !== \"string\") {\n            const error = new SerializableError({\n                code: -32603,\n                message: \"method must be string\"\n            });\n            return cb(error, {\n                id: callerReq.id,\n                jsonrpc: \"2.0\",\n                error\n            });\n        }\n        const req = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, callerReq);\n        const res = {\n            id: req.id,\n            jsonrpc: req.jsonrpc\n        };\n        let error = null;\n        try {\n            await this._processRequest(req, res);\n        } catch (_error) {\n            // A request handler error, a re-thrown middleware error, or something\n            // unexpected.\n            error = _error;\n        }\n        if (error) {\n            // Ensure no result is present on an errored response\n            delete res.result;\n            if (!res.error) {\n                var _error2, _error3, _error4, _error5, _error6, _error7, _error8;\n                if (typeof error === \"object\" && Object.keys(error).includes(\"stack\") === false) error.stack = \"Stack trace is not available.\";\n                res.error = serializeError(error, {\n                    shouldIncludeStack: true,\n                    fallbackError: {\n                        message: ((_error2 = error) === null || _error2 === void 0 ? void 0 : _error2.message) || ((_error3 = error) === null || _error3 === void 0 ? void 0 : _error3.toString()),\n                        code: ((_error4 = error) === null || _error4 === void 0 ? void 0 : _error4.code) || -32603,\n                        stack: ((_error5 = error) === null || _error5 === void 0 ? void 0 : _error5.stack) || \"Stack trace is not available.\",\n                        data: ((_error6 = error) === null || _error6 === void 0 ? void 0 : _error6.data) || ((_error7 = error) === null || _error7 === void 0 ? void 0 : _error7.message) || ((_error8 = error) === null || _error8 === void 0 ? void 0 : _error8.toString())\n                    }\n                });\n            }\n        }\n        return cb(error, res);\n    }\n    /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   */ async _processRequest(req, res) {\n        const [error, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n        // Throw if \"end\" was not called, or if the response has neither a result\n        // nor an error.\n        JRPCEngine._checkForCompletion(req, res, isComplete);\n        // The return handlers should run even if an error was encountered during\n        // middleware processing.\n        await JRPCEngine._runReturnHandlers(returnHandlers);\n        // Now we re-throw the middleware processing error, if any, to catch it\n        // further up the call chain.\n        if (error) {\n            throw error;\n        }\n    }\n}\nfunction mergeMiddleware(middlewareStack) {\n    const engine = new JRPCEngine();\n    middlewareStack.forEach((middleware)=>engine.push(middleware));\n    return engine.asMiddleware();\n}\nfunction createEngineStream(opts) {\n    if (!opts || !opts.engine) {\n        throw new Error(\"Missing engine parameter!\");\n    }\n    const { engine } = opts;\n    // eslint-disable-next-line prefer-const\n    let stream;\n    function read() {\n        return undefined;\n    }\n    function write(req, _encoding, cb) {\n        engine.handle(req, (_err, res)=>{\n            stream.push(res);\n        });\n        cb();\n    }\n    stream = new readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex({\n        objectMode: true,\n        read,\n        write\n    });\n    // forward notifications\n    if (engine.on) {\n        engine.on(\"notification\", (message)=>{\n            stream.push(message);\n        });\n    }\n    return stream;\n}\nfunction providerFromEngine(engine) {\n    const provider = new SafeEventEmitter();\n    // handle both rpc send methods\n    provider.sendAsync = async (req)=>{\n        const res = await engine.handle(req);\n        if (res.error) {\n            var _res$error, _res$error2, _res$error3, _res$error4, _res$error5, _res$error6, _res$error7;\n            if (typeof res.error === \"object\" && Object.keys(res.error).includes(\"stack\") === false) res.error.stack = \"Stack trace is not available.\";\n            const err = serializeError(res.error, {\n                fallbackError: {\n                    message: ((_res$error = res.error) === null || _res$error === void 0 ? void 0 : _res$error.message) || ((_res$error2 = res.error) === null || _res$error2 === void 0 ? void 0 : _res$error2.toString()),\n                    code: ((_res$error3 = res.error) === null || _res$error3 === void 0 ? void 0 : _res$error3.code) || -32603,\n                    stack: ((_res$error4 = res.error) === null || _res$error4 === void 0 ? void 0 : _res$error4.stack) || \"Stack trace is not available.\",\n                    data: ((_res$error5 = res.error) === null || _res$error5 === void 0 ? void 0 : _res$error5.data) || ((_res$error6 = res.error) === null || _res$error6 === void 0 ? void 0 : _res$error6.message) || ((_res$error7 = res.error) === null || _res$error7 === void 0 ? void 0 : _res$error7.toString())\n                },\n                shouldIncludeStack: true\n            });\n            throw rpcErrors.internal(err);\n        }\n        return res.result;\n    };\n    provider.send = (req, callback)=>{\n        if (typeof callback !== \"function\") {\n            throw new Error('Must provide callback to \"send\" method.');\n        }\n        engine.handle(req, callback);\n    };\n    // forward notifications\n    if (engine.on) {\n        engine.on(\"notification\", (message)=>{\n            provider.emit(\"data\", null, message);\n        });\n    }\n    provider.request = async (args)=>{\n        const req = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, args), {}, {\n            id: Math.random().toString(36).slice(2),\n            jsonrpc: \"2.0\"\n        });\n        const res = await provider.sendAsync(req);\n        return res;\n    };\n    return provider;\n}\nfunction providerFromMiddleware(middleware) {\n    const engine = new JRPCEngine();\n    engine.push(middleware);\n    const provider = providerFromEngine(engine);\n    return provider;\n}\nfunction providerAsMiddleware(provider) {\n    return async (req, res, _next, end)=>{\n        // send request to provider\n        try {\n            const providerRes = await provider.sendAsync(req);\n            res.result = providerRes;\n            return end();\n        } catch (error) {\n            return end(error);\n        }\n    };\n}\nclass Substream extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(_ref){\n        let { parent, name } = _ref;\n        super({\n            objectMode: true\n        });\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_parent\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_name\", void 0);\n        this._parent = parent;\n        this._name = name;\n    }\n    /**\n   * Explicitly sets read operations to a no-op.\n   */ _read() {\n        return undefined;\n    }\n    /**\n   * Called when data should be written to this writable stream.\n   *\n   * @param chunk - Arbitrary object to write\n   * @param encoding - Encoding to use when writing payload\n   * @param callback - Called when writing is complete or an error occurs\n   */ _write(chunk, _encoding, callback) {\n        this._parent.push({\n            name: this._name,\n            data: chunk\n        });\n        callback();\n    }\n}\nconst IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\nclass ObjectMultiplex extends readable_stream__WEBPACK_IMPORTED_MODULE_1__.Duplex {\n    constructor(){\n        let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_3___default()({}, opts), {}, {\n            objectMode: true\n        }));\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_substreams\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"getStream\", void 0);\n        this._substreams = {};\n    }\n    createStream(name) {\n        // validate name\n        if (!name) {\n            throw new Error(\"ObjectMultiplex - name must not be empty\");\n        }\n        if (this._substreams[name]) {\n            throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n        }\n        // create substream\n        const substream = new Substream({\n            parent: this,\n            name\n        });\n        this._substreams[name] = substream;\n        // listen for parent stream to end\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        anyStreamEnd(this, (_error)=>substream.destroy(_error || undefined));\n        return substream;\n    }\n    // ignore streams (dont display orphaned data warning)\n    ignoreStream(name) {\n        // validate name\n        if (!name) {\n            throw new Error(\"ObjectMultiplex - name must not be empty\");\n        }\n        if (this._substreams[name]) {\n            throw new Error(`ObjectMultiplex - Substream for name \"${name}\" already exists`);\n        }\n        // set\n        this._substreams[name] = IGNORE_SUBSTREAM;\n    }\n    _read() {\n        return undefined;\n    }\n    _write(chunk, _encoding, callback) {\n        const { name, data } = chunk;\n        if (!name) {\n            window.console.warn(`ObjectMultiplex - malformed chunk without name \"${chunk}\"`);\n            return callback();\n        }\n        // get corresponding substream\n        const substream = this._substreams[name];\n        if (!substream) {\n            window.console.warn(`ObjectMultiplex - orphaned data for stream \"${name}\"`);\n            return callback();\n        }\n        // push data into substream\n        if (substream !== IGNORE_SUBSTREAM) {\n            substream.push(data);\n        }\n        return callback();\n    }\n}\n// util\nfunction anyStreamEnd(stream, _cb) {\n    const cb = once__WEBPACK_IMPORTED_MODULE_6___default()(_cb);\n    end_of_stream__WEBPACK_IMPORTED_MODULE_5___default()(stream, {\n        readable: false\n    }, cb);\n    end_of_stream__WEBPACK_IMPORTED_MODULE_5___default()(stream, {\n        writable: false\n    }, cb);\n}\nfunction setupMultiplex(stream) {\n    const mux = new ObjectMultiplex();\n    mux.getStream = function streamHelper(name) {\n        if (this._substreams[name]) {\n            return this._substreams[name];\n        }\n        return this.createStream(name);\n    };\n    pump__WEBPACK_IMPORTED_MODULE_7___default()(stream, mux, stream, (err)=>{\n        if (err) window.console.error(err);\n    });\n    return mux;\n}\nclass PostMessageStream extends BasePostMessageStream {\n    _postMessage(data) {\n        let originConstraint = this._targetOrigin;\n        if (typeof data === \"object\") {\n            const dataObj = data;\n            if (typeof dataObj.data === \"object\") {\n                const dataObjData = dataObj.data;\n                if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\n                    const dataObjDataParam = dataObjData.params[0];\n                    if (dataObjDataParam._origin) {\n                        originConstraint = dataObjDataParam._origin;\n                    }\n                    // add a constraint for the response\n                    dataObjDataParam._origin = window.location.origin;\n                }\n            }\n        }\n        this._targetWindow.postMessage({\n            target: this._target,\n            data\n        }, originConstraint);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tanJwYy9kaXN0L29wZW5sb2dpbkpycGMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDM0I7QUFDTztBQUNpQjtBQUMzQjtBQUNOO0FBQ1I7QUFDQTtBQUV4QixTQUFTUTtJQUNQLE9BQU9DO0FBQ1Q7QUFDQSxNQUFNQyxNQUFNO0FBQ1osTUFBTUMsTUFBTTtBQUNaLE1BQU1DLE1BQU07QUFDWixNQUFNQyw4QkFBOEJaLG1EQUFNQTtJQUN4Q2EsWUFBWUMsSUFBSSxDQUFFO1FBQ2hCLElBQUksRUFDRkMsSUFBSSxFQUNKQyxNQUFNLEVBQ05DLGVBQWVDLE1BQU0sRUFDckJDLGVBQWUsR0FBRyxFQUNuQixHQUFHTDtRQUNKLEtBQUssQ0FBQztZQUNKTSxZQUFZO1FBQ2Q7UUFDQXJCLDRFQUFlQSxDQUFDLElBQUksRUFBRSxTQUFTLEtBQUs7UUFDcENBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxZQUFZLEtBQUs7UUFDdkNBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxTQUFTLEtBQUs7UUFDcENBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxXQUFXLEtBQUs7UUFDdENBLDRFQUFlQSxDQUFDLElBQUksRUFBRSxpQkFBaUIsS0FBSztRQUM1Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGlCQUFpQixLQUFLO1FBQzVDLDhEQUE4RDtRQUM5REEsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGNBQWMsS0FBSztRQUN6Q0EsNEVBQWVBLENBQUMsSUFBSSxFQUFFLGtCQUFrQixLQUFLO1FBQzdDLElBQUksQ0FBQ2dCLFFBQVEsQ0FBQ0MsUUFBUTtZQUNwQixNQUFNLElBQUlLLE1BQU07UUFDbEI7UUFDQSxJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FB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QUFHN1IsT0FBTzhSLFFBQVEsQ0FBQ2hRLE1BQU07Z0JBQ25EO1lBQ0Y7UUFDRjtRQUNBLElBQUksQ0FBQ3RCLGFBQWEsQ0FBQ21CLFdBQVcsQ0FBQztZQUM3QjdCLFFBQVEsSUFBSSxDQUFDUyxPQUFPO1lBQ3BCYTtRQUNGLEdBQUdNO0lBQ0w7QUFDRjtBQUVpcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zb2wtcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9AdG9ydXNsYWJzL29wZW5sb2dpbi1qcnBjL2Rpc3Qvb3BlbmxvZ2luSnJwYy5lc20uanM/OGFhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknO1xuaW1wb3J0IHsgRHVwbGV4IH0gZnJvbSAncmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCBzYWZlU3RyaW5naWZ5IGZyb20gJ2Zhc3Qtc2FmZS1zdHJpbmdpZnknO1xuaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9vYmplY3RTcHJlYWQyJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgZW9zIGZyb20gJ2VuZC1vZi1zdHJlYW0nO1xuaW1wb3J0IG9uY2UgZnJvbSAnb25jZSc7XG5pbXBvcnQgcHVtcCBmcm9tICdwdW1wJztcblxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNvbnN0IFNZTiA9IFwiU1lOXCI7XG5jb25zdCBBQ0sgPSBcIkFDS1wiO1xuY29uc3QgQlJLID0gXCJCUktcIjtcbmNsYXNzIEJhc2VQb3N0TWVzc2FnZVN0cmVhbSBleHRlbmRzIER1cGxleCB7XG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgbmFtZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHRhcmdldFdpbmRvdyA9IHdpbmRvdyxcbiAgICAgIHRhcmdldE9yaWdpbiA9IFwiKlwiXG4gICAgfSA9IF9yZWY7XG4gICAgc3VwZXIoe1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbml0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2hhdmVTeW5cIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbmFtZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YXJnZXRcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFyZ2V0V2luZG93XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RhcmdldE9yaWdpblwiLCB2b2lkIDApO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29uTWVzc2FnZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zeW5JbnRlcnZhbElkXCIsIHZvaWQgMCk7XG4gICAgaWYgKCFuYW1lIHx8ICF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQuXCIpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0ID0gZmFsc2U7XG4gICAgdGhpcy5faGF2ZVN5biA9IGZhbHNlO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDsgLy8gdGFyZ2V0IG9yaWdpblxuICAgIHRoaXMuX3RhcmdldFdpbmRvdyA9IHRhcmdldFdpbmRvdztcbiAgICB0aGlzLl90YXJnZXRPcmlnaW4gPSB0YXJnZXRPcmlnaW47XG4gICAgdGhpcy5fb25NZXNzYWdlID0gdGhpcy5vbk1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9zeW5JbnRlcnZhbElkID0gbnVsbDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25NZXNzYWdlLCBmYWxzZSk7XG4gICAgdGhpcy5faGFuZFNoYWtlKCk7XG4gIH1cbiAgX2JyZWFrKCkge1xuICAgIHRoaXMuY29yaygpO1xuICAgIHRoaXMuX3dyaXRlKEJSSywgbnVsbCwgbm9vcCk7XG4gICAgdGhpcy5faGF2ZVN5biA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXQgPSBmYWxzZTtcbiAgfVxuICBfaGFuZFNoYWtlKCkge1xuICAgIHRoaXMuX3dyaXRlKFNZTiwgbnVsbCwgbm9vcCk7XG4gICAgdGhpcy5jb3JrKCk7XG4gIH1cbiAgX29uRGF0YShkYXRhKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0KSB7XG4gICAgICAvLyBsaXN0ZW4gZm9yIGhhbmRzaGFrZVxuICAgICAgaWYgKGRhdGEgPT09IFNZTikge1xuICAgICAgICB0aGlzLl9oYXZlU3luID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fd3JpdGUoQUNLLCBudWxsLCBub29wKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gQUNLKSB7XG4gICAgICAgIHRoaXMuX2luaXQgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuX2hhdmVTeW4pIHtcbiAgICAgICAgICB0aGlzLl93cml0ZShBQ0ssIG51bGwsIG5vb3ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5jb3JrKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSBCUkspIHtcbiAgICAgIHRoaXMuX2JyZWFrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvcndhcmQgbWVzc2FnZVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5wdXNoKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9wb3N0TWVzc2FnZShkYXRhKSB7XG4gICAgY29uc3Qgb3JpZ2luQ29uc3RyYWludCA9IHRoaXMuX3RhcmdldE9yaWdpbjtcbiAgICB0aGlzLl90YXJnZXRXaW5kb3cucG9zdE1lc3NhZ2Uoe1xuICAgICAgdGFyZ2V0OiB0aGlzLl90YXJnZXQsXG4gICAgICBkYXRhXG4gICAgfSwgb3JpZ2luQ29uc3RyYWludCk7XG4gIH1cbiAgb25NZXNzYWdlKGV2ZW50KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XG5cbiAgICAvLyB2YWxpZGF0ZSBtZXNzYWdlXG4gICAgaWYgKHRoaXMuX3RhcmdldE9yaWdpbiAhPT0gXCIqXCIgJiYgZXZlbnQub3JpZ2luICE9PSB0aGlzLl90YXJnZXRPcmlnaW4gfHwgZXZlbnQuc291cmNlICE9PSB0aGlzLl90YXJnZXRXaW5kb3cgfHwgdHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZS50YXJnZXQgIT09IHRoaXMuX25hbWUgfHwgIW1lc3NhZ2UuZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9vbkRhdGEobWVzc2FnZS5kYXRhKTtcbiAgfVxuICBfcmVhZCgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgX3dyaXRlKGRhdGEsIF8sIGNiKSB7XG4gICAgdGhpcy5fcG9zdE1lc3NhZ2UoZGF0YSk7XG4gICAgY2IoKTtcbiAgfVxuICBfZGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25NZXNzYWdlLCBmYWxzZSk7XG4gIH1cbn1cblxuY29uc3QgZXJyb3JDb2RlcyA9IHtcbiAgcnBjOiB7XG4gICAgaW52YWxpZElucHV0OiAtMzIwMDAsXG4gICAgcmVzb3VyY2VOb3RGb3VuZDogLTMyMDAxLFxuICAgIHJlc291cmNlVW5hdmFpbGFibGU6IC0zMjAwMixcbiAgICB0cmFuc2FjdGlvblJlamVjdGVkOiAtMzIwMDMsXG4gICAgbWV0aG9kTm90U3VwcG9ydGVkOiAtMzIwMDQsXG4gICAgbGltaXRFeGNlZWRlZDogLTMyMDA1LFxuICAgIHBhcnNlOiAtMzI3MDAsXG4gICAgaW52YWxpZFJlcXVlc3Q6IC0zMjYwMCxcbiAgICBtZXRob2ROb3RGb3VuZDogLTMyNjAxLFxuICAgIGludmFsaWRQYXJhbXM6IC0zMjYwMixcbiAgICBpbnRlcm5hbDogLTMyNjAzXG4gIH0sXG4gIHByb3ZpZGVyOiB7XG4gICAgdXNlclJlamVjdGVkUmVxdWVzdDogNDAwMSxcbiAgICB1bmF1dGhvcml6ZWQ6IDQxMDAsXG4gICAgdW5zdXBwb3J0ZWRNZXRob2Q6IDQyMDAsXG4gICAgZGlzY29ubmVjdGVkOiA0OTAwLFxuICAgIGNoYWluRGlzY29ubmVjdGVkOiA0OTAxXG4gIH1cbn07XG5jb25zdCBlcnJvclZhbHVlcyA9IHtcbiAgXCItMzI3MDBcIjoge1xuICAgIHN0YW5kYXJkOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBKU09OIHdhcyByZWNlaXZlZCBieSB0aGUgc2VydmVyLiBBbiBlcnJvciBvY2N1cnJlZCBvbiB0aGUgc2VydmVyIHdoaWxlIHBhcnNpbmcgdGhlIEpTT04gdGV4dC5cIlxuICB9LFxuICBcIi0zMjYwMFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiSlNPTiBSUEMgMi4wXCIsXG4gICAgbWVzc2FnZTogXCJUaGUgSlNPTiBzZW50IGlzIG5vdCBhIHZhbGlkIFJlcXVlc3Qgb2JqZWN0LlwiXG4gIH0sXG4gIFwiLTMyNjAxXCI6IHtcbiAgICBzdGFuZGFyZDogXCJKU09OIFJQQyAyLjBcIixcbiAgICBtZXNzYWdlOiBcIlRoZSBtZXRob2QgZG9lcyBub3QgZXhpc3QgLyBpcyBub3QgYXZhaWxhYmxlLlwiXG4gIH0sXG4gIFwiLTMyNjAyXCI6IHtcbiAgICBzdGFuZGFyZDogXCJKU09OIFJQQyAyLjBcIixcbiAgICBtZXNzYWdlOiBcIkludmFsaWQgbWV0aG9kIHBhcmFtZXRlcihzKS5cIlxuICB9LFxuICBcIi0zMjYwM1wiOiB7XG4gICAgc3RhbmRhcmQ6IFwiSlNPTiBSUEMgMi4wXCIsXG4gICAgbWVzc2FnZTogXCJJbnRlcm5hbCBKU09OLVJQQyBlcnJvci5cIlxuICB9LFxuICBcIi0zMjAwMFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIkludmFsaWQgaW5wdXQuXCJcbiAgfSxcbiAgXCItMzIwMDFcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xNDc0XCIsXG4gICAgbWVzc2FnZTogXCJSZXNvdXJjZSBub3QgZm91bmQuXCJcbiAgfSxcbiAgXCItMzIwMDJcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xNDc0XCIsXG4gICAgbWVzc2FnZTogXCJSZXNvdXJjZSB1bmF2YWlsYWJsZS5cIlxuICB9LFxuICBcIi0zMjAwM1wiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIlRyYW5zYWN0aW9uIHJlamVjdGVkLlwiXG4gIH0sXG4gIFwiLTMyMDA0XCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTQ3NFwiLFxuICAgIG1lc3NhZ2U6IFwiTWV0aG9kIG5vdCBzdXBwb3J0ZWQuXCJcbiAgfSxcbiAgXCItMzIwMDVcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xNDc0XCIsXG4gICAgbWVzc2FnZTogXCJSZXF1ZXN0IGxpbWl0IGV4Y2VlZGVkLlwiXG4gIH0sXG4gIFwiNDAwMVwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTExOTNcIixcbiAgICBtZXNzYWdlOiBcIlVzZXIgcmVqZWN0ZWQgdGhlIHJlcXVlc3QuXCJcbiAgfSxcbiAgXCI0MTAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTE5M1wiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIHJlcXVlc3RlZCBhY2NvdW50IGFuZC9vciBtZXRob2QgaGFzIG5vdCBiZWVuIGF1dGhvcml6ZWQgYnkgdGhlIHVzZXIuXCJcbiAgfSxcbiAgXCI0MjAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTE5M1wiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIHJlcXVlc3RlZCBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIEV0aGVyZXVtIHByb3ZpZGVyLlwiXG4gIH0sXG4gIFwiNDkwMFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTExOTNcIixcbiAgICBtZXNzYWdlOiBcIlRoZSBwcm92aWRlciBpcyBkaXNjb25uZWN0ZWQgZnJvbSBhbGwgY2hhaW5zLlwiXG4gIH0sXG4gIFwiNDkwMVwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTExOTNcIixcbiAgICBtZXNzYWdlOiBcIlRoZSBwcm92aWRlciBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgc3BlY2lmaWVkIGNoYWluLlwiXG4gIH1cbn07XG5cbmNvbnN0IEZBTExCQUNLX0VSUk9SX0NPREUgPSBlcnJvckNvZGVzLnJwYy5pbnRlcm5hbDtcbmNvbnN0IEZBTExCQUNLX01FU1NBR0UgPSBcIlVuc3BlY2lmaWVkIGVycm9yIG1lc3NhZ2UuIFRoaXMgaXMgYSBidWcsIHBsZWFzZSByZXBvcnQgaXQuXCI7XG5jb25zdCBKU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSA9IFwiVW5zcGVjaWZpZWQgc2VydmVyIGVycm9yLlwiO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGNvZGUgaXMgdmFsaWQuXG4gKiBBIGNvZGUgaXMgdmFsaWQgaWYgaXQgaXMgYW4gaW50ZWdlci5cbiAqXG4gKiBAcGFyYW0gY29kZSAtIFRoZSBlcnJvciBjb2RlLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gY29kZSBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENvZGUoY29kZSkge1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihjb2RlKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufVxuXG4vKipcbiAqIEEgdHlwZSBndWFyZCBmb3Ige0BsaW5rIFJ1bnRpbWVPYmplY3R9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCB2YWx1ZSBoYXMgYSBydW50aW1lIHR5cGUgb2YgYG9iamVjdGAgYW5kIGlzXG4gKiBuZWl0aGVyIGBudWxsYCBub3IgYW4gYEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVHJ1ZSBpZiBhbiBvYmplY3QgaXMgdGhlIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LFxuICogZmFsc2UgaWYgdGhlIG9iamVjdCBpcyBub3QgcGxhaW4gKGUuZy4gZnVuY3Rpb24pLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgcHJvdG8gPSB2YWx1ZTtcbiAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gcHJvdG87XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gY29kZSBpcyBhIHZhbGlkIEpTT04tUlBDIHNlcnZlciBlcnJvciBjb2RlLlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIGVycm9yIGNvZGUuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiBjb2RlIGlzIGEgdmFsaWQgSlNPTi1SUEMgc2VydmVyIGVycm9yIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGlzSnNvblJwY1NlcnZlckVycm9yKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gLTMyMDk5ICYmIGNvZGUgPD0gLTMyMDAwO1xufVxuZnVuY3Rpb24gaXNKc29uUnBjRXJyb3IodmFsdWUpIHtcbiAgY29uc3QgY2FzdFZhbHVlID0gdmFsdWU7XG4gIGlmICghY2FzdFZhbHVlKSByZXR1cm4gZmFsc2U7XG4gIGlmICghaXNWYWxpZENvZGUoY2FzdFZhbHVlLmNvZGUpIHx8ICFpc1ZhbGlkU3RyaW5nKGNhc3RWYWx1ZS5tZXNzYWdlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoY2FzdFZhbHVlLnN0YWNrICYmICFpc1ZhbGlkU3RyaW5nKGNhc3RWYWx1ZS5zdGFjaykpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWVzc2FnZSBmb3IgYSBnaXZlbiBjb2RlLCBvciBhIGZhbGxiYWNrIG1lc3NhZ2UgaWYgdGhlIGNvZGUgaGFzXG4gKiBubyBjb3JyZXNwb25kaW5nIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGNvZGUgLSBUaGUgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSBmYWxsYmFja01lc3NhZ2UgLSBUaGUgZmFsbGJhY2sgbWVzc2FnZSB0byB1c2UgaWYgdGhlIGNvZGUgaGFzIG5vXG4gKiBjb3JyZXNwb25kaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgbWVzc2FnZSBmb3IgdGhlIGdpdmVuIGNvZGUsIG9yIHRoZSBmYWxsYmFjayBtZXNzYWdlIGlmIHRoZSBjb2RlXG4gKiBoYXMgbm8gY29ycmVzcG9uZGluZyBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBnZXRNZXNzYWdlRnJvbUNvZGUoY29kZSkge1xuICBsZXQgZmFsbGJhY2tNZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBGQUxMQkFDS19NRVNTQUdFO1xuICBpZiAoaXNWYWxpZENvZGUoY29kZSkpIHtcbiAgICBjb25zdCBjb2RlU3RyaW5nID0gY29kZS50b1N0cmluZygpO1xuICAgIGlmIChPYmplY3QuaGFzT3duKGVycm9yVmFsdWVzLCBjb2RlU3RyaW5nKSkge1xuICAgICAgcmV0dXJuIGVycm9yVmFsdWVzW2NvZGVTdHJpbmddLm1lc3NhZ2U7XG4gICAgfVxuICAgIGlmIChpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSkge1xuICAgICAgcmV0dXJuIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsbGJhY2tNZXNzYWdlO1xufVxuY29uc3QgRkFMTEJBQ0tfRVJST1IgPSB7XG4gIGNvZGU6IEZBTExCQUNLX0VSUk9SX0NPREUsXG4gIG1lc3NhZ2U6IGdldE1lc3NhZ2VGcm9tQ29kZShGQUxMQkFDS19FUlJPUl9DT0RFKVxufTtcbmZ1bmN0aW9uIGlzVmFsaWRKc29uKHN0cikge1xuICB0cnkge1xuICAgIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc3RyLCAoc3RyS2V5LCBzdHJWYWwpID0+IHtcbiAgICAgIGlmIChzdHJLZXkgPT09IFwiX19wcm90b19fXCIgfHwgc3RyS2V5ID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHZhbGlkIGpzb25cIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHN0clZhbCA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBzdHJWYWwgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHZhbGlkIGpzb25cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyVmFsO1xuICAgIH0pLCAocHJvcEtleSwgcHJvcFZhbHVlKSA9PiB7XG4gICAgICAvLyBTdHJpcCBfX3Byb3RvX18gYW5kIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgdG8gcHJldmVudCBwcm90b3R5cGUgcG9sbHV0aW9uLlxuICAgICAgaWYgKHByb3BLZXkgPT09IFwiX19wcm90b19fXCIgfHwgcHJvcEtleSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcFZhbHVlO1xuICAgIH0pO1xuICAgIC8vIHRoaXMgbWVhbnMsIGl0J3MgYSB2YWxpZCBqc29uIHNvIGZhclxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEV4dHJhY3RzIGFsbCBKU09OLXNlcmlhbGl6YWJsZSBwcm9wZXJ0aWVzIGZyb20gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgb2JqZWN0IGluIHF1ZXN0aW9uLlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBKU09OLXNlcmlhbGl6YWJsZSBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgIGlmIChpc1ZhbGlkSnNvbih2YWx1ZSkpIHtcbiAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemVzIGFuIHVua25vd24gZXJyb3IgdG8gYmUgdXNlZCBhcyB0aGUgYGNhdXNlYCBpbiBhIGZhbGxiYWNrIGVycm9yLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSB1bmtub3duIGVycm9yLlxuICogQHJldHVybnMgQSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgY29udGFpbmluZyBhcyBtdWNoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBlcnJvciBhcyBwb3NzaWJsZS5cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplQ2F1c2UoZXJyb3IpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3IpKSB7XG4gICAgcmV0dXJuIGVycm9yLm1hcChlbnRyeSA9PiB7XG4gICAgICBpZiAoaXNWYWxpZEpzb24oZW50cnkpKSB7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZW50cnkpKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVPYmplY3QoZW50cnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZXJyb3IpKSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZU9iamVjdChlcnJvcik7XG4gIH1cbiAgaWYgKGlzVmFsaWRKc29uKGVycm9yKSkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgZ2l2ZW4gYW4gZXJyb3IgYW5kIGEgSlNPTiBzZXJpYWxpemFibGUgYGZhbGxiYWNrRXJyb3JgXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIGluIHF1ZXN0aW9uLlxuICogQHBhcmFtIGZhbGxiYWNrRXJyb3IgLSBBIEpTT04gc2VyaWFsaXphYmxlIGZhbGxiYWNrIGVycm9yLlxuICogQHJldHVybnMgQSBKU09OIHNlcmlhbGl6YWJsZSBlcnJvciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRXJyb3IoZXJyb3IsIGZhbGxiYWNrRXJyb3IpIHtcbiAgLy8gSWYgYW4gZXJyb3Igc3BlY2lmaWVzIGEgYHNlcmlhbGl6ZWAgZnVuY3Rpb24sIHdlIGNhbGwgaXQgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICBpZiAoZXJyb3IgJiYgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIFwic2VyaWFsaXplXCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLnNlcmlhbGl6ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGVycm9yLnNlcmlhbGl6ZSgpO1xuICB9XG4gIGlmIChpc0pzb25ScGNFcnJvcihlcnJvcikpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBJZiB0aGUgZXJyb3IgZG9lcyBub3QgbWF0Y2ggdGhlIEpzb25ScGNFcnJvciB0eXBlLCB1c2UgdGhlIGZhbGxiYWNrIGVycm9yLCBidXQgdHJ5IHRvIGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIGFzIGBjYXVzZWAuXG4gIGNvbnN0IGNhdXNlID0gc2VyaWFsaXplQ2F1c2UoZXJyb3IpO1xuICBjb25zdCBmYWxsYmFja1dpdGhDYXVzZSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZmFsbGJhY2tFcnJvciksIHt9LCB7XG4gICAgZGF0YToge1xuICAgICAgY2F1c2VcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmFsbGJhY2tXaXRoQ2F1c2U7XG59XG5cbi8qKlxuICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gZXJyb3IgdG8gYW4gRXRoZXJldW0gSlNPTiBSUEMtY29tcGF0aWJsZSBlcnJvciBvYmplY3QuXG4gKiBJZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgbm90IGZ1bGx5IGNvbXBhdGlibGUsIGl0IHdpbGwgYmUgcHJlc2VydmVkIG9uIHRoZVxuICogcmV0dXJuZWQgb2JqZWN0J3MgZGF0YS5jYXVzZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gc2VyaWFsaXplLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJhZy5cbiAqIEBwYXJhbSBvcHRpb25zLmZhbGxiYWNrRXJyb3IgLSBUaGUgZXJyb3IgdG8gcmV0dXJuIGlmIHRoZSBnaXZlbiBlcnJvciBpc1xuICogbm90IGNvbXBhdGlibGUuIFNob3VsZCBiZSBhIEpTT04gc2VyaWFsaXphYmxlIHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMuc2hvdWxkSW5jbHVkZVN0YWNrIC0gV2hldGhlciB0byBpbmNsdWRlIHRoZSBlcnJvcidzIHN0YWNrXG4gKiBvbiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yKGVycm9yKSB7XG4gIGxldCB7XG4gICAgZmFsbGJhY2tFcnJvciA9IEZBTExCQUNLX0VSUk9SLFxuICAgIHNob3VsZEluY2x1ZGVTdGFjayA9IHRydWVcbiAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGlmICghaXNKc29uUnBjRXJyb3IoZmFsbGJhY2tFcnJvcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZmFsbGJhY2sgZXJyb3Igd2l0aCBpbnRlZ2VyIG51bWJlciBjb2RlIGFuZCBzdHJpbmcgbWVzc2FnZS5cIik7XG4gIH1cbiAgY29uc3Qgc2VyaWFsaXplZCA9IGJ1aWxkRXJyb3IoZXJyb3IsIGZhbGxiYWNrRXJyb3IpO1xuICBpZiAoIXNob3VsZEluY2x1ZGVTdGFjaykge1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkLnN0YWNrO1xuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBzdXBwbGllZCBlcnJvciBkYXRhIGhhcyBhIHVzYWJsZSBgY2F1c2VgIHByb3BlcnR5OyBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIGRhdGEgLSBPcHRpb25hbCBkYXRhIHRvIHZhbGlkYXRlLlxuICogQHJldHVybnMgV2hldGhlciBjYXVzZSBwcm9wZXJ0eSBpcyBwcmVzZW50IGFuZCBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRhdGFIYXNDYXVzZShkYXRhKSB7XG4gIHJldHVybiBpc09iamVjdChkYXRhKSAmJiBPYmplY3QuaGFzT3duKGRhdGEsIFwiY2F1c2VcIikgJiYgaXNPYmplY3QoZGF0YS5jYXVzZSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGNvZGUgaXMgYSB2YWxpZCBKU09OLVJQQyBlcnJvciBjb2RlLlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIGNvZGUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBjb2RlIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoY29kZSkgJiYgY29kZSA+PSAxMDAwICYmIGNvZGUgPD0gNDk5OTtcbn1cblxuLyoqXG4gKiBBIEpTT04gcmVwbGFjZXIgZnVuY3Rpb24gdGhhdCBvbWl0cyBjaXJjdWxhciByZWZlcmVuY2VzLlxuICpcbiAqIEBwYXJhbSBfIC0gVGhlIGtleSBiZWluZyByZXBsYWNlZC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBiZWluZyByZXBsYWNlZC5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIG9yaWdpbmFsIHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlSZXBsYWNlcihfLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IFwiW0NpcmN1bGFyXVwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogRXJyb3Igc3ViY2xhc3MgaW1wbGVtZW50aW5nIEpTT04gUlBDIDIuMCBlcnJvcnMgYW5kIEV0aGVyZXVtIFJQQyBlcnJvcnNcbiAqIHBlciBFSVAtMTQ3NC5cbiAqXG4gKiBQZXJtaXRzIGFueSBpbnRlZ2VyIGVycm9yIGNvZGUuXG4gKi9cbmNsYXNzIEpzb25ScGNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIuJyk7XG4gICAgfVxuICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy4nKTtcbiAgICB9XG4gICAgaWYgKGRhdGFIYXNDYXVzZShkYXRhKSkge1xuICAgICAgc3VwZXIobWVzc2FnZSwge1xuICAgICAgICBjYXVzZTogZGF0YS5jYXVzZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEJyb3dzZXIgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZmFsbGJhY2tcbiAgICAgIC8vIFRoZSBgY2F1c2VgIGRlZmluaXRpb24gY2FuIGJlIHJlbW92ZWQgd2hlbiB0c2NvbmZpZyBsaWIgYW5kL29yIHRhcmdldCBoYXZlIGNoYW5nZWQgdG8gPj1lczIwMjJcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhdXNlXCIsIHZvaWQgMCk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHZvaWQgMCk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgICBpZiAoIU9iamVjdC5oYXNPd24odGhpcywgXCJjYXVzZVwiKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgICAgICBjYXVzZTogZGF0YS5jYXVzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAvLyBUaGUgYGNhdXNlYCBkZWZpbml0aW9uIGNhbiBiZSByZW1vdmVkIHdoZW4gdHNjb25maWcgbGliIGFuZC9vciB0YXJnZXQgaGF2ZSBjaGFuZ2VkIHRvID49ZXMyMDIyXG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYXVzZVwiLCB2b2lkIDApO1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB2b2lkIDApO1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB2b2lkIDApO1xuICAgIH1cbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuY2F1c2UgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuY2F1c2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlcnJvciBhcyBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgcGxhaW4gb2JqZWN0IHdpdGggYWxsIHB1YmxpYyBjbGFzcyBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICB9O1xuICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYHRoaXMuZGF0YWAgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgYSBwbGFpbiBvYmplY3QsIGJ1dCB0aGlzIHNpbXBsaWZpZXNcbiAgICAgIC8vIHRoZSB0eXBlIGd1YXJkIGJlbG93LiBXZSBjYW4gc2FmZWx5IGNhc3QgaXQgYmVjYXVzZSB3ZSBrbm93IGl0J3MgYVxuICAgICAgLy8gSlNPTi1zZXJpYWxpemFibGUgdmFsdWUuXG4gICAgICBzZXJpYWxpemVkLmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCh0aGlzLmRhdGEpKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQuZGF0YS5jYXVzZSA9IHNlcmlhbGl6ZUNhdXNlKHRoaXMuZGF0YS5jYXVzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YWNrKSB7XG4gICAgICBzZXJpYWxpemVkLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzZXJpYWxpemVkIGVycm9yLCBvbWl0dGluZyBhbnkgY2lyY3VsYXJcbiAgICogcmVmZXJlbmNlcy5cbiAgICpcbiAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNlcmlhbGl6ZWQgZXJyb3IuXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc2FmZVN0cmluZ2lmeSh0aGlzLnNlcmlhbGl6ZSgpLCBzdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gIH1cbn1cblxuLyoqXG4gKiBFcnJvciBzdWJjbGFzcyBpbXBsZW1lbnRpbmcgRXRoZXJldW0gUHJvdmlkZXIgZXJyb3JzIHBlciBFSVAtMTE5My5cbiAqIFBlcm1pdHMgaW50ZWdlciBlcnJvciBjb2RlcyBpbiB0aGUgWyAxMDAwIDw9IDQ5OTkgXSByYW5nZS5cbiAqL1xuY2xhc3MgRXRoZXJldW1Qcm92aWRlckVycm9yIGV4dGVuZHMgSnNvblJwY0Vycm9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBFdGhlcmV1bSBQcm92aWRlciBKU09OLVJQQyBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGNvZGUgLSBUaGUgSlNPTi1SUEMgZXJyb3IgY29kZS4gTXVzdCBiZSBhbiBpbnRlZ2VyIGluIHRoZVxuICAgKiBgMTAwMCA8PSBuIDw9IDQ5OTlgIHJhbmdlLlxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBKU09OLVJQQyBlcnJvciBtZXNzYWdlLlxuICAgKiBAcGFyYW0gZGF0YSAtIE9wdGlvbmFsIGRhdGEgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgaWYgKCFpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlciBzdWNoIHRoYXQ6IDEwMDAgPD0gY29kZSA8PSA0OTk5Jyk7XG4gICAgfVxuICAgIHN1cGVyKGNvZGUsIG1lc3NhZ2UsIGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGFuIGVycm9yIG1lc3NhZ2UgYW5kIG9wdGlvbmFsIGRhdGEgZnJvbSBhbiBvcHRpb25zIGJhZy5cbiAqXG4gKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gKiBAcmV0dXJucyBBIHR1cGxlIGNvbnRhaW5pbmcgdGhlIGVycm9yIG1lc3NhZ2UgYW5kIG9wdGlvbmFsIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT3B0cyhhcmcpIHtcbiAgaWYgKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gW2FyZ107XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgZGF0YVxuICAgICAgfSA9IGFyZztcbiAgICAgIGlmIChtZXNzYWdlICYmIHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3Qgc3BlY2lmeSBzdHJpbmcgbWVzc2FnZS5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gW21lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IHVuZGVmaW5lZCwgZGF0YV07XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBHZXQgYSBnZW5lcmljIEpTT04tUlBDIGVycm9yIGNsYXNzIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGdldEpzb25ScGNFcnJvcihjb2RlLCBhcmcpIHtcbiAgY29uc3QgW21lc3NhZ2UsIGRhdGFdID0gcGFyc2VPcHRzKGFyZyk7XG4gIHJldHVybiBuZXcgSnNvblJwY0Vycm9yKGNvZGUsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGdldE1lc3NhZ2VGcm9tQ29kZShjb2RlKSwgZGF0YSk7XG59XG5cbi8qKlxuICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9yIGNsYXNzIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGdldEV0aFByb3ZpZGVyRXJyb3IoY29kZSwgYXJnKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBkYXRhXSA9IHBhcnNlT3B0cyhhcmcpO1xuICByZXR1cm4gbmV3IEV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBnZXRNZXNzYWdlRnJvbUNvZGUoY29kZSksIGRhdGEpO1xufVxuY29uc3QgcnBjRXJyb3JzID0ge1xuICAvKipcbiAgICogR2V0IGEgSlNPTiBSUEMgMi4wIFBhcnNlICgtMzI3MDApIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIHBhcnNlOiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLnBhcnNlLCBhcmcpLFxuICAvKipcbiAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUmVxdWVzdCAoLTMyNjAwKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBpbnZhbGlkUmVxdWVzdDogYXJnID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5pbnZhbGlkUmVxdWVzdCwgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnZhbGlkIFBhcmFtcyAoLTMyNjAyKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBpbnZhbGlkUGFyYW1zOiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmludmFsaWRQYXJhbXMsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgTWV0aG9kIE5vdCBGb3VuZCAoLTMyNjAxKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBtZXRob2ROb3RGb3VuZDogYXJnID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5tZXRob2ROb3RGb3VuZCwgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnRlcm5hbCAoLTMyNjAzKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBpbnRlcm5hbDogYXJnID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5pbnRlcm5hbCwgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhIEpTT04gUlBDIDIuMCBTZXJ2ZXIgZXJyb3IuXG4gICAqIFBlcm1pdHMgaW50ZWdlciBlcnJvciBjb2RlcyBpbiB0aGUgWyAtMzIwOTkgPD0gLTMyMDA1IF0gcmFuZ2UuXG4gICAqIENvZGVzIC0zMjAwMCB0aHJvdWdoIC0zMjAwNCBhcmUgcmVzZXJ2ZWQgYnkgRUlQLTE0NzQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRzIC0gVGhlIGVycm9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBzZXJ2ZXI6IG9wdHMgPT4ge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdGhlcmV1bSBSUEMgU2VydmVyIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvZGVcbiAgICB9ID0gb3B0cztcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkgfHwgY29kZSA+IC0zMjAwNSB8fCBjb2RlIDwgLTMyMDk5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlciBzdWNoIHRoYXQ6IC0zMjA5OSA8PSBjb2RlIDw9IC0zMjAwNScpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblJwY0Vycm9yKGNvZGUsIG9wdHMpO1xuICB9LFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIEludmFsaWQgSW5wdXQgKC0zMjAwMCkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgaW52YWxpZElucHV0OiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmludmFsaWRJbnB1dCwgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBSZXNvdXJjZSBOb3QgRm91bmQgKC0zMjAwMSkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgcmVzb3VyY2VOb3RGb3VuZDogYXJnID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5yZXNvdXJjZU5vdEZvdW5kLCBhcmcpLFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFJlc291cmNlIFVuYXZhaWxhYmxlICgtMzIwMDIpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIHJlc291cmNlVW5hdmFpbGFibGU6IGFyZyA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMucmVzb3VyY2VVbmF2YWlsYWJsZSwgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBUcmFuc2FjdGlvbiBSZWplY3RlZCAoLTMyMDAzKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICB0cmFuc2FjdGlvblJlamVjdGVkOiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLnRyYW5zYWN0aW9uUmVqZWN0ZWQsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgTWV0aG9kIE5vdCBTdXBwb3J0ZWQgKC0zMjAwNCkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgbWV0aG9kTm90U3VwcG9ydGVkOiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCwgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBMaW1pdCBFeGNlZWRlZCAoLTMyMDA1KSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBsaW1pdEV4Y2VlZGVkOiBhcmcgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmxpbWl0RXhjZWVkZWQsIGFyZylcbn07XG5jb25zdCBwcm92aWRlckVycm9ycyA9IHtcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBVc2VyIFJlamVjdGVkIFJlcXVlc3QgKDQwMDEpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRXRoZXJldW1Qcm92aWRlckVycm9yfSBjbGFzcy5cbiAgICovXG4gIHVzZXJSZWplY3RlZFJlcXVlc3Q6IGFyZyA9PiB7XG4gICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JDb2Rlcy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0LCBhcmcpO1xuICB9LFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuYXV0aG9yaXplZCAoNDEwMCkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgdW5hdXRob3JpemVkOiBhcmcgPT4ge1xuICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yQ29kZXMucHJvdmlkZXIudW5hdXRob3JpemVkLCBhcmcpO1xuICB9LFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuc3VwcG9ydGVkIE1ldGhvZCAoNDIwMCkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgdW5zdXBwb3J0ZWRNZXRob2Q6IGFyZyA9PiB7XG4gICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JDb2Rlcy5wcm92aWRlci51bnN1cHBvcnRlZE1ldGhvZCwgYXJnKTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBOb3QgQ29ubmVjdGVkICg0OTAwKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBkaXNjb25uZWN0ZWQ6IGFyZyA9PiB7XG4gICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JDb2Rlcy5wcm92aWRlci5kaXNjb25uZWN0ZWQsIGFyZyk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgQ2hhaW4gTm90IENvbm5lY3RlZCAoNDkwMSkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgY2hhaW5EaXNjb25uZWN0ZWQ6IGFyZyA9PiB7XG4gICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JDb2Rlcy5wcm92aWRlci5jaGFpbkRpc2Nvbm5lY3RlZCwgYXJnKTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldCBhIGN1c3RvbSBFdGhlcmV1bSBQcm92aWRlciBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgLSBUaGUgZXJyb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRXRoZXJldW1Qcm92aWRlckVycm9yfSBjbGFzcy5cbiAgICovXG4gIGN1c3RvbTogb3B0cyA9PiB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV0aGVyZXVtIFByb3ZpZGVyIGN1c3RvbSBlcnJvcnMgbXVzdCBwcm92aWRlIHNpbmdsZSBvYmplY3QgYXJndW1lbnQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb2RlLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGRhdGFcbiAgICB9ID0gb3B0cztcbiAgICBpZiAoIW1lc3NhZ2UgfHwgdHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlXCIgbXVzdCBiZSBhIG5vbmVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKTtcbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuZnVuY3Rpb24gc2FmZUFwcGx5KGhhbmRsZXIsIGNvbnRleHQsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICBSZWZsZWN0LmFwcGx5KGhhbmRsZXIsIGNvbnRleHQsIGFyZ3MpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBUaHJvdyBlcnJvciBhZnRlciB0aW1lb3V0IHNvIGFzIG5vdCB0byBpbnRlcnJ1cHQgdGhlIHN0YWNrXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyKSB7XG4gIGNvbnN0IG4gPSBhcnIubGVuZ3RoO1xuICBjb25zdCBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkgKz0gMSkge1xuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIGNvcHk7XG59XG5jbGFzcyBTYWZlRXZlbnRFbWl0dGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgZW1pdCh0eXBlKSB7XG4gICAgbGV0IGRvRXJyb3IgPSB0eXBlID09PSBcImVycm9yXCI7XG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZG9FcnJvciA9IGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICghZG9FcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgaWYgKGRvRXJyb3IpIHtcbiAgICAgIGxldCBlcjtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgW2VyXSA9IGFyZ3M7XG4gICAgICB9XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYFVuaGFuZGxlZCBlcnJvci4ke2VyID8gYCAoJHtlci5tZXNzYWdlfSlgIDogXCJcIn1gKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG4gICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgc2FmZUFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlcik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHNhZmVBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5jbGFzcyBTZXJpYWxpemFibGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBjb2RlLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIGRhdGFcbiAgICB9ID0gX3JlZjtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNvZGUgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICAgIH1cbiAgICBpZiAoIW1lc3NhZ2UgfHwgdHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1lc3NhZ2UgbXVzdCBiZSBzdHJpbmdcIik7XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gc2FmZVN0cmluZ2lmeSh7XG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICBzdGFjazogdGhpcy5zdGFja1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IGdldFJwY1Byb21pc2VDYWxsYmFjayA9IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgbGV0IHVud3JhcFJlc3VsdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgcmV0dXJuIChlcnJvciwgcmVzcG9uc2UpID0+IHtcbiAgICBpZiAoZXJyb3IgfHwgcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIHJlamVjdChlcnJvciB8fCByZXNwb25zZS5lcnJvcik7XG4gICAgfSBlbHNlIGlmICghdW53cmFwUmVzdWx0IHx8IEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBjcmVhdGVFcnJvck1pZGRsZXdhcmUobG9nKSB7XG4gIHJldHVybiAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBqc29uLXJwYy1lbmdpbmUgd2lsbCB0ZXJtaW5hdGUgdGhlIHJlcXVlc3Qgd2hlbiBpdCBub3RpY2VzIHRoaXMgZXJyb3JcbiAgICAgIGlmICh0eXBlb2YgcmVxLm1ldGhvZCAhPT0gXCJzdHJpbmdcIiB8fCAhcmVxLm1ldGhvZCkge1xuICAgICAgICByZXMuZXJyb3IgPSBuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICAgIGNvZGU6IC0zMjYwMyxcbiAgICAgICAgICBtZXNzYWdlOiBcImludmFsaWQgbWV0aG9kXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuZXh0KGRvbmUgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSA9IHJlcztcbiAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nLmVycm9yKGBPcGVuTG9naW4gLSBSUEMgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKGBPcGVuTG9naW4gLSBSUEMgRXJyb3IgdGhyb3duOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgcmVzLmVycm9yID0gbmV3IFNlcmlhbGl6YWJsZUVycm9yKHtcbiAgICAgICAgY29kZTogLTMyNjAzLFxuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICB9KTtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUoKSB7XG4gIGNvbnN0IGlkTWFwID0ge307XG4gIGZ1bmN0aW9uIHJlYWROb29wKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBldmVudHMgPSBuZXcgU2FmZUV2ZW50RW1pdHRlcigpO1xuICBmdW5jdGlvbiBwcm9jZXNzUmVzcG9uc2UocmVzKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGlkTWFwW3Jlcy5pZF07XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmVhbU1pZGRsZXdhcmUgLSBVbmtub3duIHJlc3BvbnNlIGlkIFwiJHtyZXMuaWR9XCJgKTtcbiAgICB9XG4gICAgZGVsZXRlIGlkTWFwW3Jlcy5pZF07XG4gICAgLy8gY29weSB3aG9sZSByZXMgb250byBvcmlnaW5hbCByZXNcbiAgICBPYmplY3QuYXNzaWduKGNvbnRleHQucmVzLCByZXMpO1xuICAgIC8vIHJ1biBjYWxsYmFjayBvbiBlbXB0eSBzdGFjayxcbiAgICAvLyBwcmV2ZW50IGludGVybmFsIHN0cmVhbS1oYW5kbGVyIGZyb20gY2F0Y2hpbmcgZXJyb3JzXG4gICAgc2V0VGltZW91dChjb250ZXh0LmVuZCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc05vdGlmaWNhdGlvbihyZXMpIHtcbiAgICBldmVudHMuZW1pdChcIm5vdGlmaWNhdGlvblwiLCByZXMpO1xuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlKHJlcywgX2VuY29kaW5nLCBjYikge1xuICAgIGxldCBlcnI7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGlzTm90aWZpY2F0aW9uID0gIXJlcy5pZDtcbiAgICAgIGlmIChpc05vdGlmaWNhdGlvbikge1xuICAgICAgICBwcm9jZXNzTm90aWZpY2F0aW9uKHJlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzUmVzcG9uc2UocmVzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICBlcnIgPSBfZXJyO1xuICAgIH1cbiAgICAvLyBjb250aW51ZSBwcm9jZXNzaW5nIHN0cmVhbVxuICAgIGNiKGVycik7XG4gIH1cbiAgY29uc3Qgc3RyZWFtID0gbmV3IER1cGxleCh7XG4gICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICByZWFkOiByZWFkTm9vcCxcbiAgICB3cml0ZTogcHJvY2Vzc01lc3NhZ2VcbiAgfSk7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgIC8vIHdyaXRlIHJlcSB0byBzdHJlYW1cbiAgICBzdHJlYW0ucHVzaChyZXEpO1xuICAgIC8vIHJlZ2lzdGVyIHJlcXVlc3Qgb24gaWQgbWFwXG4gICAgaWRNYXBbcmVxLmlkXSA9IHtcbiAgICAgIHJlcSxcbiAgICAgIHJlcyxcbiAgICAgIG5leHQsXG4gICAgICBlbmRcbiAgICB9O1xuICB9O1xuICByZXR1cm4ge1xuICAgIGV2ZW50cyxcbiAgICBtaWRkbGV3YXJlLFxuICAgIHN0cmVhbVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlKGhhbmRsZXJzKSB7XG4gIHJldHVybiAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1tyZXEubWV0aG9kXTtcbiAgICAvLyBpZiBubyBoYW5kbGVyLCByZXR1cm5cbiAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cbiAgICAvLyBpZiBoYW5kbGVyIGlzIGZuLCBjYWxsIGFzIG1pZGRsZXdhcmVcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIocmVxLCByZXMsIG5leHQsIGVuZCk7XG4gICAgfVxuICAgIC8vIGlmIGhhbmRsZXIgaXMgc29tZSBvdGhlciB2YWx1ZSwgdXNlIGFzIHJlc3VsdFxuICAgIHJlcy5yZXN1bHQgPSBoYW5kbGVyO1xuICAgIHJldHVybiBlbmQoKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlKCkge1xuICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0LCBfZW5kKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxJZCA9IHJlcS5pZDtcbiAgICBjb25zdCBuZXdJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuICAgIHJlcS5pZCA9IG5ld0lkO1xuICAgIHJlcy5pZCA9IG5ld0lkO1xuICAgIG5leHQoZG9uZSA9PiB7XG4gICAgICByZXEuaWQgPSBvcmlnaW5hbElkO1xuICAgICAgcmVzLmlkID0gb3JpZ2luYWxJZDtcbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUobG9nZ2VyKSB7XG4gIHJldHVybiAocmVxLCByZXMsIG5leHQsIF8pID0+IHtcbiAgICBsb2dnZXIuZGVidWcoXCJSRVFcIiwgcmVxLCBcIlJFU1wiLCByZXMpO1xuICAgIG5leHQoKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luY01pZGRsZXdhcmUpIHtcbiAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7XG4gICAgLy8gbmV4dFByb21pc2UgaXMgdGhlIGtleSB0byB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAvLyBpdCBpcyByZXNvbHZlZCBieSB0aGUgcmV0dXJuIGhhbmRsZXIgcGFzc2VkIHRvIHRoZVxuICAgIC8vIFwibmV4dFwiIGZ1bmN0aW9uXG4gICAgbGV0IHJlc29sdmVOZXh0UHJvbWlzZTtcbiAgICBjb25zdCBuZXh0UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgcmVzb2x2ZU5leHRQcm9taXNlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBsZXQgcmV0dXJuSGFuZGxlckNhbGxiYWNrID0gbnVsbDtcbiAgICBsZXQgbmV4dFdhc0NhbGxlZCA9IGZhbHNlO1xuXG4gICAgLy8gVGhpcyB3aWxsIGJlIGNhbGxlZCBieSB0aGUgY29uc3VtZXIncyBhc3luYyBtaWRkbGV3YXJlLlxuICAgIGNvbnN0IGFzeW5jTmV4dCA9IGFzeW5jICgpID0+IHtcbiAgICAgIG5leHRXYXNDYWxsZWQgPSB0cnVlO1xuXG4gICAgICAvLyBXZSBwYXNzIGEgcmV0dXJuIGhhbmRsZXIgdG8gbmV4dCgpLiBXaGVuIGl0IGlzIGNhbGxlZCBieSB0aGUgZW5naW5lLFxuICAgICAgLy8gdGhlIGNvbnN1bWVyJ3MgYXN5bmMgbWlkZGxld2FyZSB3aWxsIHJlc3VtZSBleGVjdXRpbmcuXG5cbiAgICAgIG5leHQocnVuUmV0dXJuSGFuZGxlcnNDYWxsYmFjayA9PiB7XG4gICAgICAgIC8vIFRoaXMgY2FsbGJhY2sgY29tZXMgZnJvbSBKUlBDRW5naW5lLl9ydW5SZXR1cm5IYW5kbGVyc1xuICAgICAgICByZXR1cm5IYW5kbGVyQ2FsbGJhY2sgPSBydW5SZXR1cm5IYW5kbGVyc0NhbGxiYWNrO1xuICAgICAgICByZXNvbHZlTmV4dFByb21pc2UoKTtcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgbmV4dFByb21pc2U7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYXN5bmNNaWRkbGV3YXJlKHJlcSwgcmVzLCBhc3luY05leHQpO1xuICAgICAgaWYgKG5leHRXYXNDYWxsZWQpIHtcbiAgICAgICAgYXdhaXQgbmV4dFByb21pc2U7IC8vIHdlIG11c3Qgd2FpdCB1bnRpbCB0aGUgcmV0dXJuIGhhbmRsZXIgaXMgY2FsbGVkXG4gICAgICAgIHJldHVybkhhbmRsZXJDYWxsYmFjayhudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZChudWxsKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gZXJyO1xuICAgICAgaWYgKHJldHVybkhhbmRsZXJDYWxsYmFjaykge1xuICAgICAgICByZXR1cm5IYW5kbGVyQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQSBKU09OLVJQQyByZXF1ZXN0IGFuZCByZXNwb25zZSBwcm9jZXNzb3IuXG4gKiBHaXZlIGl0IGEgc3RhY2sgb2YgbWlkZGxld2FyZSwgcGFzcyBpdCByZXF1ZXN0cywgYW5kIGdldCBiYWNrIHJlc3BvbnNlcy5cbiAqL1xuY2xhc3MgSlJQQ0VuZ2luZSBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9taWRkbGV3YXJlXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5fbWlkZGxld2FyZSA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGx5IGV4ZWN1dGVzIHRoZSBnaXZlbiBzdGFjayBvZiBtaWRkbGV3YXJlLlxuICAgKlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbnkgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIG1pZGRsZXdhcmUgZXhlY3V0aW9uLFxuICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSByZXF1ZXN0IHdhcyBjb21wbGV0ZWQsIGFuZCBhbiBhcnJheSBvZlxuICAgKiBtaWRkbGV3YXJlLWRlZmluZWQgcmV0dXJuIGhhbmRsZXJzLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIF9ydW5BbGxNaWRkbGV3YXJlKHJlcSwgcmVzLCBtaWRkbGV3YXJlU3RhY2spIHtcbiAgICBjb25zdCByZXR1cm5IYW5kbGVycyA9IFtdO1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgbGV0IGlzQ29tcGxldGUgPSBmYWxzZTtcblxuICAgIC8vIEdvIGRvd24gc3RhY2sgb2YgbWlkZGxld2FyZSwgY2FsbCBhbmQgY29sbGVjdCBvcHRpb25hbCByZXR1cm5IYW5kbGVyc1xuICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiBtaWRkbGV3YXJlU3RhY2spIHtcbiAgICAgIFtlcnJvciwgaXNDb21wbGV0ZV0gPSBhd2FpdCBKUlBDRW5naW5lLl9ydW5NaWRkbGV3YXJlKHJlcSwgcmVzLCBtaWRkbGV3YXJlLCByZXR1cm5IYW5kbGVycyk7XG4gICAgICBpZiAoaXNDb21wbGV0ZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtlcnJvciwgaXNDb21wbGV0ZSwgcmV0dXJuSGFuZGxlcnMucmV2ZXJzZSgpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIGFuIGluZGl2aWR1YWwgbWlkZGxld2FyZS5cbiAgICpcbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYW55IGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBtaWRkbGV3YXJlIGV4ZWN1dGlvbixcbiAgICogYW5kIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHJlcXVlc3Qgc2hvdWxkIGVuZC5cbiAgICovXG4gIHN0YXRpYyBfcnVuTWlkZGxld2FyZShyZXEsIHJlcywgbWlkZGxld2FyZSwgcmV0dXJuSGFuZGxlcnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBlbmQgPSBlcnIgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IGVyciB8fCByZXMuZXJyb3I7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMoZXJyb3IpLmluY2x1ZGVzKFwic3RhY2tcIikgPT09IGZhbHNlKSBlcnJvci5zdGFjayA9IFwiU3RhY2sgdHJhY2UgaXMgbm90IGF2YWlsYWJsZS5cIjtcbiAgICAgICAgICByZXMuZXJyb3IgPSBzZXJpYWxpemVFcnJvcihlcnJvciwge1xuICAgICAgICAgICAgc2hvdWxkSW5jbHVkZVN0YWNrOiB0cnVlLFxuICAgICAgICAgICAgZmFsbGJhY2tFcnJvcjoge1xuICAgICAgICAgICAgICBtZXNzYWdlOiAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpIHx8IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgIGNvZGU6IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuY29kZSkgfHwgLTMyNjAzLFxuICAgICAgICAgICAgICBzdGFjazogKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5zdGFjaykgfHwgXCJTdGFjayB0cmFjZSBpcyBub3QgYXZhaWxhYmxlLlwiLFxuICAgICAgICAgICAgICBkYXRhOiAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmRhdGEpIHx8IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkgfHwgKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci50b1N0cmluZygpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIHJlcXVlc3Qgc2hvdWxkIGVuZFxuICAgICAgICByZXNvbHZlKFtlcnJvciwgdHJ1ZV0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG5leHQgPSByZXR1cm5IYW5kbGVyID0+IHtcbiAgICAgICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgICAgIGVuZChyZXMuZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZXR1cm5IYW5kbGVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJldHVybkhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICBlbmQobmV3IFNlcmlhbGl6YWJsZUVycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiAtMzI2MDMsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJKUlBDRW5naW5lOiAnbmV4dCcgcmV0dXJuIGhhbmRsZXJzIG11c3QgYmUgZnVuY3Rpb25zXCJcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuSGFuZGxlcnMucHVzaChyZXR1cm5IYW5kbGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgcmVxdWVzdCBzaG91bGQgbm90IGVuZFxuICAgICAgICAgIHJlc29sdmUoW251bGwsIGZhbHNlXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICBtaWRkbGV3YXJlKHJlcSwgcmVzLCBuZXh0LCBlbmQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZW5kKGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxseSBleGVjdXRlcyBhcnJheSBvZiByZXR1cm4gaGFuZGxlcnMuIFRoZSByZXF1ZXN0IGFuZCByZXNwb25zZSBhcmVcbiAgICogYXNzdW1lZCB0byBiZSBpbiB0aGVpciBzY29wZS5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBfcnVuUmV0dXJuSGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaGFuZGxlcihlcnIgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcmVzcG9uc2UgaGFzIG5laXRoZXIgYSByZXN1bHQgbm9yIGFuIGVycm9yLCBvciBpZlxuICAgKiB0aGUgXCJpc0NvbXBsZXRlXCIgZmxhZyBpcyBmYWxzeS5cbiAgICovXG4gIHN0YXRpYyBfY2hlY2tGb3JDb21wbGV0aW9uKF9yZXEsIHJlcywgaXNDb21wbGV0ZSkge1xuICAgIGlmICghKFwicmVzdWx0XCIgaW4gcmVzKSAmJiAhKFwiZXJyb3JcIiBpbiByZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICBjb2RlOiAtMzI2MDMsXG4gICAgICAgIG1lc3NhZ2U6IFwiUmVzcG9uc2UgaGFzIG5vIGVycm9yIG9yIHJlc3VsdCBmb3IgcmVxdWVzdFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFpc0NvbXBsZXRlKSB7XG4gICAgICB0aHJvdyBuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICBjb2RlOiAtMzI2MDMsXG4gICAgICAgIG1lc3NhZ2U6IFwiTm90aGluZyBlbmRlZCByZXF1ZXN0XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIHRoZSBlbmdpbmUncyBtaWRkbGV3YXJlIHN0YWNrLlxuICAgKlxuICAgKiBAcGFyYW0gbWlkZGxld2FyZSAtIFRoZSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIGFkZC5cbiAgICovXG4gIHB1c2gobWlkZGxld2FyZSkge1xuICAgIHRoaXMuX21pZGRsZXdhcmUucHVzaChtaWRkbGV3YXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBKU09OLVJQQyByZXF1ZXN0LCBhbmQgcmV0dXJuIGEgcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIHJlcXVlc3QgdG8gaGFuZGxlLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBbiBlcnJvci1maXJzdCBjYWxsYmFjayB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgcmVzcG9uc2UuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYW4gYXJyYXkgb2YgSlNPTi1SUEMgcmVxdWVzdHMsIGFuZCByZXR1cm4gYW4gYXJyYXkgb2YgcmVzcG9uc2VzLlxuICAgKlxuICAgKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSByZXF1ZXN0cyB0byBoYW5kbGUuXG4gICAqIEBwYXJhbSBjYWxsYmFjayAtIEFuIGVycm9yLWZpcnN0IGNhbGxiYWNrIHRoYXQgd2lsbCByZWNlaXZlIHRoZSBhcnJheSBvZlxuICAgKiByZXNwb25zZXMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBKU09OLVJQQyByZXF1ZXN0LCBhbmQgcmV0dXJuIGEgcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIHJlcXVlc3QgdG8gaGFuZGxlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXNwb25zZSwgb3IgcmVqZWN0cyB3aXRoIGFuXG4gICAqIGVycm9yLlxuICAgKi9cblxuICAvKipcbiAgICogSGFuZGxlIGFuIGFycmF5IG9mIEpTT04tUlBDIHJlcXVlc3RzLCBhbmQgcmV0dXJuIGFuIGFycmF5IG9mIHJlc3BvbnNlcy5cbiAgICpcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgcmVxdWVzdHMgdG8gaGFuZGxlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBhcnJheSBvZiByZXNwb25zZXMsIG9yIHJlamVjdHNcbiAgICogd2l0aCBhbiBlcnJvci5cbiAgICovXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgaGFuZGxlKHJlcSwgY2IpIHtcbiAgICBpZiAoY2IgJiYgdHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJjYWxsYmFja1wiIG11c3QgYmUgYSBmdW5jdGlvbiBpZiBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVxKSkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVCYXRjaChyZXEsIGNiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVCYXRjaChyZXEpO1xuICAgIH1cbiAgICBpZiAoY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGUocmVxLCBjYik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlSGFuZGxlKHJlcSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGlzIGVuZ2luZSBhcyBhIG1pZGRsZXdhcmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgcHVzaGVkIHRvIG90aGVyXG4gICAqIGVuZ2luZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoaXMgZW5naW5lIGFzIGEgbWlkZGxld2FyZSBmdW5jdGlvbi5cbiAgICovXG4gIGFzTWlkZGxld2FyZSgpIHtcbiAgICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFttaWRkbGV3YXJlRXJyb3IsIGlzQ29tcGxldGUsIHJldHVybkhhbmRsZXJzXSA9IGF3YWl0IEpSUENFbmdpbmUuX3J1bkFsbE1pZGRsZXdhcmUocmVxLCByZXMsIHRoaXMuX21pZGRsZXdhcmUpO1xuICAgICAgICBpZiAoaXNDb21wbGV0ZSkge1xuICAgICAgICAgIGF3YWl0IEpSUENFbmdpbmUuX3J1blJldHVybkhhbmRsZXJzKHJldHVybkhhbmRsZXJzKTtcbiAgICAgICAgICByZXR1cm4gZW5kKG1pZGRsZXdhcmVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoYXN5bmMgaGFuZGxlckNhbGxiYWNrID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgSlJQQ0VuZ2luZS5fcnVuUmV0dXJuSGFuZGxlcnMocmV0dXJuSGFuZGxlcnMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlckNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZXJDYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlbmQoZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTGlrZSBfaGFuZGxlLCBidXQgZm9yIGJhdGNoIHJlcXVlc3RzLlxuICAgKi9cblxuICAvKipcbiAgICogTGlrZSBfaGFuZGxlLCBidXQgZm9yIGJhdGNoIHJlcXVlc3RzLlxuICAgKi9cblxuICBhc3luYyBfaGFuZGxlQmF0Y2gocmVxcywgY2IpIHtcbiAgICAvLyBUaGUgb3JkZXIgaGVyZSBpcyBpbXBvcnRhbnRcbiAgICB0cnkge1xuICAgICAgLy8gMi4gV2FpdCBmb3IgYWxsIHJlcXVlc3RzIHRvIGZpbmlzaCwgb3IgdGhyb3cgb24gc29tZSBraW5kIG9mIGZhdGFsXG4gICAgICAvLyBlcnJvclxuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAvLyAxLiBCZWdpbiBleGVjdXRpbmcgZWFjaCByZXF1ZXN0IGluIHRoZSBvcmRlciByZWNlaXZlZFxuICAgICAgcmVxcy5tYXAodGhpcy5fcHJvbWlzZUhhbmRsZS5iaW5kKHRoaXMpKSk7XG5cbiAgICAgIC8vIDMuIFJldHVybiBiYXRjaCByZXNwb25zZVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHJldHVybiBjYihudWxsLCByZXNwb25zZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHJldHVybiBjYihlcnJvcik7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBwcm9taXNlLXdyYXBwZWQgX2hhbmRsZS5cbiAgICovXG4gIF9wcm9taXNlSGFuZGxlKHJlcSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGUocmVxLCAoX2VyciwgcmVzKSA9PiB7XG4gICAgICAgIC8vIFRoZXJlIHdpbGwgYWx3YXlzIGJlIGEgcmVzcG9uc2UsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXZlIGFueSBlcnJvclxuICAgICAgICAvLyB0aGF0IGlzIGNhdWdodCBhbmQgcHJvcGFnYXRlZC5cbiAgICAgICAgaWYgKF9lcnIgJiYgcmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZWplY3QoX2Vycik7XG4gICAgICAgIH0gZWxzZSByZXNvbHZlKHJlcyk7XG4gICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhhdCB0aGUgcmVxdWVzdCBvYmplY3QgaXMgdmFsaWQsIHByb2Nlc3NlcyBpdCwgYW5kIHBhc3NlcyBhbnlcbiAgICogZXJyb3IgYW5kIHRoZSByZXNwb25zZSBvYmplY3QgdG8gdGhlIGdpdmVuIGNhbGxiYWNrLlxuICAgKlxuICAgKiBEb2VzIG5vdCByZWplY3QuXG4gICAqL1xuICBhc3luYyBfaGFuZGxlKGNhbGxlclJlcSwgY2IpIHtcbiAgICBpZiAoIWNhbGxlclJlcSB8fCBBcnJheS5pc0FycmF5KGNhbGxlclJlcSkgfHwgdHlwZW9mIGNhbGxlclJlcSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICBjb2RlOiAtMzI2MDMsXG4gICAgICAgIG1lc3NhZ2U6IFwicmVxdWVzdCBtdXN0IGJlIHBsYWluIG9iamVjdFwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYihlcnJvciwge1xuICAgICAgICBpZDogdW5kZWZpbmVkLFxuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGVyUmVxLm1ldGhvZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgU2VyaWFsaXphYmxlRXJyb3Ioe1xuICAgICAgICBjb2RlOiAtMzI2MDMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWV0aG9kIG11c3QgYmUgc3RyaW5nXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNiKGVycm9yLCB7XG4gICAgICAgIGlkOiBjYWxsZXJSZXEuaWQsXG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVxID0gX29iamVjdFNwcmVhZCh7fSwgY2FsbGVyUmVxKTtcbiAgICBjb25zdCByZXMgPSB7XG4gICAgICBpZDogcmVxLmlkLFxuICAgICAganNvbnJwYzogcmVxLmpzb25ycGNcbiAgICB9O1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NSZXF1ZXN0KHJlcSwgcmVzKTtcbiAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgIC8vIEEgcmVxdWVzdCBoYW5kbGVyIGVycm9yLCBhIHJlLXRocm93biBtaWRkbGV3YXJlIGVycm9yLCBvciBzb21ldGhpbmdcbiAgICAgIC8vIHVuZXhwZWN0ZWQuXG4gICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICAvLyBFbnN1cmUgbm8gcmVzdWx0IGlzIHByZXNlbnQgb24gYW4gZXJyb3JlZCByZXNwb25zZVxuICAgICAgZGVsZXRlIHJlcy5yZXN1bHQ7XG4gICAgICBpZiAoIXJlcy5lcnJvcikge1xuICAgICAgICB2YXIgX2Vycm9yMiwgX2Vycm9yMywgX2Vycm9yNCwgX2Vycm9yNSwgX2Vycm9yNiwgX2Vycm9yNywgX2Vycm9yODtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhlcnJvcikuaW5jbHVkZXMoXCJzdGFja1wiKSA9PT0gZmFsc2UpIGVycm9yLnN0YWNrID0gXCJTdGFjayB0cmFjZSBpcyBub3QgYXZhaWxhYmxlLlwiO1xuICAgICAgICByZXMuZXJyb3IgPSBzZXJpYWxpemVFcnJvcihlcnJvciwge1xuICAgICAgICAgIHNob3VsZEluY2x1ZGVTdGFjazogdHJ1ZSxcbiAgICAgICAgICBmYWxsYmFja0Vycm9yOiB7XG4gICAgICAgICAgICBtZXNzYWdlOiAoKF9lcnJvcjIgPSBlcnJvcikgPT09IG51bGwgfHwgX2Vycm9yMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Vycm9yMi5tZXNzYWdlKSB8fCAoKF9lcnJvcjMgPSBlcnJvcikgPT09IG51bGwgfHwgX2Vycm9yMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Vycm9yMy50b1N0cmluZygpKSxcbiAgICAgICAgICAgIGNvZGU6ICgoX2Vycm9yNCA9IGVycm9yKSA9PT0gbnVsbCB8fCBfZXJyb3I0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXJyb3I0LmNvZGUpIHx8IC0zMjYwMyxcbiAgICAgICAgICAgIHN0YWNrOiAoKF9lcnJvcjUgPSBlcnJvcikgPT09IG51bGwgfHwgX2Vycm9yNSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Vycm9yNS5zdGFjaykgfHwgXCJTdGFjayB0cmFjZSBpcyBub3QgYXZhaWxhYmxlLlwiLFxuICAgICAgICAgICAgZGF0YTogKChfZXJyb3I2ID0gZXJyb3IpID09PSBudWxsIHx8IF9lcnJvcjYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lcnJvcjYuZGF0YSkgfHwgKChfZXJyb3I3ID0gZXJyb3IpID09PSBudWxsIHx8IF9lcnJvcjcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lcnJvcjcubWVzc2FnZSkgfHwgKChfZXJyb3I4ID0gZXJyb3IpID09PSBudWxsIHx8IF9lcnJvcjggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lcnJvcjgudG9TdHJpbmcoKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2IoZXJyb3IsIHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogRm9yIHRoZSBnaXZlbiByZXF1ZXN0IGFuZCByZXNwb25zZSwgcnVucyBhbGwgbWlkZGxld2FyZSBhbmQgdGhlaXIgcmV0dXJuXG4gICAqIGhhbmRsZXJzLCBpZiBhbnksIGFuZCBlbnN1cmVzIHRoYXQgaW50ZXJuYWwgcmVxdWVzdCBwcm9jZXNzaW5nIHNlbWFudGljc1xuICAgKiBhcmUgc2F0aXNmaWVkLlxuICAgKi9cbiAgYXN5bmMgX3Byb2Nlc3NSZXF1ZXN0KHJlcSwgcmVzKSB7XG4gICAgY29uc3QgW2Vycm9yLCBpc0NvbXBsZXRlLCByZXR1cm5IYW5kbGVyc10gPSBhd2FpdCBKUlBDRW5naW5lLl9ydW5BbGxNaWRkbGV3YXJlKHJlcSwgcmVzLCB0aGlzLl9taWRkbGV3YXJlKTtcblxuICAgIC8vIFRocm93IGlmIFwiZW5kXCIgd2FzIG5vdCBjYWxsZWQsIG9yIGlmIHRoZSByZXNwb25zZSBoYXMgbmVpdGhlciBhIHJlc3VsdFxuICAgIC8vIG5vciBhbiBlcnJvci5cbiAgICBKUlBDRW5naW5lLl9jaGVja0ZvckNvbXBsZXRpb24ocmVxLCByZXMsIGlzQ29tcGxldGUpO1xuXG4gICAgLy8gVGhlIHJldHVybiBoYW5kbGVycyBzaG91bGQgcnVuIGV2ZW4gaWYgYW4gZXJyb3Igd2FzIGVuY291bnRlcmVkIGR1cmluZ1xuICAgIC8vIG1pZGRsZXdhcmUgcHJvY2Vzc2luZy5cbiAgICBhd2FpdCBKUlBDRW5naW5lLl9ydW5SZXR1cm5IYW5kbGVycyhyZXR1cm5IYW5kbGVycyk7XG5cbiAgICAvLyBOb3cgd2UgcmUtdGhyb3cgdGhlIG1pZGRsZXdhcmUgcHJvY2Vzc2luZyBlcnJvciwgaWYgYW55LCB0byBjYXRjaCBpdFxuICAgIC8vIGZ1cnRoZXIgdXAgdGhlIGNhbGwgY2hhaW4uXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlTWlkZGxld2FyZShtaWRkbGV3YXJlU3RhY2spIHtcbiAgY29uc3QgZW5naW5lID0gbmV3IEpSUENFbmdpbmUoKTtcbiAgbWlkZGxld2FyZVN0YWNrLmZvckVhY2gobWlkZGxld2FyZSA9PiBlbmdpbmUucHVzaChtaWRkbGV3YXJlKSk7XG4gIHJldHVybiBlbmdpbmUuYXNNaWRkbGV3YXJlKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbmdpbmVTdHJlYW0ob3B0cykge1xuICBpZiAoIW9wdHMgfHwgIW9wdHMuZW5naW5lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBlbmdpbmUgcGFyYW1ldGVyIVwiKTtcbiAgfVxuICBjb25zdCB7XG4gICAgZW5naW5lXG4gIH0gPSBvcHRzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCBzdHJlYW07XG4gIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZShyZXEsIF9lbmNvZGluZywgY2IpIHtcbiAgICBlbmdpbmUuaGFuZGxlKHJlcSwgKF9lcnIsIHJlcykgPT4ge1xuICAgICAgc3RyZWFtLnB1c2gocmVzKTtcbiAgICB9KTtcbiAgICBjYigpO1xuICB9XG4gIHN0cmVhbSA9IG5ldyBEdXBsZXgoe1xuICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgcmVhZCxcbiAgICB3cml0ZVxuICB9KTtcblxuICAvLyBmb3J3YXJkIG5vdGlmaWNhdGlvbnNcbiAgaWYgKGVuZ2luZS5vbikge1xuICAgIGVuZ2luZS5vbihcIm5vdGlmaWNhdGlvblwiLCBtZXNzYWdlID0+IHtcbiAgICAgIHN0cmVhbS5wdXNoKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBzdHJlYW07XG59XG5mdW5jdGlvbiBwcm92aWRlckZyb21FbmdpbmUoZW5naW5lKSB7XG4gIGNvbnN0IHByb3ZpZGVyID0gbmV3IFNhZmVFdmVudEVtaXR0ZXIoKTtcbiAgLy8gaGFuZGxlIGJvdGggcnBjIHNlbmQgbWV0aG9kc1xuICBwcm92aWRlci5zZW5kQXN5bmMgPSBhc3luYyByZXEgPT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGVuZ2luZS5oYW5kbGUocmVxKTtcbiAgICBpZiAocmVzLmVycm9yKSB7XG4gICAgICB2YXIgX3JlcyRlcnJvciwgX3JlcyRlcnJvcjIsIF9yZXMkZXJyb3IzLCBfcmVzJGVycm9yNCwgX3JlcyRlcnJvcjUsIF9yZXMkZXJyb3I2LCBfcmVzJGVycm9yNztcbiAgICAgIGlmICh0eXBlb2YgcmVzLmVycm9yID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKHJlcy5lcnJvcikuaW5jbHVkZXMoXCJzdGFja1wiKSA9PT0gZmFsc2UpIHJlcy5lcnJvci5zdGFjayA9IFwiU3RhY2sgdHJhY2UgaXMgbm90IGF2YWlsYWJsZS5cIjtcbiAgICAgIGNvbnN0IGVyciA9IHNlcmlhbGl6ZUVycm9yKHJlcy5lcnJvciwge1xuICAgICAgICBmYWxsYmFja0Vycm9yOiB7XG4gICAgICAgICAgbWVzc2FnZTogKChfcmVzJGVycm9yID0gcmVzLmVycm9yKSA9PT0gbnVsbCB8fCBfcmVzJGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzJGVycm9yLm1lc3NhZ2UpIHx8ICgoX3JlcyRlcnJvcjIgPSByZXMuZXJyb3IpID09PSBudWxsIHx8IF9yZXMkZXJyb3IyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzJGVycm9yMi50b1N0cmluZygpKSxcbiAgICAgICAgICBjb2RlOiAoKF9yZXMkZXJyb3IzID0gcmVzLmVycm9yKSA9PT0gbnVsbCB8fCBfcmVzJGVycm9yMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRlcnJvcjMuY29kZSkgfHwgLTMyNjAzLFxuICAgICAgICAgIHN0YWNrOiAoKF9yZXMkZXJyb3I0ID0gcmVzLmVycm9yKSA9PT0gbnVsbCB8fCBfcmVzJGVycm9yNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRlcnJvcjQuc3RhY2spIHx8IFwiU3RhY2sgdHJhY2UgaXMgbm90IGF2YWlsYWJsZS5cIixcbiAgICAgICAgICBkYXRhOiAoKF9yZXMkZXJyb3I1ID0gcmVzLmVycm9yKSA9PT0gbnVsbCB8fCBfcmVzJGVycm9yNSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcyRlcnJvcjUuZGF0YSkgfHwgKChfcmVzJGVycm9yNiA9IHJlcy5lcnJvcikgPT09IG51bGwgfHwgX3JlcyRlcnJvcjYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXMkZXJyb3I2Lm1lc3NhZ2UpIHx8ICgoX3JlcyRlcnJvcjcgPSByZXMuZXJyb3IpID09PSBudWxsIHx8IF9yZXMkZXJyb3I3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzJGVycm9yNy50b1N0cmluZygpKVxuICAgICAgICB9LFxuICAgICAgICBzaG91bGRJbmNsdWRlU3RhY2s6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgcnBjRXJyb3JzLmludGVybmFsKGVycik7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9O1xuICBwcm92aWRlci5zZW5kID0gKHJlcSwgY2FsbGJhY2spID0+IHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGNhbGxiYWNrIHRvIFwic2VuZFwiIG1ldGhvZC4nKTtcbiAgICB9XG4gICAgZW5naW5lLmhhbmRsZShyZXEsIGNhbGxiYWNrKTtcbiAgfTtcbiAgLy8gZm9yd2FyZCBub3RpZmljYXRpb25zXG4gIGlmIChlbmdpbmUub24pIHtcbiAgICBlbmdpbmUub24oXCJub3RpZmljYXRpb25cIiwgbWVzc2FnZSA9PiB7XG4gICAgICBwcm92aWRlci5lbWl0KFwiZGF0YVwiLCBudWxsLCBtZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxuICBwcm92aWRlci5yZXF1ZXN0ID0gYXN5bmMgYXJncyA9PiB7XG4gICAgY29uc3QgcmVxID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBhcmdzKSwge30sIHtcbiAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSxcbiAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICB9KTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBwcm92aWRlci5zZW5kQXN5bmMocmVxKTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICByZXR1cm4gcHJvdmlkZXI7XG59XG5mdW5jdGlvbiBwcm92aWRlckZyb21NaWRkbGV3YXJlKG1pZGRsZXdhcmUpIHtcbiAgY29uc3QgZW5naW5lID0gbmV3IEpSUENFbmdpbmUoKTtcbiAgZW5naW5lLnB1c2gobWlkZGxld2FyZSk7XG4gIGNvbnN0IHByb3ZpZGVyID0gcHJvdmlkZXJGcm9tRW5naW5lKGVuZ2luZSk7XG4gIHJldHVybiBwcm92aWRlcjtcbn1cbmZ1bmN0aW9uIHByb3ZpZGVyQXNNaWRkbGV3YXJlKHByb3ZpZGVyKSB7XG4gIHJldHVybiBhc3luYyAocmVxLCByZXMsIF9uZXh0LCBlbmQpID0+IHtcbiAgICAvLyBzZW5kIHJlcXVlc3QgdG8gcHJvdmlkZXJcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvdmlkZXJSZXMgPSBhd2FpdCBwcm92aWRlci5zZW5kQXN5bmMocmVxKTtcbiAgICAgIHJlcy5yZXN1bHQgPSBwcm92aWRlclJlcztcbiAgICAgIHJldHVybiBlbmQoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGVuZChlcnJvcik7XG4gICAgfVxuICB9O1xufVxuXG5jbGFzcyBTdWJzdHJlYW0gZXh0ZW5kcyBEdXBsZXgge1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcmVudCxcbiAgICAgIG5hbWVcbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcih7XG4gICAgICBvYmplY3RNb2RlOiB0cnVlXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhcmVudFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9uYW1lXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxpY2l0bHkgc2V0cyByZWFkIG9wZXJhdGlvbnMgdG8gYSBuby1vcC5cbiAgICovXG4gIF9yZWFkKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gZGF0YSBzaG91bGQgYmUgd3JpdHRlbiB0byB0aGlzIHdyaXRhYmxlIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIGNodW5rIC0gQXJiaXRyYXJ5IG9iamVjdCB0byB3cml0ZVxuICAgKiBAcGFyYW0gZW5jb2RpbmcgLSBFbmNvZGluZyB0byB1c2Ugd2hlbiB3cml0aW5nIHBheWxvYWRcbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGVkIHdoZW4gd3JpdGluZyBpcyBjb21wbGV0ZSBvciBhbiBlcnJvciBvY2N1cnNcbiAgICovXG4gIF93cml0ZShjaHVuaywgX2VuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3BhcmVudC5wdXNoKHtcbiAgICAgIG5hbWU6IHRoaXMuX25hbWUsXG4gICAgICBkYXRhOiBjaHVua1xuICAgIH0pO1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuY29uc3QgSUdOT1JFX1NVQlNUUkVBTSA9IFN5bWJvbChcIklHTk9SRV9TVUJTVFJFQU1cIik7XG5jbGFzcyBPYmplY3RNdWx0aXBsZXggZXh0ZW5kcyBEdXBsZXgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgc3VwZXIoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRzKSwge30sIHtcbiAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICB9KSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N1YnN0cmVhbXNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRTdHJlYW1cIiwgdm9pZCAwKTtcbiAgICB0aGlzLl9zdWJzdHJlYW1zID0ge307XG4gIH1cbiAgY3JlYXRlU3RyZWFtKG5hbWUpIHtcbiAgICAvLyB2YWxpZGF0ZSBuYW1lXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RNdWx0aXBsZXggLSBuYW1lIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3Vic3RyZWFtc1tuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3RNdWx0aXBsZXggLSBTdWJzdHJlYW0gZm9yIG5hbWUgXCIke25hbWV9XCIgYWxyZWFkeSBleGlzdHNgKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgc3Vic3RyZWFtXG4gICAgY29uc3Qgc3Vic3RyZWFtID0gbmV3IFN1YnN0cmVhbSh7XG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBuYW1lXG4gICAgfSk7XG4gICAgdGhpcy5fc3Vic3RyZWFtc1tuYW1lXSA9IHN1YnN0cmVhbTtcblxuICAgIC8vIGxpc3RlbiBmb3IgcGFyZW50IHN0cmVhbSB0byBlbmRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgYW55U3RyZWFtRW5kKHRoaXMsIF9lcnJvciA9PiBzdWJzdHJlYW0uZGVzdHJveShfZXJyb3IgfHwgdW5kZWZpbmVkKSk7XG4gICAgcmV0dXJuIHN1YnN0cmVhbTtcbiAgfVxuXG4gIC8vIGlnbm9yZSBzdHJlYW1zIChkb250IGRpc3BsYXkgb3JwaGFuZWQgZGF0YSB3YXJuaW5nKVxuICBpZ25vcmVTdHJlYW0obmFtZSkge1xuICAgIC8vIHZhbGlkYXRlIG5hbWVcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdE11bHRpcGxleCAtIG5hbWUgbXVzdCBub3QgYmUgZW1wdHlcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdE11bHRpcGxleCAtIFN1YnN0cmVhbSBmb3IgbmFtZSBcIiR7bmFtZX1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgIH1cbiAgICAvLyBzZXRcbiAgICB0aGlzLl9zdWJzdHJlYW1zW25hbWVdID0gSUdOT1JFX1NVQlNUUkVBTTtcbiAgfVxuICBfcmVhZCgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIF93cml0ZShjaHVuaywgX2VuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBkYXRhXG4gICAgfSA9IGNodW5rO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgd2luZG93LmNvbnNvbGUud2FybihgT2JqZWN0TXVsdGlwbGV4IC0gbWFsZm9ybWVkIGNodW5rIHdpdGhvdXQgbmFtZSBcIiR7Y2h1bmt9XCJgKTtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIC8vIGdldCBjb3JyZXNwb25kaW5nIHN1YnN0cmVhbVxuICAgIGNvbnN0IHN1YnN0cmVhbSA9IHRoaXMuX3N1YnN0cmVhbXNbbmFtZV07XG4gICAgaWYgKCFzdWJzdHJlYW0pIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oYE9iamVjdE11bHRpcGxleCAtIG9ycGhhbmVkIGRhdGEgZm9yIHN0cmVhbSBcIiR7bmFtZX1cImApO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgLy8gcHVzaCBkYXRhIGludG8gc3Vic3RyZWFtXG4gICAgaWYgKHN1YnN0cmVhbSAhPT0gSUdOT1JFX1NVQlNUUkVBTSkge1xuICAgICAgc3Vic3RyZWFtLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9XG59XG5cbi8vIHV0aWxcbmZ1bmN0aW9uIGFueVN0cmVhbUVuZChzdHJlYW0sIF9jYikge1xuICBjb25zdCBjYiA9IG9uY2UoX2NiKTtcbiAgZW9zKHN0cmVhbSwge1xuICAgIHJlYWRhYmxlOiBmYWxzZVxuICB9LCBjYik7XG4gIGVvcyhzdHJlYW0sIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSwgY2IpO1xufVxuZnVuY3Rpb24gc2V0dXBNdWx0aXBsZXgoc3RyZWFtKSB7XG4gIGNvbnN0IG11eCA9IG5ldyBPYmplY3RNdWx0aXBsZXgoKTtcbiAgbXV4LmdldFN0cmVhbSA9IGZ1bmN0aW9uIHN0cmVhbUhlbHBlcihuYW1lKSB7XG4gICAgaWYgKHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzdHJlYW1zW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVTdHJlYW0obmFtZSk7XG4gIH07XG4gIHB1bXAoc3RyZWFtLCBtdXgsIHN0cmVhbSwgZXJyID0+IHtcbiAgICBpZiAoZXJyKSB3aW5kb3cuY29uc29sZS5lcnJvcihlcnIpO1xuICB9KTtcbiAgcmV0dXJuIG11eDtcbn1cblxuY2xhc3MgUG9zdE1lc3NhZ2VTdHJlYW0gZXh0ZW5kcyBCYXNlUG9zdE1lc3NhZ2VTdHJlYW0ge1xuICBfcG9zdE1lc3NhZ2UoZGF0YSkge1xuICAgIGxldCBvcmlnaW5Db25zdHJhaW50ID0gdGhpcy5fdGFyZ2V0T3JpZ2luO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgZGF0YU9iaiA9IGRhdGE7XG4gICAgICBpZiAodHlwZW9mIGRhdGFPYmouZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCBkYXRhT2JqRGF0YSA9IGRhdGFPYmouZGF0YTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YU9iakRhdGEucGFyYW1zKSAmJiBkYXRhT2JqRGF0YS5wYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGRhdGFPYmpEYXRhUGFyYW0gPSBkYXRhT2JqRGF0YS5wYXJhbXNbMF07XG4gICAgICAgICAgaWYgKGRhdGFPYmpEYXRhUGFyYW0uX29yaWdpbikge1xuICAgICAgICAgICAgb3JpZ2luQ29uc3RyYWludCA9IGRhdGFPYmpEYXRhUGFyYW0uX29yaWdpbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhZGQgYSBjb25zdHJhaW50IGZvciB0aGUgcmVzcG9uc2VcbiAgICAgICAgICBkYXRhT2JqRGF0YVBhcmFtLl9vcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3RhcmdldFdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICB0YXJnZXQ6IHRoaXMuX3RhcmdldCxcbiAgICAgIGRhdGFcbiAgICB9LCBvcmlnaW5Db25zdHJhaW50KTtcbiAgfVxufVxuXG5leHBvcnQgeyBCYXNlUG9zdE1lc3NhZ2VTdHJlYW0sIEV0aGVyZXVtUHJvdmlkZXJFcnJvciwgSUdOT1JFX1NVQlNUUkVBTSwgSlJQQ0VuZ2luZSwgSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0UsIEpzb25ScGNFcnJvciwgT2JqZWN0TXVsdGlwbGV4LCBQb3N0TWVzc2FnZVN0cmVhbSwgU2FmZUV2ZW50RW1pdHRlciwgU2VyaWFsaXphYmxlRXJyb3IsIFN1YnN0cmVhbSwgY3JlYXRlQXN5bmNNaWRkbGV3YXJlLCBjcmVhdGVFbmdpbmVTdHJlYW0sIGNyZWF0ZUVycm9yTWlkZGxld2FyZSwgY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUsIGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUsIGNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSwgY3JlYXRlU3RyZWFtTWlkZGxld2FyZSwgZGF0YUhhc0NhdXNlLCBlcnJvckNvZGVzLCBlcnJvclZhbHVlcywgZ2V0TWVzc2FnZUZyb21Db2RlLCBnZXRScGNQcm9taXNlQ2FsbGJhY2ssIGlzT2JqZWN0LCBpc1BsYWluT2JqZWN0LCBpc1ZhbGlkQ29kZSwgaXNWYWxpZFN0cmluZywgbWVyZ2VNaWRkbGV3YXJlLCBwcm92aWRlckFzTWlkZGxld2FyZSwgcHJvdmlkZXJFcnJvcnMsIHByb3ZpZGVyRnJvbUVuZ2luZSwgcHJvdmlkZXJGcm9tTWlkZGxld2FyZSwgcnBjRXJyb3JzLCBzZXJpYWxpemVDYXVzZSwgc2VyaWFsaXplRXJyb3IsIHNldHVwTXVsdGlwbGV4IH07XG4iXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnR5IiwiRHVwbGV4Iiwic2FmZVN0cmluZ2lmeSIsIl9vYmplY3RTcHJlYWQiLCJFdmVudEVtaXR0ZXIiLCJlb3MiLCJvbmNlIiwicHVtcCIsIm5vb3AiLCJ1bmRlZmluZWQiLCJTWU4iLCJBQ0siLCJCUksiLCJCYXNlUG9zdE1lc3NhZ2VTdHJlYW0iLCJjb25zdHJ1Y3RvciIsIl9yZWYiLCJuYW1lIiwidGFyZ2V0IiwidGFyZ2V0V2luZG93Iiwid2luZG93IiwidGFyZ2V0T3JpZ2luIiwib2JqZWN0TW9kZSIsIkVycm9yIiwiX2luaXQiLCJfaGF2ZVN5biIsIl9uYW1lIiwiX3RhcmdldCIsIl90YXJnZXRXaW5kb3ciLCJfdGFyZ2V0T3JpZ2luIiwiX29uTWVzc2FnZSIsIm9uTWVzc2FnZSIsImJpbmQiLCJfc3luSW50ZXJ2YWxJZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJfaGFuZFNoYWtlIiwiX2JyZWFrIiwiY29yayIsIl93cml0ZSIsIl9vbkRhdGEiLCJkYXRhIiwidW5jb3JrIiwicHVzaCIsImVyciIsImVtaXQiLCJfcG9zdE1lc3NhZ2UiLCJvcmlnaW5Db25zdHJhaW50IiwicG9zdE1lc3NhZ2UiLCJldmVudCIsIm1lc3NhZ2UiLCJvcmlnaW4iLCJzb3VyY2UiLCJfcmVhZCIsIl8iLCJjYiIsIl9kZXN0cm95IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImVycm9yQ29kZXMiLCJycGMiLCJpbnZhbGlkSW5wdXQiLCJyZXNvdXJjZU5vdEZvdW5kIiwicmVzb3VyY2VVbmF2YWlsYWJsZSIsInRyYW5zYWN0aW9uUmVqZWN0ZWQiLCJtZXRob2ROb3RTdXBwb3J0ZWQiLCJsaW1pdEV4Y2VlZGVkIiwicGFyc2UiLCJpbnZhbGlkUmVxdWVzdCIsIm1ldGhvZE5vdEZvdW5kIiwiaW52YWxpZFBhcmFtcyIsImludGVybmFsIiwicHJvdmlkZXIiLCJ1c2VyUmVqZWN0ZWRSZXF1ZXN0IiwidW5hdXRob3JpemVkIiwidW5zdXBwb3J0ZWRNZXRob2QiLCJkaXNjb25uZWN0ZWQiLCJjaGFpbkRpc2Nvbm5lY3RlZCIsImVycm9yVmFsdWVzIiwic3RhbmRhcmQiLCJGQUxMQkFDS19FUlJPUl9DT0RFIiwiRkFMTEJBQ0tfTUVTU0FHRSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFIiwiaXNWYWxpZENvZGUiLCJjb2RlIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaXNWYWxpZFN0cmluZyIsInZhbHVlIiwibGVuZ3RoIiwiaXNPYmplY3QiLCJCb29sZWFuIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNQbGFpbk9iamVjdCIsInByb3RvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJpc0pzb25ScGNTZXJ2ZXJFcnJvciIsImlzSnNvblJwY0Vycm9yIiwiY2FzdFZhbHVlIiwic3RhY2siLCJnZXRNZXNzYWdlRnJvbUNvZGUiLCJmYWxsYmFja01lc3NhZ2UiLCJhcmd1bWVudHMiLCJjb2RlU3RyaW5nIiwidG9TdHJpbmciLCJoYXNPd24iLCJGQUxMQkFDS19FUlJPUiIsImlzVmFsaWRKc29uIiwic3RyIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0cktleSIsInN0clZhbCIsInByb3BLZXkiLCJwcm9wVmFsdWUiLCJlIiwic2VyaWFsaXplT2JqZWN0Iiwib2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInJlZHVjZSIsImFjYyIsImtleSIsInNlcmlhbGl6ZUNhdXNlIiwiZXJyb3IiLCJtYXAiLCJlbnRyeSIsImJ1aWxkRXJyb3IiLCJmYWxsYmFja0Vycm9yIiwic2VyaWFsaXplIiwiY2F1c2UiLCJmYWxsYmFja1dpdGhDYXVzZSIsInNlcmlhbGl6ZUVycm9yIiwic2hvdWxkSW5jbHVkZVN0YWNrIiwic2VyaWFsaXplZCIsImRhdGFIYXNDYXVzZSIsImlzVmFsaWRFdGhQcm92aWRlckNvZGUiLCJzdHJpbmdpZnlSZXBsYWNlciIsIkpzb25ScGNFcnJvciIsImFzc2lnbiIsIkV0aGVyZXVtUHJvdmlkZXJFcnJvciIsInBhcnNlT3B0cyIsImFyZyIsImdldEpzb25ScGNFcnJvciIsImdldEV0aFByb3ZpZGVyRXJyb3IiLCJycGNFcnJvcnMiLCJzZXJ2ZXIiLCJvcHRzIiwicHJvdmlkZXJFcnJvcnMiLCJjdXN0b20iLCJzYWZlQXBwbHkiLCJoYW5kbGVyIiwiY29udGV4dCIsImFyZ3MiLCJSZWZsZWN0IiwiYXBwbHkiLCJzZXRUaW1lb3V0IiwiYXJyYXlDbG9uZSIsImFyciIsIm4iLCJjb3B5IiwiaSIsIlNhZmVFdmVudEVtaXR0ZXIiLCJ0eXBlIiwiZG9FcnJvciIsImV2ZW50cyIsIl9ldmVudHMiLCJfbGVuIiwiX2tleSIsImVyIiwibGVuIiwibGlzdGVuZXJzIiwiU2VyaWFsaXphYmxlRXJyb3IiLCJnZXRScGNQcm9taXNlQ2FsbGJhY2siLCJyZXNvbHZlIiwicmVqZWN0IiwidW53cmFwUmVzdWx0IiwicmVzcG9uc2UiLCJyZXN1bHQiLCJjcmVhdGVFcnJvck1pZGRsZXdhcmUiLCJsb2ciLCJyZXEiLCJyZXMiLCJuZXh0IiwiZW5kIiwibWV0aG9kIiwiZG9uZSIsImNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUiLCJpZE1hcCIsInJlYWROb29wIiwicHJvY2Vzc1Jlc3BvbnNlIiwiaWQiLCJwcm9jZXNzTm90aWZpY2F0aW9uIiwicHJvY2Vzc01lc3NhZ2UiLCJfZW5jb2RpbmciLCJpc05vdGlmaWNhdGlvbiIsIl9lcnIiLCJzdHJlYW0iLCJyZWFkIiwid3JpdGUiLCJtaWRkbGV3YXJlIiwiY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlIiwiaGFuZGxlcnMiLCJjcmVhdGVJZFJlbWFwTWlkZGxld2FyZSIsIl9lbmQiLCJvcmlnaW5hbElkIiwibmV3SWQiLCJNYXRoIiwicmFuZG9tIiwic2xpY2UiLCJjcmVhdGVMb2dnZXJNaWRkbGV3YXJlIiwibG9nZ2VyIiwiZGVidWciLCJjcmVhdGVBc3luY01pZGRsZXdhcmUiLCJhc3luY01pZGRsZXdhcmUiLCJyZXNvbHZlTmV4dFByb21pc2UiLCJuZXh0UHJvbWlzZSIsIlByb21pc2UiLCJyZXR1cm5IYW5kbGVyQ2FsbGJhY2siLCJuZXh0V2FzQ2FsbGVkIiwiYXN5bmNOZXh0IiwicnVuUmV0dXJuSGFuZGxlcnNDYWxsYmFjayIsIkpSUENFbmdpbmUiLCJfbWlkZGxld2FyZSIsIl9ydW5BbGxNaWRkbGV3YXJlIiwibWlkZGxld2FyZVN0YWNrIiwicmV0dXJuSGFuZGxlcnMiLCJpc0NvbXBsZXRlIiwiX3J1bk1pZGRsZXdhcmUiLCJyZXZlcnNlIiwia2V5cyIsImluY2x1ZGVzIiwicmV0dXJuSGFuZGxlciIsIl9ydW5SZXR1cm5IYW5kbGVycyIsIl9jaGVja0ZvckNvbXBsZXRpb24iLCJfcmVxIiwiaGFuZGxlIiwiX2hhbmRsZUJhdGNoIiwiX2hhbmRsZSIsIl9wcm9taXNlSGFuZGxlIiwiYXNNaWRkbGV3YXJlIiwibWlkZGxld2FyZUVycm9yIiwiaGFuZGxlckNhbGxiYWNrIiwicmVxcyIsInJlc3BvbnNlcyIsImFsbCIsImNhdGNoIiwiY2FsbGVyUmVxIiwianNvbnJwYyIsIl9wcm9jZXNzUmVxdWVzdCIsIl9lcnJvciIsIl9lcnJvcjIiLCJfZXJyb3IzIiwiX2Vycm9yNCIsIl9lcnJvcjUiLCJfZXJyb3I2IiwiX2Vycm9yNyIsIl9lcnJvcjgiLCJtZXJnZU1pZGRsZXdhcmUiLCJlbmdpbmUiLCJmb3JFYWNoIiwiY3JlYXRlRW5naW5lU3RyZWFtIiwib24iLCJwcm92aWRlckZyb21FbmdpbmUiLCJzZW5kQXN5bmMiLCJfcmVzJGVycm9yIiwiX3JlcyRlcnJvcjIiLCJfcmVzJGVycm9yMyIsIl9yZXMkZXJyb3I0IiwiX3JlcyRlcnJvcjUiLCJfcmVzJGVycm9yNiIsIl9yZXMkZXJyb3I3Iiwic2VuZCIsImNhbGxiYWNrIiwicmVxdWVzdCIsInByb3ZpZGVyRnJvbU1pZGRsZXdhcmUiLCJwcm92aWRlckFzTWlkZGxld2FyZSIsIl9uZXh0IiwicHJvdmlkZXJSZXMiLCJTdWJzdHJlYW0iLCJwYXJlbnQiLCJfcGFyZW50IiwiY2h1bmsiLCJJR05PUkVfU1VCU1RSRUFNIiwiU3ltYm9sIiwiT2JqZWN0TXVsdGlwbGV4IiwiX3N1YnN0cmVhbXMiLCJjcmVhdGVTdHJlYW0iLCJzdWJzdHJlYW0iLCJhbnlTdHJlYW1FbmQiLCJkZXN0cm95IiwiaWdub3JlU3RyZWFtIiwiY29uc29sZSIsIndhcm4iLCJfY2IiLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwic2V0dXBNdWx0aXBsZXgiLCJtdXgiLCJnZXRTdHJlYW0iLCJzdHJlYW1IZWxwZXIiLCJQb3N0TWVzc2FnZVN0cmVhbSIsImRhdGFPYmoiLCJkYXRhT2JqRGF0YSIsInBhcmFtcyIsImRhdGFPYmpEYXRhUGFyYW0iLCJfb3JpZ2luIiwibG9jYXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BUILD_ENV: () => (/* binding */ BUILD_ENV),\n/* harmony export */   BrowserStorage: () => (/* binding */ BrowserStorage),\n/* harmony export */   LANGUAGES: () => (/* binding */ LANGUAGES),\n/* harmony export */   LANGUAGE_MAP: () => (/* binding */ LANGUAGE_MAP),\n/* harmony export */   LOGIN_PROVIDER: () => (/* binding */ LOGIN_PROVIDER),\n/* harmony export */   MFA_FACTOR: () => (/* binding */ MFA_FACTOR),\n/* harmony export */   MFA_LEVELS: () => (/* binding */ MFA_LEVELS),\n/* harmony export */   MemoryStore: () => (/* binding */ MemoryStore),\n/* harmony export */   OPENLOGIN_ACTIONS: () => (/* binding */ OPENLOGIN_ACTIONS),\n/* harmony export */   OPENLOGIN_NETWORK: () => (/* binding */ OPENLOGIN_NETWORK),\n/* harmony export */   SUPPORTED_KEY_CURVES: () => (/* binding */ SUPPORTED_KEY_CURVES),\n/* harmony export */   THEME_MODES: () => (/* binding */ THEME_MODES),\n/* harmony export */   TORUS_LEGACY_NETWORK: () => (/* reexport safe */ _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_LEGACY_NETWORK),\n/* harmony export */   TORUS_SAPPHIRE_NETWORK: () => (/* reexport safe */ _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_SAPPHIRE_NETWORK),\n/* harmony export */   UX_MODE: () => (/* binding */ UX_MODE),\n/* harmony export */   applyWhiteLabelTheme: () => (/* binding */ applyWhiteLabelTheme),\n/* harmony export */   base64toJSON: () => (/* binding */ base64toJSON),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   generateWhiteLabelTheme: () => (/* binding */ generateWhiteLabelTheme),\n/* harmony export */   getColorsList: () => (/* binding */ getColorsList),\n/* harmony export */   jsonToBase64: () => (/* binding */ jsonToBase64),\n/* harmony export */   safeatob: () => (/* binding */ safeatob),\n/* harmony export */   safebtoa: () => (/* binding */ safebtoa),\n/* harmony export */   storageAvailable: () => (/* binding */ storageAvailable),\n/* harmony export */   storeKey: () => (/* binding */ storeKey)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var base64url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! base64url */ \"(ssr)/./node_modules/base64url/index.js\");\n/* harmony import */ var base64url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(base64url__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/constants */ \"(ssr)/./node_modules/@toruslabs/constants/dist/constants.esm.js\");\n/* harmony import */ var color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! color */ \"(ssr)/./node_modules/color/index.js\");\n/* harmony import */ var color__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(color__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n\nconst base64url = (base64url__WEBPACK_IMPORTED_MODULE_1___default());\nfunction safebtoa(str) {\n    return base64url.encode(str);\n}\nfunction safeatob(str) {\n    // Going backwards: from bytestream, to percent-encoding, to original string.\n    return base64url.decode(str);\n}\nfunction base64toJSON(b64str) {\n    return JSON.parse(base64url.decode(b64str));\n}\nfunction jsonToBase64(json) {\n    return base64url.encode(JSON.stringify(json));\n}\nfunction storageAvailable(type) {\n    let storageExists = false;\n    let storageLength = 0;\n    let storage;\n    try {\n        storage = window[type];\n        storageExists = true;\n        storageLength = storage.length;\n        const x = \"__storage_test__\";\n        storage.setItem(x, x);\n        storage.removeItem(x);\n        return true;\n    } catch (err) {\n        const error = err;\n        return error && // everything except Firefox\n        (error.code === 22 || // Firefox\n        error.code === 1014 || // test name field too, because code might not be present\n        // everything except Firefox\n        error.name === \"QuotaExceededError\" || // Firefox\n        error.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && // acknowledge QuotaExceededError only if there's something already stored\n        storageExists && storageLength !== 0;\n    }\n}\nclass MemoryStore {\n    constructor(){\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"store\", new Map());\n    }\n    getItem(key) {\n        return this.store.get(key) || null;\n    }\n    setItem(key, value) {\n        this.store.set(key, value);\n    }\n    removeItem(key) {\n        this.store.delete(key);\n    }\n}\nclass BrowserStorage {\n    constructor(storeKey, storage){\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"storage\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_storeKey\", void 0);\n        this.storage = storage;\n        this._storeKey = storeKey;\n        try {\n            if (!storage.getItem(storeKey)) {\n                this.resetStore();\n            }\n        } catch (error) {\n        // Storage is not available\n        }\n    }\n    static getInstance(key) {\n        let storageKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"local\";\n        if (!this.instanceMap.has(key)) {\n            let storage;\n            if (storageKey === \"local\" && storageAvailable(\"localStorage\")) {\n                storage = window.localStorage;\n            } else if (storageKey === \"session\" && storageAvailable(\"sessionStorage\")) {\n                storage = window.sessionStorage;\n            } else {\n                storage = new MemoryStore();\n            }\n            this.instanceMap.set(key, new this(key, storage));\n        }\n        return this.instanceMap.get(key);\n    }\n    toJSON() {\n        return this.storage.getItem(this._storeKey);\n    }\n    resetStore() {\n        const currStore = this.getStore();\n        this.storage.removeItem(this._storeKey);\n        return currStore;\n    }\n    getStore() {\n        return JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n    }\n    get(key) {\n        const store = JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n        return store[key];\n    }\n    set(key, value) {\n        const store = JSON.parse(this.storage.getItem(this._storeKey) || \"{}\");\n        store[key] = value;\n        this.storage.setItem(this._storeKey, JSON.stringify(store));\n    }\n}\n_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(BrowserStorage, \"instanceMap\", new Map());\nconst storeKey = \"openlogin_store\";\nconst UX_MODE = {\n    POPUP: \"popup\",\n    REDIRECT: \"redirect\"\n};\nconst OPENLOGIN_NETWORK = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_2___default()({}, _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_SAPPHIRE_NETWORK), _toruslabs_constants__WEBPACK_IMPORTED_MODULE_3__.TORUS_LEGACY_NETWORK);\nconst SUPPORTED_KEY_CURVES = {\n    SECP256K1: \"secp256k1\",\n    ED25519: \"ed25519\"\n};\nconst LOGIN_PROVIDER = {\n    GOOGLE: \"google\",\n    FACEBOOK: \"facebook\",\n    REDDIT: \"reddit\",\n    DISCORD: \"discord\",\n    TWITCH: \"twitch\",\n    APPLE: \"apple\",\n    LINE: \"line\",\n    GITHUB: \"github\",\n    KAKAO: \"kakao\",\n    LINKEDIN: \"linkedin\",\n    TWITTER: \"twitter\",\n    WEIBO: \"weibo\",\n    WECHAT: \"wechat\",\n    FARCASTER: \"farcaster\",\n    EMAIL_PASSWORDLESS: \"email_passwordless\",\n    SMS_PASSWORDLESS: \"sms_passwordless\",\n    WEBAUTHN: \"webauthn\",\n    JWT: \"jwt\"\n};\nconst MFA_LEVELS = {\n    DEFAULT: \"default\",\n    OPTIONAL: \"optional\",\n    MANDATORY: \"mandatory\",\n    NONE: \"none\"\n};\nconst OPENLOGIN_ACTIONS = {\n    LOGIN: \"login\",\n    ENABLE_MFA: \"enable_mfa\",\n    MANAGE_MFA: \"manage_mfa\",\n    MODIFY_SOCIAL_FACTOR: \"modify_social_factor\"\n};\nconst BUILD_ENV = {\n    PRODUCTION: \"production\",\n    DEVELOPMENT: \"development\",\n    STAGING: \"staging\",\n    TESTING: \"testing\"\n};\n/**\n * {@label loginProviderType}\n */ // autocomplete workaround https://github.com/microsoft/TypeScript/issues/29729\nconst LANGUAGES = {\n    en: \"en\",\n    ja: \"ja\",\n    ko: \"ko\",\n    de: \"de\",\n    zh: \"zh\",\n    es: \"es\",\n    fr: \"fr\",\n    pt: \"pt\",\n    nl: \"nl\",\n    tr: \"tr\"\n};\nconst LANGUAGE_MAP = {\n    en: \"english\",\n    ja: \"japanese\",\n    ko: \"korean\",\n    de: \"german\",\n    zh: \"mandarin\",\n    es: \"spanish\",\n    fr: \"french\",\n    pt: \"portuguese\",\n    nl: \"dutch\",\n    tr: \"turkish\"\n};\nconst THEME_MODES = {\n    light: \"light\",\n    dark: \"dark\",\n    auto: \"auto\"\n};\nconst MFA_FACTOR = {\n    DEVICE: \"deviceShareFactor\",\n    BACKUP_SHARE: \"backUpShareFactor\",\n    SOCIAL_BACKUP: \"socialBackupFactor\",\n    PASSWORD: \"passwordFactor\",\n    PASSKEYS: \"passkeysFactor\",\n    AUTHENTICATOR: \"authenticatorFactor\"\n};\nfunction getColorsList() {\n    let colorsAmount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n    let colorsShiftAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n    let mixColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"black\";\n    let rotate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let saturation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;\n    let mainColor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"#0346ff\";\n    const colorsList = [];\n    let step;\n    for(step = 0; step < colorsAmount; step += 1){\n        colorsList.push(color__WEBPACK_IMPORTED_MODULE_4___default()(mainColor).rotate((step + 1) / colorsAmount * -rotate).saturate((step + 1) / colorsAmount * (saturation / 100)).mix(color__WEBPACK_IMPORTED_MODULE_4___default()(mixColor), colorsShiftAmount / 100 * (step + 1) / colorsAmount).hex());\n    }\n    return colorsList;\n}\nfunction generateWhiteLabelTheme(primary) {\n    const darkSet = getColorsList(3, 50, \"black\", 0, 20, primary);\n    const lightSet = getColorsList(6, 85, \"white\", 0, 20, primary);\n    return [\n        ...darkSet.reverse(),\n        primary,\n        ...lightSet\n    ];\n}\nfunction applyWhiteLabelTheme(rootElement, theme) {\n    if (theme.primary) {\n        const themeSet = generateWhiteLabelTheme(theme.primary);\n        rootElement.style.setProperty(\"--app-primary-900\", themeSet[0]);\n        rootElement.style.setProperty(\"--app-primary-800\", themeSet[1]);\n        rootElement.style.setProperty(\"--app-primary-700\", themeSet[2]);\n        rootElement.style.setProperty(\"--app-primary-600\", themeSet[3]);\n        rootElement.style.setProperty(\"--app-primary-500\", themeSet[4]);\n        rootElement.style.setProperty(\"--app-primary-400\", themeSet[5]);\n        rootElement.style.setProperty(\"--app-primary-300\", themeSet[6]);\n        rootElement.style.setProperty(\"--app-primary-200\", themeSet[7]);\n        rootElement.style.setProperty(\"--app-primary-100\", themeSet[8]);\n        rootElement.style.setProperty(\"--app-primary-50\", themeSet[9]);\n    }\n    if (theme.onPrimary) {\n        rootElement.style.setProperty(\"--app-on-primary\", theme.onPrimary);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9vcGVubG9naW4tdXRpbHMvZGlzdC9vcGVubG9naW5VdGlscy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUMvQjtBQUM0QjtBQUNtQjtBQUNBO0FBQzFEO0FBRTFCLE1BQU1NLFlBQVlMLGtEQUFZQTtBQUM5QixTQUFTTSxTQUFTQyxHQUFHO0lBQ25CLE9BQU9GLFVBQVVHLE1BQU0sQ0FBQ0Q7QUFDMUI7QUFDQSxTQUFTRSxTQUFTRixHQUFHO0lBQ25CLDZFQUE2RTtJQUM3RSxPQUFPRixVQUFVSyxNQUFNLENBQUNIO0FBQzFCO0FBQ0EsU0FBU0ksYUFBYUMsTUFBTTtJQUMxQixPQUFPQyxLQUFLQyxLQUFLLENBQUNULFVBQVVLLE1BQU0sQ0FBQ0U7QUFDckM7QUFDQSxTQUFTRyxhQUFhQyxJQUFJO0lBQ3hCLE9BQU9YLFVBQVVHLE1BQU0sQ0FBQ0ssS0FBS0ksU0FBUyxDQUFDRDtBQUN6QztBQUNBLFNBQVNFLGlCQUFpQkMsSUFBSTtJQUM1QixJQUFJQyxnQkFBZ0I7SUFDcEIsSUFBSUMsZ0JBQWdCO0lBQ3BCLElBQUlDO0lBQ0osSUFBSTtRQUNGQSxVQUFVQyxNQUFNLENBQUNKLEtBQUs7UUFDdEJDLGdCQUFnQjtRQUNoQkMsZ0JBQWdCQyxRQUFRRSxNQUFNO1FBQzlCLE1BQU1DLElBQUk7UUFDVkgsUUFBUUksT0FBTyxDQUFDRCxHQUFHQTtRQUNuQkgsUUFBUUssVUFBVSxDQUFDRjtRQUNuQixPQUFPO0lBQ1QsRUFBRSxPQUFPRyxLQUFLO1FBQ1osTUFBTUMsUUFBUUQ7UUFDZCxPQUFPQyxTQUNQLDRCQUE0QjtRQUM1QkEsQ0FBQUEsTUFBTUMsSUFBSSxLQUFLLE1BQ2YsVUFBVTtRQUNWRCxNQUFNQyxJQUFJLEtBQUssUUFDZix5REFBeUQ7UUFDekQsNEJBQTRCO1FBQzVCRCxNQUFNRSxJQUFJLEtBQUssd0JBQ2YsVUFBVTtRQUNW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cUJGLFFBQVEsQ0FBQyxFQUFFO1FBQzlERixZQUFZRyxLQUFLLENBQUNDLFdBQVcsQ0FBQyxxQkFBcUJGLFFBQVEsQ0FBQyxFQUFFO1FBQzlERixZQUFZRyxLQUFLLENBQUNDLFdBQVcsQ0FBQyxvQkFBb0JGLFFBQVEsQ0FBQyxFQUFFO0lBQy9EO0lBQ0EsSUFBSUQsTUFBTUksU0FBUyxFQUFFO1FBQ25CTCxZQUFZRyxLQUFLLENBQUNDLFdBQVcsQ0FBQyxvQkFBb0JILE1BQU1JLFNBQVM7SUFDbkU7QUFDRjtBQUUwViIsInNvdXJjZXMiOlsid2VicGFjazovL3NvbC1wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL0B0b3J1c2xhYnMvb3BlbmxvZ2luLXV0aWxzL2Rpc3Qvb3BlbmxvZ2luVXRpbHMuZXNtLmpzP2Y5M2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCBiYXNlNjR1cmxMaWIgZnJvbSAnYmFzZTY0dXJsJztcbmltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0U3ByZWFkMic7XG5pbXBvcnQgeyBUT1JVU19TQVBQSElSRV9ORVRXT1JLLCBUT1JVU19MRUdBQ1lfTkVUV09SSyB9IGZyb20gJ0B0b3J1c2xhYnMvY29uc3RhbnRzJztcbmV4cG9ydCB7IFRPUlVTX0xFR0FDWV9ORVRXT1JLLCBUT1JVU19TQVBQSElSRV9ORVRXT1JLIH0gZnJvbSAnQHRvcnVzbGFicy9jb25zdGFudHMnO1xuaW1wb3J0IENvbG9yIGZyb20gJ2NvbG9yJztcblxuY29uc3QgYmFzZTY0dXJsID0gYmFzZTY0dXJsTGliO1xuZnVuY3Rpb24gc2FmZWJ0b2Eoc3RyKSB7XG4gIHJldHVybiBiYXNlNjR1cmwuZW5jb2RlKHN0cik7XG59XG5mdW5jdGlvbiBzYWZlYXRvYihzdHIpIHtcbiAgLy8gR29pbmcgYmFja3dhcmRzOiBmcm9tIGJ5dGVzdHJlYW0sIHRvIHBlcmNlbnQtZW5jb2RpbmcsIHRvIG9yaWdpbmFsIHN0cmluZy5cbiAgcmV0dXJuIGJhc2U2NHVybC5kZWNvZGUoc3RyKTtcbn1cbmZ1bmN0aW9uIGJhc2U2NHRvSlNPTihiNjRzdHIpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoYmFzZTY0dXJsLmRlY29kZShiNjRzdHIpKTtcbn1cbmZ1bmN0aW9uIGpzb25Ub0Jhc2U2NChqc29uKSB7XG4gIHJldHVybiBiYXNlNjR1cmwuZW5jb2RlKEpTT04uc3RyaW5naWZ5KGpzb24pKTtcbn1cbmZ1bmN0aW9uIHN0b3JhZ2VBdmFpbGFibGUodHlwZSkge1xuICBsZXQgc3RvcmFnZUV4aXN0cyA9IGZhbHNlO1xuICBsZXQgc3RvcmFnZUxlbmd0aCA9IDA7XG4gIGxldCBzdG9yYWdlO1xuICB0cnkge1xuICAgIHN0b3JhZ2UgPSB3aW5kb3dbdHlwZV07XG4gICAgc3RvcmFnZUV4aXN0cyA9IHRydWU7XG4gICAgc3RvcmFnZUxlbmd0aCA9IHN0b3JhZ2UubGVuZ3RoO1xuICAgIGNvbnN0IHggPSBcIl9fc3RvcmFnZV90ZXN0X19cIjtcbiAgICBzdG9yYWdlLnNldEl0ZW0oeCwgeCk7XG4gICAgc3RvcmFnZS5yZW1vdmVJdGVtKHgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zdCBlcnJvciA9IGVycjtcbiAgICByZXR1cm4gZXJyb3IgJiYgKFxuICAgIC8vIGV2ZXJ5dGhpbmcgZXhjZXB0IEZpcmVmb3hcbiAgICBlcnJvci5jb2RlID09PSAyMiB8fFxuICAgIC8vIEZpcmVmb3hcbiAgICBlcnJvci5jb2RlID09PSAxMDE0IHx8XG4gICAgLy8gdGVzdCBuYW1lIGZpZWxkIHRvbywgYmVjYXVzZSBjb2RlIG1pZ2h0IG5vdCBiZSBwcmVzZW50XG4gICAgLy8gZXZlcnl0aGluZyBleGNlcHQgRmlyZWZveFxuICAgIGVycm9yLm5hbWUgPT09IFwiUXVvdGFFeGNlZWRlZEVycm9yXCIgfHxcbiAgICAvLyBGaXJlZm94XG4gICAgZXJyb3IubmFtZSA9PT0gXCJOU19FUlJPUl9ET01fUVVPVEFfUkVBQ0hFRFwiKSAmJlxuICAgIC8vIGFja25vd2xlZGdlIFF1b3RhRXhjZWVkZWRFcnJvciBvbmx5IGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGFscmVhZHkgc3RvcmVkXG4gICAgc3RvcmFnZUV4aXN0cyAmJiBzdG9yYWdlTGVuZ3RoICE9PSAwO1xuICB9XG59XG5cbmNsYXNzIE1lbW9yeVN0b3JlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmVcIiwgbmV3IE1hcCgpKTtcbiAgfVxuICBnZXRJdGVtKGtleSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmdldChrZXkpIHx8IG51bGw7XG4gIH1cbiAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5zdG9yZS5zZXQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICB0aGlzLnN0b3JlLmRlbGV0ZShrZXkpO1xuICB9XG59XG5jbGFzcyBCcm93c2VyU3RvcmFnZSB7XG4gIGNvbnN0cnVjdG9yKHN0b3JlS2V5LCBzdG9yYWdlKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RvcmFnZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zdG9yZUtleVwiLCB2b2lkIDApO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgdGhpcy5fc3RvcmVLZXkgPSBzdG9yZUtleTtcbiAgICB0cnkge1xuICAgICAgaWYgKCFzdG9yYWdlLmdldEl0ZW0oc3RvcmVLZXkpKSB7XG4gICAgICAgIHRoaXMucmVzZXRTdG9yZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBTdG9yYWdlIGlzIG5vdCBhdmFpbGFibGVcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKGtleSkge1xuICAgIGxldCBzdG9yYWdlS2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcImxvY2FsXCI7XG4gICAgaWYgKCF0aGlzLmluc3RhbmNlTWFwLmhhcyhrZXkpKSB7XG4gICAgICBsZXQgc3RvcmFnZTtcbiAgICAgIGlmIChzdG9yYWdlS2V5ID09PSBcImxvY2FsXCIgJiYgc3RvcmFnZUF2YWlsYWJsZShcImxvY2FsU3RvcmFnZVwiKSkge1xuICAgICAgICBzdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RvcmFnZUtleSA9PT0gXCJzZXNzaW9uXCIgJiYgc3RvcmFnZUF2YWlsYWJsZShcInNlc3Npb25TdG9yYWdlXCIpKSB7XG4gICAgICAgIHN0b3JhZ2UgPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yYWdlID0gbmV3IE1lbW9yeVN0b3JlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmluc3RhbmNlTWFwLnNldChrZXksIG5ldyB0aGlzKGtleSwgc3RvcmFnZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZU1hcC5nZXQoa2V5KTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMuX3N0b3JlS2V5KTtcbiAgfVxuICByZXNldFN0b3JlKCkge1xuICAgIGNvbnN0IGN1cnJTdG9yZSA9IHRoaXMuZ2V0U3RvcmUoKTtcbiAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLl9zdG9yZUtleSk7XG4gICAgcmV0dXJuIGN1cnJTdG9yZTtcbiAgfVxuICBnZXRTdG9yZSgpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLl9zdG9yZUtleSkgfHwgXCJ7fVwiKTtcbiAgfVxuICBnZXQoa2V5KSB7XG4gICAgY29uc3Qgc3RvcmUgPSBKU09OLnBhcnNlKHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMuX3N0b3JlS2V5KSB8fCBcInt9XCIpO1xuICAgIHJldHVybiBzdG9yZVtrZXldO1xuICB9XG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qgc3RvcmUgPSBKU09OLnBhcnNlKHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMuX3N0b3JlS2V5KSB8fCBcInt9XCIpO1xuICAgIHN0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLl9zdG9yZUtleSwgSlNPTi5zdHJpbmdpZnkoc3RvcmUpKTtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KEJyb3dzZXJTdG9yYWdlLCBcImluc3RhbmNlTWFwXCIsIG5ldyBNYXAoKSk7XG5cbmNvbnN0IHN0b3JlS2V5ID0gXCJvcGVubG9naW5fc3RvcmVcIjtcbmNvbnN0IFVYX01PREUgPSB7XG4gIFBPUFVQOiBcInBvcHVwXCIsXG4gIFJFRElSRUNUOiBcInJlZGlyZWN0XCJcbn07XG5jb25zdCBPUEVOTE9HSU5fTkVUV09SSyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgVE9SVVNfU0FQUEhJUkVfTkVUV09SSyksIFRPUlVTX0xFR0FDWV9ORVRXT1JLKTtcbmNvbnN0IFNVUFBPUlRFRF9LRVlfQ1VSVkVTID0ge1xuICBTRUNQMjU2SzE6IFwic2VjcDI1NmsxXCIsXG4gIEVEMjU1MTk6IFwiZWQyNTUxOVwiXG59O1xuY29uc3QgTE9HSU5fUFJPVklERVIgPSB7XG4gIEdPT0dMRTogXCJnb29nbGVcIixcbiAgRkFDRUJPT0s6IFwiZmFjZWJvb2tcIixcbiAgUkVERElUOiBcInJlZGRpdFwiLFxuICBESVNDT1JEOiBcImRpc2NvcmRcIixcbiAgVFdJVENIOiBcInR3aXRjaFwiLFxuICBBUFBMRTogXCJhcHBsZVwiLFxuICBMSU5FOiBcImxpbmVcIixcbiAgR0lUSFVCOiBcImdpdGh1YlwiLFxuICBLQUtBTzogXCJrYWthb1wiLFxuICBMSU5LRURJTjogXCJsaW5rZWRpblwiLFxuICBUV0lUVEVSOiBcInR3aXR0ZXJcIixcbiAgV0VJQk86IFwid2VpYm9cIixcbiAgV0VDSEFUOiBcIndlY2hhdFwiLFxuICBGQVJDQVNURVI6IFwiZmFyY2FzdGVyXCIsXG4gIEVNQUlMX1BBU1NXT1JETEVTUzogXCJlbWFpbF9wYXNzd29yZGxlc3NcIixcbiAgU01TX1BBU1NXT1JETEVTUzogXCJzbXNfcGFzc3dvcmRsZXNzXCIsXG4gIFdFQkFVVEhOOiBcIndlYmF1dGhuXCIsXG4gIEpXVDogXCJqd3RcIlxufTtcbmNvbnN0IE1GQV9MRVZFTFMgPSB7XG4gIERFRkFVTFQ6IFwiZGVmYXVsdFwiLFxuICBPUFRJT05BTDogXCJvcHRpb25hbFwiLFxuICBNQU5EQVRPUlk6IFwibWFuZGF0b3J5XCIsXG4gIE5PTkU6IFwibm9uZVwiXG59O1xuY29uc3QgT1BFTkxPR0lOX0FDVElPTlMgPSB7XG4gIExPR0lOOiBcImxvZ2luXCIsXG4gIEVOQUJMRV9NRkE6IFwiZW5hYmxlX21mYVwiLFxuICBNQU5BR0VfTUZBOiBcIm1hbmFnZV9tZmFcIixcbiAgTU9ESUZZX1NPQ0lBTF9GQUNUT1I6IFwibW9kaWZ5X3NvY2lhbF9mYWN0b3JcIlxufTtcbmNvbnN0IEJVSUxEX0VOViA9IHtcbiAgUFJPRFVDVElPTjogXCJwcm9kdWN0aW9uXCIsXG4gIERFVkVMT1BNRU5UOiBcImRldmVsb3BtZW50XCIsXG4gIFNUQUdJTkc6IFwic3RhZ2luZ1wiLFxuICBURVNUSU5HOiBcInRlc3RpbmdcIlxufTtcblxuLyoqXG4gKiB7QGxhYmVsIGxvZ2luUHJvdmlkZXJUeXBlfVxuICovXG5cbi8vIGF1dG9jb21wbGV0ZSB3b3JrYXJvdW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjk3MjlcblxuY29uc3QgTEFOR1VBR0VTID0ge1xuICBlbjogXCJlblwiLFxuICBqYTogXCJqYVwiLFxuICBrbzogXCJrb1wiLFxuICBkZTogXCJkZVwiLFxuICB6aDogXCJ6aFwiLFxuICBlczogXCJlc1wiLFxuICBmcjogXCJmclwiLFxuICBwdDogXCJwdFwiLFxuICBubDogXCJubFwiLFxuICB0cjogXCJ0clwiXG59O1xuY29uc3QgTEFOR1VBR0VfTUFQID0ge1xuICBlbjogXCJlbmdsaXNoXCIsXG4gIGphOiBcImphcGFuZXNlXCIsXG4gIGtvOiBcImtvcmVhblwiLFxuICBkZTogXCJnZXJtYW5cIixcbiAgemg6IFwibWFuZGFyaW5cIixcbiAgZXM6IFwic3BhbmlzaFwiLFxuICBmcjogXCJmcmVuY2hcIixcbiAgcHQ6IFwicG9ydHVndWVzZVwiLFxuICBubDogXCJkdXRjaFwiLFxuICB0cjogXCJ0dXJraXNoXCJcbn07XG5jb25zdCBUSEVNRV9NT0RFUyA9IHtcbiAgbGlnaHQ6IFwibGlnaHRcIixcbiAgZGFyazogXCJkYXJrXCIsXG4gIGF1dG86IFwiYXV0b1wiXG59O1xuY29uc3QgTUZBX0ZBQ1RPUiA9IHtcbiAgREVWSUNFOiBcImRldmljZVNoYXJlRmFjdG9yXCIsXG4gIEJBQ0tVUF9TSEFSRTogXCJiYWNrVXBTaGFyZUZhY3RvclwiLFxuICBTT0NJQUxfQkFDS1VQOiBcInNvY2lhbEJhY2t1cEZhY3RvclwiLFxuICBQQVNTV09SRDogXCJwYXNzd29yZEZhY3RvclwiLFxuICBQQVNTS0VZUzogXCJwYXNza2V5c0ZhY3RvclwiLFxuICBBVVRIRU5USUNBVE9SOiBcImF1dGhlbnRpY2F0b3JGYWN0b3JcIlxufTtcblxuZnVuY3Rpb24gZ2V0Q29sb3JzTGlzdCgpIHtcbiAgbGV0IGNvbG9yc0Ftb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMztcbiAgbGV0IGNvbG9yc1NoaWZ0QW1vdW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA1MDtcbiAgbGV0IG1peENvbG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBcImJsYWNrXCI7XG4gIGxldCByb3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gIGxldCBzYXR1cmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAyMDtcbiAgbGV0IG1haW5Db2xvciA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogXCIjMDM0NmZmXCI7XG4gIGNvbnN0IGNvbG9yc0xpc3QgPSBbXTtcbiAgbGV0IHN0ZXA7XG4gIGZvciAoc3RlcCA9IDA7IHN0ZXAgPCBjb2xvcnNBbW91bnQ7IHN0ZXAgKz0gMSkge1xuICAgIGNvbG9yc0xpc3QucHVzaChDb2xvcihtYWluQ29sb3IpLnJvdGF0ZSgoc3RlcCArIDEpIC8gY29sb3JzQW1vdW50ICogLXJvdGF0ZSkuc2F0dXJhdGUoKHN0ZXAgKyAxKSAvIGNvbG9yc0Ftb3VudCAqIChzYXR1cmF0aW9uIC8gMTAwKSkubWl4KENvbG9yKG1peENvbG9yKSwgY29sb3JzU2hpZnRBbW91bnQgLyAxMDAgKiAoc3RlcCArIDEpIC8gY29sb3JzQW1vdW50KS5oZXgoKSk7XG4gIH1cbiAgcmV0dXJuIGNvbG9yc0xpc3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVdoaXRlTGFiZWxUaGVtZShwcmltYXJ5KSB7XG4gIGNvbnN0IGRhcmtTZXQgPSBnZXRDb2xvcnNMaXN0KDMsIDUwLCBcImJsYWNrXCIsIDAsIDIwLCBwcmltYXJ5KTtcbiAgY29uc3QgbGlnaHRTZXQgPSBnZXRDb2xvcnNMaXN0KDYsIDg1LCBcIndoaXRlXCIsIDAsIDIwLCBwcmltYXJ5KTtcbiAgcmV0dXJuIFsuLi5kYXJrU2V0LnJldmVyc2UoKSwgcHJpbWFyeSwgLi4ubGlnaHRTZXRdO1xufVxuZnVuY3Rpb24gYXBwbHlXaGl0ZUxhYmVsVGhlbWUocm9vdEVsZW1lbnQsIHRoZW1lKSB7XG4gIGlmICh0aGVtZS5wcmltYXJ5KSB7XG4gICAgY29uc3QgdGhlbWVTZXQgPSBnZW5lcmF0ZVdoaXRlTGFiZWxUaGVtZSh0aGVtZS5wcmltYXJ5KTtcbiAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYXBwLXByaW1hcnktOTAwXCIsIHRoZW1lU2V0WzBdKTtcbiAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYXBwLXByaW1hcnktODAwXCIsIHRoZW1lU2V0WzFdKTtcbiAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYXBwLXByaW1hcnktNzAwXCIsIHRoZW1lU2V0WzJdKTtcbiAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYXBwLXByaW1hcnktNjAwXCIsIHRoZW1lU2V0WzNdKTtcbiAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYXBwLXByaW1hcnktNTAwXCIsIHRoZW1lU2V0WzRdKTtcbiAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYXBwLXByaW1hcnktNDAwXCIsIHRoZW1lU2V0WzVdKTtcbiAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYXBwLXByaW1hcnktMzAwXCIsIHRoZW1lU2V0WzZdKTtcbiAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYXBwLXByaW1hcnktMjAwXCIsIHRoZW1lU2V0WzddKTtcbiAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYXBwLXByaW1hcnktMTAwXCIsIHRoZW1lU2V0WzhdKTtcbiAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYXBwLXByaW1hcnktNTBcIiwgdGhlbWVTZXRbOV0pO1xuICB9XG4gIGlmICh0aGVtZS5vblByaW1hcnkpIHtcbiAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tYXBwLW9uLXByaW1hcnlcIiwgdGhlbWUub25QcmltYXJ5KTtcbiAgfVxufVxuXG5leHBvcnQgeyBCVUlMRF9FTlYsIEJyb3dzZXJTdG9yYWdlLCBMQU5HVUFHRVMsIExBTkdVQUdFX01BUCwgTE9HSU5fUFJPVklERVIsIE1GQV9GQUNUT1IsIE1GQV9MRVZFTFMsIE1lbW9yeVN0b3JlLCBPUEVOTE9HSU5fQUNUSU9OUywgT1BFTkxPR0lOX05FVFdPUkssIFNVUFBPUlRFRF9LRVlfQ1VSVkVTLCBUSEVNRV9NT0RFUywgVVhfTU9ERSwgYXBwbHlXaGl0ZUxhYmVsVGhlbWUsIGJhc2U2NHRvSlNPTiwgYmFzZTY0dXJsLCBnZW5lcmF0ZVdoaXRlTGFiZWxUaGVtZSwgZ2V0Q29sb3JzTGlzdCwganNvblRvQmFzZTY0LCBzYWZlYXRvYiwgc2FmZWJ0b2EsIHN0b3JhZ2VBdmFpbGFibGUsIHN0b3JlS2V5IH07XG4iXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnR5IiwiYmFzZTY0dXJsTGliIiwiX29iamVjdFNwcmVhZCIsIlRPUlVTX1NBUFBISVJFX05FVFdPUksiLCJUT1JVU19MRUdBQ1lfTkVUV09SSyIsIkNvbG9yIiwiYmFzZTY0dXJsIiwic2FmZWJ0b2EiLCJzdHIiLCJlbmNvZGUiLCJzYWZlYXRvYiIsImRlY29kZSIsImJhc2U2NHRvSlNPTiIsImI2NHN0ciIsIkpTT04iLCJwYXJzZSIsImpzb25Ub0Jhc2U2NCIsImpzb24iLCJzdHJpbmdpZnkiLCJzdG9yYWdlQXZhaWxhYmxlIiwidHlwZSIsInN0b3JhZ2VFeGlzdHMiLCJzdG9yYWdlTGVuZ3RoIiwic3RvcmFnZSIsIndpbmRvdyIsImxlbmd0aCIsIngiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImVyciIsImVycm9yIiwiY29kZSIsIm5hbWUiLCJNZW1vcnlTdG9yZSIsImNvbnN0cnVjdG9yIiwiTWFwIiwiZ2V0SXRlbSIsImtleSIsInN0b3JlIiwiZ2V0IiwidmFsdWUiLCJzZXQiLCJkZWxldGUiLCJCcm93c2VyU3RvcmFnZSIsInN0b3JlS2V5IiwiX3N0b3JlS2V5IiwicmVzZXRTdG9yZSIsImdldEluc3RhbmNlIiwic3RvcmFnZUtleSIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsImluc3RhbmNlTWFwIiwiaGFzIiwibG9jYWxTdG9yYWdlIiwic2Vzc2lvblN0b3JhZ2UiLCJ0b0pTT04iLCJjdXJyU3RvcmUiLCJnZXRTdG9yZSIsIlVYX01PREUiLCJQT1BVUCIsIlJFRElSRUNUIiwiT1BFTkxPR0lOX05FVFdPUksiLCJTVVBQT1JURURfS0VZX0NVUlZFUyIsIlNFQ1AyNTZLMSIsIkVEMjU1MTkiLCJMT0dJTl9QUk9WSURFUiIsIkdPT0dMRSIsIkZBQ0VCT09LIiwiUkVERElUIiwiRElTQ09SRCIsIlRXSVRDSCIsIkFQUExFIiwiTElORSIsIkdJVEhVQiIsIktBS0FPIiwiTElOS0VESU4iLCJUV0lUVEVSIiwiV0VJQk8iLCJXRUNIQVQiLCJGQVJDQVNURVIiLCJFTUFJTF9QQVNTV09SRExFU1MiLCJTTVNfUEFTU1dPUkRMRVNTIiwiV0VCQVVUSE4iLCJKV1QiLCJNRkFfTEVWRUxTIiwiREVGQVVMVCIsIk9QVElPTkFMIiwiTUFOREFUT1JZIiwiTk9ORSIsIk9QRU5MT0dJTl9BQ1RJT05TIiwiTE9HSU4iLCJFTkFCTEVfTUZBIiwiTUFOQUdFX01GQSIsIk1PRElGWV9TT0NJQUxfRkFDVE9SIiwiQlVJTERfRU5WIiwiUFJPRFVDVElPTiIsIkRFVkVMT1BNRU5UIiwiU1RBR0lORyIsIlRFU1RJTkciLCJMQU5HVUFHRVMiLCJlbiIsImphIiwia28iLCJkZSIsInpoIiwiZXMiLCJmciIsInB0IiwibmwiLCJ0ciIsIkxBTkdVQUdFX01BUCIsIlRIRU1FX01PREVTIiwibGlnaHQiLCJkYXJrIiwiYXV0byIsIk1GQV9GQUNUT1IiLCJERVZJQ0UiLCJCQUNLVVBfU0hBUkUiLCJTT0NJQUxfQkFDS1VQIiwiUEFTU1dPUkQiLCJQQVNTS0VZUyIsIkFVVEhFTlRJQ0FUT1IiLCJnZXRDb2xvcnNMaXN0IiwiY29sb3JzQW1vdW50IiwiY29sb3JzU2hpZnRBbW91bnQiLCJtaXhDb2xvciIsInJvdGF0ZSIsInNhdHVyYXRpb24iLCJtYWluQ29sb3IiLCJjb2xvcnNMaXN0Iiwic3RlcCIsInB1c2giLCJzYXR1cmF0ZSIsIm1peCIsImhleCIsImdlbmVyYXRlV2hpdGVMYWJlbFRoZW1lIiwicHJpbWFyeSIsImRhcmtTZXQiLCJsaWdodFNldCIsInJldmVyc2UiLCJhcHBseVdoaXRlTGFiZWxUaGVtZSIsInJvb3RFbGVtZW50IiwidGhlbWUiLCJ0aGVtZVNldCIsInN0eWxlIiwic2V0UHJvcGVydHkiLCJvblByaW1hcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BUTTON_POSITION: () => (/* binding */ BUTTON_POSITION),\n/* harmony export */   LOGIN_PROVIDER: () => (/* binding */ LOGIN_PROVIDER),\n/* harmony export */   PAYMENT_PROVIDER: () => (/* binding */ PAYMENT_PROVIDER),\n/* harmony export */   TORUS_BUILD_ENV: () => (/* binding */ TORUS_BUILD_ENV),\n/* harmony export */   TorusInPageProvider: () => (/* binding */ TorusInPageProvider),\n/* harmony export */   \"default\": () => (/* binding */ Torus)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/objectSpread2.js\");\n/* harmony import */ var _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @toruslabs/base-controllers */ \"(ssr)/./node_modules/@toruslabs/base-controllers/dist/baseControllers.esm.js\");\n/* harmony import */ var _toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @toruslabs/http-helpers */ \"(ssr)/./node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js\");\n/* harmony import */ var _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @toruslabs/openlogin-jrpc */ \"(ssr)/./node_modules/@toruslabs/openlogin-jrpc/dist/openloginJrpc.esm.js\");\n/* harmony import */ var eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! eth-rpc-errors */ \"(ssr)/./node_modules/eth-rpc-errors/dist/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! pump */ \"(ssr)/./node_modules/pump/index.js\");\n/* harmony import */ var pump__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pump__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! loglevel */ \"(ssr)/./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! fast-deep-equal */ \"(ssr)/./node_modules/fast-deep-equal/index.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_9__);\n\n\n\n\n\n\n\n\n\n\nvar version = \"2.1.0\";\n/* eslint-disable @typescript-eslint/no-explicit-any */ function isStream(stream) {\n    return stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";\n}\nfunction isWritableStream(stream) {\n    return isStream(stream) && stream.writable !== false && typeof stream._write === \"function\" && typeof stream._writableState === \"object\";\n}\nfunction isReadableStream(stream) {\n    return isStream(stream) && stream.readable !== false && typeof stream._read === \"function\" && typeof stream._readableState === \"object\";\n}\nfunction isDuplexStream(stream) {\n    return isWritableStream(stream) && isReadableStream(stream);\n}\nvar messages = {\n    errors: {\n        disconnected: ()=>\"Torus: Lost connection to Torus.\",\n        permanentlyDisconnected: ()=>\"Torus: Disconnected from iframe. Page reload required.\",\n        unsupportedSync: (method)=>`Torus: The Torus Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,\n        invalidDuplexStream: ()=>\"Must provide a Node.js-style duplex stream.\",\n        invalidOptions: (maxEventListeners)=>`Invalid options. Received: { maxEventListeners: ${maxEventListeners}}`,\n        invalidRequestArgs: ()=>`Expected a single, non-array, object argument.`,\n        invalidRequestMethod: ()=>`'args.method' must be a non-empty string.`,\n        invalidRequestParams: ()=>`'args.params' must be an object or array if provided.`,\n        invalidLoggerObject: ()=>`'args.logger' must be an object if provided.`,\n        invalidLoggerMethod: (method)=>`'args.logger' must include required method '${method}'.`\n    },\n    info: {\n        connected: (chainId)=>`Torus: Connected to chain with ID \"${chainId}\".`\n    },\n    warnings: {}\n};\nconst PAYMENT_PROVIDER = {\n    MOONPAY: \"moonpay\",\n    WYRE: \"wyre\",\n    RAMPNETWORK: \"rampnetwork\",\n    XANPOOL: \"xanpool\",\n    MERCURYO: \"mercuryo\",\n    TRANSAK: \"transak\"\n};\nconst TORUS_BUILD_ENV = {\n    PRODUCTION: \"production\",\n    DEVELOPMENT: \"development\",\n    TESTING: \"testing\"\n};\nconst BUTTON_POSITION = {\n    BOTTOM_LEFT: \"bottom-left\",\n    TOP_LEFT: \"top-left\",\n    BOTTOM_RIGHT: \"bottom-right\",\n    TOP_RIGHT: \"top-right\"\n};\nconst LOGIN_PROVIDER = {\n    GOOGLE: \"google\",\n    FACEBOOK: \"facebook\",\n    REDDIT: \"reddit\",\n    DISCORD: \"discord\",\n    TWITCH: \"twitch\",\n    APPLE: \"apple\",\n    LINE: \"line\",\n    GITHUB: \"github\",\n    KAKAO: \"kakao\",\n    LINKEDIN: \"linkedin\",\n    TWITTER: \"twitter\",\n    WEIBO: \"weibo\",\n    WECHAT: \"wechat\",\n    EMAIL_PASSWORDLESS: \"email_passwordless\"\n};\nconst translations = {\n    en: {\n        embed: {\n            continue: \"Continue\",\n            actionRequired: \"Authorization required\",\n            pendingAction: \"Click continue to proceed with your request in a popup\",\n            cookiesRequired: \"Cookies Required\",\n            enableCookies: \"Please enable cookies in your browser preferences to access Torus\",\n            clickHere: \"More Info\"\n        }\n    },\n    de: {\n        embed: {\n            continue: \"Fortsetzen\",\n            actionRequired: \"Autorisierung erforderlich\",\n            pendingAction: \"Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren\",\n            cookiesRequired: \"Cookies ben\\xf6tigt\",\n            enableCookies: \"Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen\",\n            clickHere: \"Mehr Info\"\n        }\n    },\n    ja: {\n        embed: {\n            continue: \"\",\n            actionRequired: \"\",\n            pendingAction: \"\",\n            cookiesRequired: \"\",\n            enableCookies: \"TorusCookie\",\n            clickHere: \"\"\n        }\n    },\n    ko: {\n        embed: {\n            continue: \"\",\n            actionRequired: \" \",\n            pendingAction: \"    .\",\n            cookiesRequired: \" \",\n            enableCookies: \"     Torus .\",\n            clickHere: \"  \"\n        }\n    },\n    zh: {\n        embed: {\n            continue: \"\",\n            actionRequired: \"\",\n            pendingAction: \"\",\n            cookiesRequired: \"Cookie\",\n            enableCookies: \"cookieTorus\",\n            clickHere: \"\"\n        }\n    }\n};\nvar configuration = {\n    supportedVerifierList: [\n        LOGIN_PROVIDER.GOOGLE,\n        LOGIN_PROVIDER.REDDIT,\n        LOGIN_PROVIDER.DISCORD\n    ],\n    api: \"https://api.tor.us\",\n    translations,\n    prodTorusUrl: \"\",\n    localStorageKeyPrefix: `torus-`\n};\nvar log = loglevel__WEBPACK_IMPORTED_MODULE_8___default().getLogger(\"solana-embed\");\n// utility functions\n/**\n * json-rpc-engine middleware that logs RPC errors and and validates req.method.\n *\n * @param log - The logging API to use.\n * @returns  json-rpc-engine middleware function\n */ function createErrorMiddleware() {\n    return (req, res, next)=>{\n        // json-rpc-engine will terminate the request when it notices this error\n        if (typeof req.method !== \"string\" || !req.method) {\n            res.error = eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n                message: `The request 'method' must be a non-empty string.`,\n                data: req\n            });\n        }\n        next((done)=>{\n            const { error } = res;\n            if (!error) {\n                return done();\n            }\n            log.error(`Torus - RPC Error: ${error.message}`, error);\n            return done();\n        });\n    };\n}\n/**\n * Logs a stream disconnection error. Emits an 'error' if given an\n * EventEmitter that has listeners for the 'error' event.\n *\n * @param log - The logging API to use.\n * @param remoteLabel - The label of the disconnected stream.\n * @param error - The associated error to log.\n * @param emitter - The logging API to use.\n */ function logStreamDisconnectWarning(remoteLabel, error, emitter) {\n    let warningMsg = `Torus: Lost connection to \"${remoteLabel}\".`;\n    if (error?.stack) {\n        warningMsg += `\\n${error.stack}`;\n    }\n    log.warn(warningMsg);\n    if (emitter && emitter.listenerCount(\"error\") > 0) {\n        emitter.emit(\"error\", warningMsg);\n    }\n}\nconst getWindowId = ()=>Math.random().toString(36).slice(2);\nconst getTorusUrl = async (buildEnv)=>{\n    let torusUrl;\n    let logLevel;\n    // const versionUsed = version;\n    // log.info(\"solana embed version used: \", versionUsed);\n    switch(buildEnv){\n        case \"testing\":\n            torusUrl = \"https://solana-testing.tor.us\";\n            logLevel = \"debug\";\n            break;\n        case \"development\":\n            torusUrl = \"http://localhost:8080\";\n            logLevel = \"debug\";\n            break;\n        default:\n            torusUrl = `https://solana.tor.us`;\n            logLevel = \"error\";\n            break;\n    }\n    return {\n        torusUrl,\n        logLevel\n    };\n};\nconst getUserLanguage = ()=>{\n    let userLanguage = window.navigator.language || \"en-US\";\n    const userLanguages = userLanguage.split(\"-\");\n    userLanguage = Object.prototype.hasOwnProperty.call(configuration.translations, userLanguages[0]) ? userLanguages[0] : \"en\";\n    return userLanguage;\n};\nconst FEATURES_PROVIDER_CHANGE_WINDOW = {\n    height: 660,\n    width: 375\n};\nconst FEATURES_DEFAULT_WALLET_WINDOW = {\n    height: 740,\n    width: 1315\n};\nconst FEATURES_DEFAULT_POPUP_WINDOW = {\n    height: 700,\n    width: 1200\n};\nconst FEATURES_CONFIRM_WINDOW = {\n    height: 600,\n    width: 400\n};\nfunction storageAvailable(type) {\n    let storage;\n    try {\n        storage = window[type];\n        const x = \"__storage_test__\";\n        storage.setItem(x, x);\n        storage.removeItem(x);\n        return true;\n    } catch (error) {\n        const e = error;\n        return e && // everything except Firefox\n        (e.code === 22 || // Firefox\n        e.code === 1014 || // test name field too, because code might not be present\n        // everything except Firefox\n        e.name === \"QuotaExceededError\" || // Firefox\n        e.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && // acknowledge QuotaExceededError only if there's something already stored\n        storage && storage.length !== 0;\n    }\n}\n/**\n * popup handler utils\n */ function getPopupFeatures(_ref) {\n    let { width: w, height: h } = _ref;\n    // Fixes dual-screen position                             Most browsers      Firefox\n    const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n    const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n    const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n    const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n    const systemZoom = 1; // No reliable estimate\n    const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n    const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n    const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;\n    return features;\n}\nclass BaseProvider extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.SafeEventEmitter {\n    constructor(connectionStream, _ref){\n        let { maxEventListeners = 100, jsonRpcStreamName = \"provider\" } = _ref;\n        super();\n        /**\n     * Indicating that this provider is a Torus provider.\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"isTorus\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"_rpcEngine\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"jsonRpcConnectionEvents\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"_state\", void 0);\n        if (!isDuplexStream(connectionStream)) {\n            throw new Error(messages.errors.invalidDuplexStream());\n        }\n        this.isTorus = true;\n        this.setMaxListeners(maxEventListeners);\n        this._handleConnect = this._handleConnect.bind(this);\n        this._handleDisconnect = this._handleDisconnect.bind(this);\n        this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);\n        this._rpcRequest = this._rpcRequest.bind(this);\n        this._initializeState = this._initializeState.bind(this);\n        this.request = this.request.bind(this);\n        this.sendAsync = this.sendAsync.bind(this);\n        // this.enable = this.enable.bind(this);\n        // setup connectionStream multiplexing\n        const mux = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.ObjectMultiplex();\n        pump__WEBPACK_IMPORTED_MODULE_7___default()(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, \"Torus\"));\n        // ignore phishing warning message (handled elsewhere)\n        mux.ignoreStream(\"phishing\");\n        // setup own event listeners\n        // connect to async provider\n        const jsonRpcConnection = (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.createStreamMiddleware)();\n        pump__WEBPACK_IMPORTED_MODULE_7___default()(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, \"Torus RpcProvider\"));\n        // handle RPC requests via dapp-side rpc engine\n        const rpcEngine = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.JRPCEngine();\n        rpcEngine.push((0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.createIdRemapMiddleware)());\n        rpcEngine.push(createErrorMiddleware());\n        rpcEngine.push((0,_toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.createLoggerMiddleware)({\n            origin: location.origin\n        }));\n        rpcEngine.push(jsonRpcConnection.middleware);\n        this._rpcEngine = rpcEngine;\n        this.jsonRpcConnectionEvents = jsonRpcConnection.events;\n    }\n    /**\n   * Submits an RPC request for the given method, with the given params.\n   * Resolves with the result of the method call, or rejects on error.\n   */ async request(args) {\n        if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n                message: messages.errors.invalidRequestArgs(),\n                data: args\n            });\n        }\n        const { method, params } = args;\n        if (typeof method !== \"string\" || method.length === 0) {\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n                message: messages.errors.invalidRequestMethod(),\n                data: args\n            });\n        }\n        if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n            throw eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.ethErrors.rpc.invalidRequest({\n                message: messages.errors.invalidRequestParams(),\n                data: args\n            });\n        }\n        return new Promise((resolve, reject)=>{\n            this._rpcRequest({\n                method,\n                params\n            }, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.getRpcPromiseCallback)(resolve, reject));\n        });\n    }\n    /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   */ send(payload, callback) {\n        this._rpcRequest(payload, callback);\n    }\n    /**\n   * Submits an RPC request per the given JSON-RPC request object.\n   */ sendAsync(payload) {\n        return new Promise((resolve, reject)=>{\n            this._rpcRequest(payload, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.getRpcPromiseCallback)(resolve, reject));\n        });\n    }\n    /**\n   * Called when connection is lost to critical streams.\n   *\n   * emits TorusInpageProvider#disconnect\n   */ _handleStreamDisconnect(streamName, error) {\n        logStreamDisconnectWarning(streamName, error, this);\n        this._handleDisconnect(false, error ? error.message : undefined);\n    }\n}\nconst htmlToElement = (html)=>{\n    const template = window.document.createElement(\"template\");\n    const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result\n    template.innerHTML = trimmedHtml;\n    return template.content.firstChild;\n};\nfunction isLegacyTransactionInstance(transaction) {\n    return transaction.version === undefined;\n}\nclass PopupHandler extends _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.SafeEventEmitter {\n    constructor(_ref){\n        let { url, target, features, timeout = 30000 } = _ref;\n        super();\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"url\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"target\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"features\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"window\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"windowTimer\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"iClosedWindow\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"timeout\", void 0);\n        this.url = url;\n        this.target = target || \"_blank\";\n        this.features = features || getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW);\n        this.window = undefined;\n        this.windowTimer = undefined;\n        this.iClosedWindow = false;\n        this.timeout = timeout;\n        this._setupTimer();\n    }\n    _setupTimer() {\n        this.windowTimer = Number(setInterval(()=>{\n            if (this.window && this.window.closed) {\n                clearInterval(this.windowTimer);\n                setTimeout(()=>{\n                    if (!this.iClosedWindow) {\n                        this.emit(\"close\");\n                    }\n                    this.iClosedWindow = false;\n                    this.window = undefined;\n                }, this.timeout);\n            }\n            if (this.window === undefined) clearInterval(this.windowTimer);\n        }, 500));\n    }\n    open() {\n        this.window = window.open(this.url.href, this.target, this.features);\n        if (this.window?.focus) this.window.focus();\n        return Promise.resolve();\n    }\n    close() {\n        this.iClosedWindow = true;\n        if (this.window) this.window.close();\n    }\n    redirect(locationReplaceOnRedirect) {\n        if (locationReplaceOnRedirect) {\n            window.location.replace(this.url.href);\n        } else {\n            window.location.href = this.url.href;\n        }\n    }\n}\nclass TorusCommunicationProvider extends BaseProvider {\n    constructor(connectionStream, _ref){\n        let { maxEventListeners = 100, jsonRpcStreamName = \"provider\" } = _ref;\n        super(connectionStream, {\n            maxEventListeners,\n            jsonRpcStreamName\n        });\n        // private state\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"embedTranslations\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusUrl\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"dappStorageKey\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"windowRefs\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"tryWindowHandle\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusAlertContainer\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusIframe\", void 0);\n        this._state = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, TorusCommunicationProvider._defaultState);\n        // public state\n        this.torusUrl = \"\";\n        this.dappStorageKey = \"\";\n        const languageTranslations = configuration.translations[getUserLanguage()];\n        this.embedTranslations = languageTranslations.embed;\n        this.windowRefs = {};\n        // setup own event listeners\n        // EIP-1193 connect\n        this.on(\"connect\", ()=>{\n            this._state.isConnected = true;\n        });\n        const notificationHandler = (payload)=>{\n            const { method, params } = payload;\n            if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {\n                const { isFullScreen, rid } = params;\n                this._displayIframe({\n                    isFull: isFullScreen,\n                    rid: rid\n                });\n            // TODO: remove this method when wallet adds versioning and stops supporting this method\n            } else if (method === \"create_window\") {\n                const { windowId, url } = params;\n                this._createPopupBlockAlert(windowId, url);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) {\n                this._handleCloseWindow(params);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {\n                const { currentLoginProvider } = params;\n                this._state.isLoggedIn = true;\n                this._state.currentLoginProvider = currentLoginProvider;\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {\n                this._state.isLoggedIn = false;\n                this._state.currentLoginProvider = null;\n                this._displayIframe();\n            }\n        };\n        this.jsonRpcConnectionEvents.on(\"notification\", notificationHandler);\n    }\n    get isLoggedIn() {\n        return this._state.isLoggedIn;\n    }\n    get isIFrameFullScreen() {\n        return this._state.isIFrameFullScreen;\n    }\n    /**\n   * Returns whether the inPage provider is connected to Torus.\n   */ isConnected() {\n        return this._state.isConnected;\n    }\n    async _initializeState(params) {\n        try {\n            const { torusUrl, dappStorageKey, torusAlertContainer, torusIframe } = params;\n            this.torusUrl = torusUrl;\n            this.dappStorageKey = dappStorageKey;\n            this.torusAlertContainer = torusAlertContainer;\n            this.torusIframe = torusIframe;\n            this.torusIframe.addEventListener(\"load\", ()=>{\n                // only do this if iframe is not full screen\n                if (!this._state.isIFrameFullScreen) this._displayIframe();\n            });\n            const { currentLoginProvider, isLoggedIn } = await this.request({\n                method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,\n                params: []\n            });\n            // indicate that we've connected, for EIP-1193 compliance\n            this._handleConnect(currentLoginProvider, isLoggedIn);\n        } catch (error) {\n            log.error(\"Torus: Failed to get initial state. Please report this bug.\", error);\n        } finally{\n            log.info(\"initialized communication state\");\n            this._state.initialized = true;\n            this.emit(\"_initialized\");\n        }\n    }\n    _handleWindow(windowId) {\n        let { url, target, features } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const finalUrl = new URL(url || `${this.torusUrl}/redirect?windowId=${windowId}`);\n        if (this.dappStorageKey) {\n            // If multiple instances, it returns the first one\n            if (finalUrl.hash) finalUrl.hash += `&dappStorageKey=${this.dappStorageKey}`;\n            else finalUrl.hash = `#dappStorageKey=${this.dappStorageKey}`;\n        }\n        const handledWindow = new PopupHandler({\n            url: finalUrl,\n            target,\n            features\n        });\n        handledWindow.open();\n        if (!handledWindow.window) {\n            this._createPopupBlockAlert(windowId, finalUrl.href);\n            return;\n        }\n        // Add to collection only if window is opened\n        this.windowRefs[windowId] = handledWindow;\n        // We tell the iframe that the window has been successfully opened\n        this.request({\n            method: \"opened_window\",\n            params: {\n                windowId\n            }\n        });\n        handledWindow.once(\"close\", ()=>{\n            // user closed the window\n            delete this.windowRefs[windowId];\n            this.request({\n                method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,\n                params: {\n                    windowId\n                }\n            });\n        });\n    }\n    _displayIframe() {\n        let { isFull = false, rid = \"\" } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const style = {};\n        // set phase\n        if (!isFull) {\n            style.display = this._state.torusWidgetVisibility ? \"block\" : \"none\";\n            style.height = \"70px\";\n            style.width = \"70px\";\n            switch(this._state.buttonPosition){\n                case BUTTON_POSITION.TOP_LEFT:\n                    style.top = \"0px\";\n                    style.left = \"0px\";\n                    style.right = \"auto\";\n                    style.bottom = \"auto\";\n                    break;\n                case BUTTON_POSITION.TOP_RIGHT:\n                    style.top = \"0px\";\n                    style.right = \"0px\";\n                    style.left = \"auto\";\n                    style.bottom = \"auto\";\n                    break;\n                case BUTTON_POSITION.BOTTOM_RIGHT:\n                    style.bottom = \"0px\";\n                    style.right = \"0px\";\n                    style.top = \"auto\";\n                    style.left = \"auto\";\n                    break;\n                case BUTTON_POSITION.BOTTOM_LEFT:\n                default:\n                    style.bottom = \"0px\";\n                    style.left = \"0px\";\n                    style.top = \"auto\";\n                    style.right = \"auto\";\n                    break;\n            }\n        } else {\n            style.display = \"block\";\n            style.width = \"100%\";\n            style.height = \"100%\";\n            style.top = \"0px\";\n            style.right = \"0px\";\n            style.left = \"0px\";\n            style.bottom = \"0px\";\n        }\n        Object.assign(this.torusIframe.style, style);\n        this._state.isIFrameFullScreen = isFull;\n        this.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,\n            params: {\n                isIFrameFullScreen: isFull,\n                rid\n            }\n        });\n    }\n    hideTorusButton() {\n        this._state.torusWidgetVisibility = false;\n        this._displayIframe();\n    }\n    showTorusButton() {\n        this._state.torusWidgetVisibility = true;\n        this._displayIframe();\n    }\n    /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */ _rpcRequest(payload, callback) {\n        const cb = callback;\n        const _payload = payload;\n        if (!Array.isArray(_payload)) {\n            if (!_payload.jsonrpc) {\n                _payload.jsonrpc = \"2.0\";\n            }\n        }\n        this.tryWindowHandle(_payload, cb);\n    }\n    /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param currentLoginProvider - The login Provider\n   * emits TorusInpageProvider#connect\n   */ _handleConnect(currentLoginProvider, isLoggedIn) {\n        if (!this._state.isConnected) {\n            this._state.isConnected = true;\n            this.emit(\"connect\", {\n                currentLoginProvider,\n                isLoggedIn\n            });\n            log.debug(messages.info.connected(currentLoginProvider));\n        }\n    }\n    /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits TorusInpageProvider#disconnect\n   */ _handleDisconnect(isRecoverable, errorMessage) {\n        if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n            this._state.isConnected = false;\n            let error;\n            if (isRecoverable) {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.EthereumRpcError(1013, // Try again later\n                errorMessage || messages.errors.disconnected());\n                log.debug(error);\n            } else {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.EthereumRpcError(1011, // Internal error\n                errorMessage || messages.errors.permanentlyDisconnected());\n                log.error(error);\n                this._state.currentLoginProvider = null;\n                this._state.isLoggedIn = false;\n                this._state.torusWidgetVisibility = false;\n                this._state.isIFrameFullScreen = false;\n                this._state.isPermanentlyDisconnected = true;\n            }\n            this.emit(\"disconnect\", error);\n        }\n    }\n    // Called if the iframe wants to close the window cause it is done processing the request\n    _handleCloseWindow(params) {\n        const { windowId } = params;\n        if (this.windowRefs[windowId]) {\n            this.windowRefs[windowId].close();\n            delete this.windowRefs[windowId];\n        }\n    }\n    async _createPopupBlockAlert(windowId, url) {\n        const logoUrl = this.getLogoUrl();\n        const torusAlert = htmlToElement('<div id=\"torusAlert\" class=\"torus-alert--v2\">' + `<div id=\"torusAlert__logo\"><img src=\"${logoUrl}\" /></div>` + \"<div>\" + `<h1 id=\"torusAlert__title\">${this.embedTranslations.actionRequired}</h1>` + `<p id=\"torusAlert__desc\">${this.embedTranslations.pendingAction}</p>` + \"</div>\" + \"</div>\");\n        const successAlert = htmlToElement(`<div><a id=\"torusAlert__btn\">${this.embedTranslations.continue}</a></div>`);\n        const btnContainer = htmlToElement('<div id=\"torusAlert__btn-container\"></div>');\n        btnContainer.appendChild(successAlert);\n        torusAlert.appendChild(btnContainer);\n        const bindOnLoad = ()=>{\n            successAlert.addEventListener(\"click\", ()=>{\n                this._handleWindow(windowId, {\n                    url,\n                    target: \"_blank\",\n                    features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)\n                });\n                torusAlert.remove();\n                if (this.torusAlertContainer.children.length === 0) this.torusAlertContainer.style.display = \"none\";\n            });\n        };\n        const attachOnLoad = ()=>{\n            this.torusAlertContainer.appendChild(torusAlert);\n        };\n        attachOnLoad();\n        bindOnLoad();\n        this.torusAlertContainer.style.display = \"block\";\n    }\n    getLogoUrl() {\n        const logoUrl = `${this.torusUrl}/images/torus_icon-blue.svg`;\n        return logoUrl;\n    }\n}\n_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(TorusCommunicationProvider, \"_defaultState\", {\n    buttonPosition: \"bottom-left\",\n    currentLoginProvider: null,\n    isIFrameFullScreen: false,\n    hasEmittedConnection: false,\n    torusWidgetVisibility: false,\n    initialized: false,\n    isLoggedIn: false,\n    isPermanentlyDisconnected: false,\n    isConnected: false\n});\nclass TorusInPageProvider extends BaseProvider {\n    constructor(connectionStream, _ref){\n        let { maxEventListeners = 100, jsonRpcStreamName = \"provider\" } = _ref;\n        super(connectionStream, {\n            maxEventListeners,\n            jsonRpcStreamName\n        });\n        // private state\n        /**\n     * The chain ID of the currently connected Solana chain.\n     * See [chainId.network]{@link https://chainid.network} for more information.\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"chainId\", void 0);\n        /**\n     * The user's currently selected Solana address.\n     * If null, Torus is either locked or the user has not permitted any\n     * addresses to be viewed.\n     */ _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"selectedAddress\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"tryWindowHandle\", void 0);\n        this._state = _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, TorusInPageProvider._defaultState);\n        // public state\n        this.selectedAddress = null;\n        this.chainId = null;\n        this._handleAccountsChanged = this._handleAccountsChanged.bind(this);\n        this._handleChainChanged = this._handleChainChanged.bind(this);\n        this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);\n        // setup own event listeners\n        // EIP-1193 connect\n        this.on(\"connect\", ()=>{\n            this._state.isConnected = true;\n        });\n        const jsonRpcNotificationHandler = (payload)=>{\n            const { method, params } = payload;\n            if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.PROVIDER_NOTIFICATIONS.ACCOUNTS_CHANGED) {\n                this._handleAccountsChanged(params);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.PROVIDER_NOTIFICATIONS.UNLOCK_STATE_CHANGED) {\n                this._handleUnlockStateChanged(params);\n            } else if (method === _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.PROVIDER_NOTIFICATIONS.CHAIN_CHANGED) {\n                this._handleChainChanged(params);\n            }\n        };\n        // json rpc notification listener\n        this.jsonRpcConnectionEvents.on(\"notification\", jsonRpcNotificationHandler);\n    }\n    /**\n   * Returns whether the inpage provider is connected to Torus.\n   */ isConnected() {\n        return this._state.isConnected;\n    }\n    // Private Methods\n    //= ===================\n    /**\n   * Constructor helper.\n   * Populates initial state by calling 'wallet_getProviderState' and emits\n   * necessary events.\n   */ async _initializeState() {\n        try {\n            const { accounts, chainId, isUnlocked } = await this.request({\n                method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE,\n                params: []\n            });\n            // indicate that we've connected, for EIP-1193 compliance\n            this.emit(\"connect\", {\n                chainId\n            });\n            this._handleChainChanged({\n                chainId\n            });\n            this._handleUnlockStateChanged({\n                accounts,\n                isUnlocked\n            });\n            this._handleAccountsChanged(accounts);\n        } catch (error) {\n            log.error(\"Torus: Failed to get initial state. Please report this bug.\", error);\n        } finally{\n            log.info(\"initialized provider state\");\n            this._state.initialized = true;\n            this.emit(\"_initialized\");\n        }\n    }\n    /**\n   * Internal RPC method. Forwards requests to background via the RPC engine.\n   * Also remap ids inbound and outbound\n   */ _rpcRequest(payload, callback) {\n        let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        let cb = callback;\n        const _payload = payload;\n        if (!Array.isArray(_payload)) {\n            if (!_payload.jsonrpc) {\n                _payload.jsonrpc = \"2.0\";\n            }\n            if (_payload.method === \"solana_accounts\" || _payload.method === \"solana_requestAccounts\") {\n                // handle accounts changing\n                cb = (err, res)=>{\n                    this._handleAccountsChanged(res.result || [], _payload.method === \"solana_accounts\", isInternal);\n                    callback(err, res);\n                };\n            } else if (_payload.method === \"wallet_getProviderState\") {\n                this._rpcEngine.handle(payload, cb);\n                return;\n            }\n        }\n        this.tryWindowHandle(_payload, cb);\n    }\n    /**\n   * When the provider becomes connected, updates internal state and emits\n   * required events. Idempotent.\n   *\n   * @param chainId - The ID of the newly connected chain.\n   * emits TorusInpageProvider#connect\n   */ _handleConnect(chainId) {\n        if (!this._state.isConnected) {\n            this._state.isConnected = true;\n            this.emit(\"connect\", {\n                chainId\n            });\n            log.debug(messages.info.connected(chainId));\n        }\n    }\n    /**\n   * When the provider becomes disconnected, updates internal state and emits\n   * required events. Idempotent with respect to the isRecoverable parameter.\n   *\n   * Error codes per the CloseEvent status codes as required by EIP-1193:\n   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n   *\n   * @param isRecoverable - Whether the disconnection is recoverable.\n   * @param errorMessage - A custom error message.\n   * emits TorusInpageProvider#disconnect\n   */ _handleDisconnect(isRecoverable, errorMessage) {\n        if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {\n            this._state.isConnected = false;\n            let error;\n            if (isRecoverable) {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.EthereumRpcError(1013, // Try again later\n                errorMessage || messages.errors.disconnected());\n                log.debug(error);\n            } else {\n                error = new eth_rpc_errors__WEBPACK_IMPORTED_MODULE_6__.EthereumRpcError(1011, // Internal error\n                errorMessage || messages.errors.permanentlyDisconnected());\n                log.error(error);\n                this.chainId = null;\n                this._state.accounts = null;\n                this.selectedAddress = null;\n                this._state.isUnlocked = false;\n                this._state.isPermanentlyDisconnected = true;\n            }\n            this.emit(\"disconnect\", error);\n        }\n    }\n    /**\n   * Called when accounts may have changed.\n   */ _handleAccountsChanged(accounts) {\n        let isEthAccounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        let isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        // defensive programming\n        let finalAccounts = accounts;\n        if (!Array.isArray(finalAccounts)) {\n            log.error(\"Torus: Received non-array accounts parameter. Please report this bug.\", finalAccounts);\n            finalAccounts = [];\n        }\n        for (const account of accounts){\n            if (typeof account !== \"string\") {\n                log.error(\"Torus: Received non-string account. Please report this bug.\", accounts);\n                finalAccounts = [];\n                break;\n            }\n        }\n        // emit accountsChanged if anything about the accounts array has changed\n        if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_9___default()(this._state.accounts, finalAccounts)) {\n            // we should always have the correct accounts even before solana_accounts\n            // returns, except in cases where isInternal is true\n            if (isEthAccounts && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !isInternal) {\n                log.error('Torus: \"solana_accounts\" unexpectedly updated accounts. Please report this bug.', finalAccounts);\n            }\n            this._state.accounts = finalAccounts;\n            this.emit(\"accountsChanged\", finalAccounts);\n        }\n        // handle selectedAddress\n        if (this.selectedAddress !== finalAccounts[0]) {\n            this.selectedAddress = finalAccounts[0] || null;\n        }\n    }\n    /**\n   * Upon receipt of a new chainId and networkVersion, emits corresponding\n   * events and sets relevant public state.\n   * Does nothing if neither the chainId nor the networkVersion are different\n   * from existing values.\n   *\n   * emits TorusInpageProvider#chainChanged\n   * @param networkInfo - An object with network info.\n   */ _handleChainChanged() {\n        let { chainId } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!chainId) {\n            log.error(\"Torus: Received invalid network parameters. Please report this bug.\", {\n                chainId\n            });\n            return;\n        }\n        if (chainId === \"loading\") {\n            this._handleDisconnect(true);\n        } else {\n            this._handleConnect(chainId);\n            if (chainId !== this.chainId) {\n                this.chainId = chainId;\n                if (this._state.initialized) {\n                    this.emit(\"chainChanged\", this.chainId);\n                }\n            }\n        }\n    }\n    /**\n   * Upon receipt of a new isUnlocked state, sets relevant public state.\n   * Calls the accounts changed handler with the received accounts, or an empty\n   * array.\n   *\n   * Does nothing if the received value is equal to the existing value.\n   * There are no lock/unlock events.\n   *\n   * @param opts - Options bag.\n   */ _handleUnlockStateChanged() {\n        let { accounts, isUnlocked } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (typeof isUnlocked !== \"boolean\") {\n            log.error(\"Torus: Received invalid isUnlocked parameter. Please report this bug.\", {\n                isUnlocked\n            });\n            return;\n        }\n        if (isUnlocked !== this._state.isUnlocked) {\n            this._state.isUnlocked = isUnlocked;\n            this._handleAccountsChanged(accounts || []);\n        }\n    }\n}\n_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(TorusInPageProvider, \"_defaultState\", {\n    accounts: null,\n    isConnected: false,\n    isUnlocked: false,\n    initialized: false,\n    isPermanentlyDisconnected: false,\n    hasEmittedConnection: false\n});\n/**\n * Returns whether the given image URL exists\n */ function imgExists(url) {\n    return new Promise((resolve, reject)=>{\n        try {\n            const img = document.createElement(\"img\");\n            img.onload = ()=>resolve(true);\n            img.onerror = ()=>resolve(false);\n            img.src = url;\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n/**\n * Extracts a name for the site from the DOM\n */ const getSiteName = (window1)=>{\n    const { document: document1 } = window1;\n    const siteName = document1.querySelector('head > meta[property=\"og:site_name\"]');\n    if (siteName) {\n        return siteName.content;\n    }\n    const metaTitle = document1.querySelector('head > meta[name=\"title\"]');\n    if (metaTitle) {\n        return metaTitle.content;\n    }\n    if (document1.title && document1.title.length > 0) {\n        return document1.title;\n    }\n    return window1.location.hostname;\n};\n/**\n * Extracts an icon for the site from the DOM\n */ async function getSiteIcon(window1) {\n    try {\n        const { document: document1 } = window1;\n        // Use the site's favicon if it exists\n        let icon = document1.querySelector('head > link[rel=\"shortcut icon\"]');\n        if (icon && await imgExists(icon.href)) {\n            return icon.href;\n        }\n        // Search through available icons in no particular order\n        icon = Array.from(document1.querySelectorAll('head > link[rel=\"icon\"]')).find((_icon)=>Boolean(_icon.href));\n        if (icon && await imgExists(icon.href)) {\n            return icon.href;\n        }\n        return \"\";\n    } catch (error) {\n        return \"\";\n    }\n}\n/**\n * Gets site metadata and returns it\n *\n */ const getSiteMetadata = async ()=>({\n        name: getSiteName(window),\n        icon: await getSiteIcon(window)\n    });\nconst PROVIDER_UNSAFE_METHODS = [\n    \"send_transaction\",\n    \"sign_transaction\",\n    \"sign_all_transactions\",\n    \"sign_message\",\n    \"connect\"\n];\nconst COMMUNICATION_UNSAFE_METHODS = [\n    _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.SET_PROVIDER\n];\nconst isLocalStorageAvailable = storageAvailable(\"localStorage\");\n// preload for iframe doesn't work https://bugs.chromium.org/p/chromium/issues/detail?id=593267\n(async function preLoadIframe() {\n    try {\n        if (typeof document === \"undefined\") return;\n        const torusIframeHtml = document.createElement(\"link\");\n        const { torusUrl } = await getTorusUrl(\"production\");\n        torusIframeHtml.href = `${torusUrl}/frame`;\n        torusIframeHtml.crossOrigin = \"anonymous\";\n        torusIframeHtml.type = \"text/html\";\n        torusIframeHtml.rel = \"prefetch\";\n        if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {\n            if (torusIframeHtml.relList.supports(\"prefetch\")) {\n                document.head.appendChild(torusIframeHtml);\n            }\n        }\n    } catch (error) {\n        log.warn(error);\n    }\n})();\nclass Torus {\n    constructor(){\n        let { modalZIndex = 99999 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"isInitialized\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusAlert\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"modalZIndex\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"alertZIndex\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"requestedLoginProvider\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"provider\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"communicationProvider\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"dappStorageKey\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"isTopupHidden\", false);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusAlertContainer\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusUrl\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"torusIframe\", void 0);\n        _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(this, \"styleLink\", void 0);\n        this.torusUrl = \"\";\n        this.isInitialized = false; // init done\n        this.requestedLoginProvider = null;\n        this.modalZIndex = modalZIndex;\n        this.alertZIndex = modalZIndex + 1000;\n        this.dappStorageKey = \"\";\n    }\n    get isLoggedIn() {\n        if (!this.communicationProvider) return false;\n        return this.communicationProvider.isLoggedIn;\n    }\n    async init() {\n        let { buildEnv = TORUS_BUILD_ENV.PRODUCTION, enableLogging = false, network, showTorusButton = false, useLocalStorage = false, buttonPosition = BUTTON_POSITION.BOTTOM_LEFT, apiKey = \"torus-default\", extraParams = {}, whiteLabel } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (this.isInitialized) throw new Error(\"Already initialized\");\n        (0,_toruslabs_http_helpers__WEBPACK_IMPORTED_MODULE_4__.setAPIKey)(apiKey);\n        const { torusUrl, logLevel } = await getTorusUrl(buildEnv);\n        log.enableAll();\n        log.info(torusUrl, \"url loaded\");\n        log.info(`Solana Embed Version :${version}`);\n        this.torusUrl = torusUrl;\n        log.setDefaultLevel(logLevel);\n        if (enableLogging) log.enableAll();\n        else log.disableAll();\n        const dappStorageKey = this.handleDappStorageKey(useLocalStorage);\n        const torusIframeUrl = new URL(torusUrl);\n        if (torusIframeUrl.pathname.endsWith(\"/\")) torusIframeUrl.pathname += \"frame\";\n        else torusIframeUrl.pathname += \"/frame\";\n        const hashParams = new URLSearchParams();\n        if (dappStorageKey) hashParams.append(\"dappStorageKey\", dappStorageKey);\n        hashParams.append(\"origin\", window.location.origin);\n        torusIframeUrl.hash = hashParams.toString();\n        // Iframe code\n        this.torusIframe = htmlToElement(`<iframe\n        id=\"torusIframe\"\n        class=\"torusIframe\"\n        src=\"${torusIframeUrl.href}\"\n        style=\"display: none; position: fixed; top: 0; right: 0; width: 100%;\n        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex.toString()}\"\n      ></iframe>`);\n        this.torusAlertContainer = htmlToElement(`<div id=\"torusAlertContainer\" style=\"display:none; z-index: ${this.alertZIndex.toString()}\"></div>`);\n        this.styleLink = htmlToElement(`<link href=\"${torusUrl}/css/widget.css\" rel=\"stylesheet\" type=\"text/css\">`);\n        return new Promise((resolve, reject)=>{\n            try {\n                this.torusIframe.addEventListener(\"load\", async ()=>{\n                    const dappMetadata = await getSiteMetadata();\n                    // send init params here\n                    this.torusIframe.contentWindow.postMessage({\n                        buttonPosition,\n                        apiKey,\n                        network,\n                        dappMetadata,\n                        extraParams,\n                        whiteLabel\n                    }, torusIframeUrl.origin);\n                    await this._setupWeb3({\n                        torusUrl\n                    });\n                    if (showTorusButton) this.showTorusButton();\n                    if (whiteLabel?.topupHide) this.isTopupHidden = whiteLabel.topupHide;\n                    else this.hideTorusButton();\n                    this.isInitialized = true;\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    window.torus = this;\n                    resolve();\n                });\n                window.document.head.appendChild(this.styleLink);\n                window.document.body.appendChild(this.torusIframe);\n                window.document.body.appendChild(this.torusAlertContainer);\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n    async login() {\n        let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!this.isInitialized) throw new Error(\"Call init() first\");\n        try {\n            this.requestedLoginProvider = params.loginProvider || null;\n            if (!this.requestedLoginProvider) {\n                this.communicationProvider._displayIframe({\n                    isFull: true\n                });\n            }\n            // If user is already logged in, we assume they have given access to the website\n            const res = await new Promise((resolve, reject)=>{\n                // We use this method because we want to update inPage provider state with account info\n                this.provider._rpcRequest({\n                    method: \"solana_requestAccounts\",\n                    params: [\n                        this.requestedLoginProvider,\n                        params.login_hint\n                    ]\n                }, (0,_toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.getRpcPromiseCallback)(resolve, reject));\n            });\n            if (Array.isArray(res) && res.length > 0) {\n                return res;\n            }\n            // This would never happen, but just in case\n            throw new Error(\"Login failed\");\n        } catch (error) {\n            log.error(\"login failed\", error);\n            throw error;\n        } finally{\n            if (this.communicationProvider.isIFrameFullScreen) this.communicationProvider._displayIframe();\n        }\n    }\n    async loginWithPrivateKey(loginParams) {\n        if (!this.isInitialized) throw new Error(\"Call init() first\");\n        const { privateKey, userInfo } = loginParams;\n        const { success } = await this.communicationProvider.request({\n            method: \"login_with_private_key\",\n            params: {\n                privateKey,\n                userInfo\n            }\n        });\n        if (!success) throw new Error(\"Login Failed\");\n    }\n    async logout() {\n        if (!this.communicationProvider.isLoggedIn) throw new Error(\"Not logged in\");\n        await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.LOGOUT,\n            params: []\n        });\n        this.requestedLoginProvider = null;\n    }\n    async cleanUp() {\n        if (this.communicationProvider.isLoggedIn) {\n            await this.logout();\n        }\n        this.clearInit();\n    }\n    clearInit() {\n        function isElement(element) {\n            return element instanceof Element || element instanceof Document;\n        }\n        if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {\n            this.styleLink.remove();\n            this.styleLink = undefined;\n        }\n        if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {\n            this.torusIframe.remove();\n            this.torusIframe = undefined;\n        }\n        if (isElement(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer)) {\n            this.torusAlert = undefined;\n            this.torusAlertContainer.remove();\n            this.torusAlertContainer = undefined;\n        }\n        this.isInitialized = false;\n    }\n    hideTorusButton() {\n        this.communicationProvider.hideTorusButton();\n    }\n    showTorusButton() {\n        this.communicationProvider.showTorusButton();\n    }\n    async setProvider(params) {\n        await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.SET_PROVIDER,\n            params: _babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, params)\n        });\n    }\n    async showWallet(path) {\n        let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const instanceId = await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID,\n            params: []\n        });\n        const finalPath = path ? `/${path}` : \"\";\n        const finalUrl = new URL(`${this.torusUrl}/wallet${finalPath}`);\n        // Using URL constructor to prevent js injection and allow parameter validation.!\n        finalUrl.searchParams.append(\"instanceId\", instanceId);\n        Object.keys(params).forEach((x)=>{\n            finalUrl.searchParams.append(x, params[x]);\n        });\n        if (this.dappStorageKey) {\n            finalUrl.hash = `#dappStorageKey=${this.dappStorageKey}`;\n        }\n        // No need to track this window state. Hence, no _handleWindow call.\n        const walletWindow = new PopupHandler({\n            url: finalUrl,\n            features: getPopupFeatures(FEATURES_DEFAULT_WALLET_WINDOW)\n        });\n        walletWindow.open();\n    }\n    async getUserInfo() {\n        const userInfoResponse = await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.USER_INFO,\n            params: []\n        });\n        return userInfoResponse;\n    }\n    async initiateTopup(provider, params) {\n        if (!this.isInitialized) throw new Error(\"Torus is not initialized\");\n        const windowId = getWindowId();\n        this.communicationProvider._handleWindow(windowId);\n        const topupResponse = await this.communicationProvider.request({\n            method: _toruslabs_base_controllers__WEBPACK_IMPORTED_MODULE_3__.COMMUNICATION_JRPC_METHODS.TOPUP,\n            params: {\n                provider,\n                params,\n                windowId\n            }\n        });\n        return topupResponse;\n    }\n    // Solana specific API\n    async getAccounts() {\n        const response = await this.provider.request({\n            method: \"getAccounts\",\n            params: []\n        });\n        return response;\n    }\n    async sendTransaction(transaction) {\n        const isLegacyTransaction = isLegacyTransactionInstance(transaction);\n        const message = isLegacyTransaction ? transaction.serialize({\n            requireAllSignatures: false\n        }).toString(\"hex\") : Buffer.from(transaction.serialize()).toString(\"hex\");\n        const response = await this.provider.request({\n            method: \"send_transaction\",\n            params: {\n                message,\n                isLegacyTransaction\n            }\n        });\n        return response;\n    }\n    // support sendOptions\n    async signAndSendTransaction(transaction, options) {\n        const isLegacyTransaction = isLegacyTransactionInstance(transaction);\n        const message = isLegacyTransaction ? transaction.serialize({\n            requireAllSignatures: false\n        }).toString(\"hex\") : Buffer.from(transaction.serialize()).toString(\"hex\");\n        const response = await this.provider.request({\n            method: \"send_transaction\",\n            params: {\n                message,\n                options,\n                isLegacyTransaction\n            }\n        });\n        return {\n            signature: response\n        };\n    }\n    async signTransaction(transaction) {\n        const isLegacyTransaction = isLegacyTransactionInstance(transaction);\n        const message = isLegacyTransaction ? transaction.serializeMessage().toString(\"hex\") : Buffer.from(transaction.message.serialize()).toString(\"hex\");\n        const response = await this.provider.request({\n            method: \"sign_transaction\",\n            params: {\n                message,\n                messageOnly: true,\n                isLegacyTransaction\n            }\n        });\n        // reconstruct signature pair\n        const parsed = JSON.parse(response);\n        const signature = {\n            publicKey: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(parsed.publicKey),\n            signature: Buffer.from(parsed.signature, \"hex\")\n        };\n        transaction.addSignature(signature.publicKey, signature.signature);\n        return transaction;\n    }\n    async signAllTransactions(transactions) {\n        let isLegacyTransaction;\n        const encodedMessage = transactions.map((tx)=>{\n            isLegacyTransaction = isLegacyTransactionInstance(tx);\n            return isLegacyTransaction ? tx.serializeMessage().toString(\"hex\") : Buffer.from(tx.message.serialize()).toString(\"hex\");\n        });\n        const responses = await this.provider.request({\n            method: \"sign_all_transactions\",\n            params: {\n                message: encodedMessage,\n                messageOnly: true,\n                isLegacyTransaction\n            }\n        });\n        // reconstruct signature pairs\n        const signatures = responses.map((item)=>{\n            const parsed = JSON.parse(item);\n            return {\n                publicKey: new _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.PublicKey(parsed.publicKey),\n                signature: Buffer.from(parsed.signature, \"hex\")\n            };\n        });\n        transactions.forEach((tx, idx)=>{\n            tx.addSignature(signatures[idx].publicKey, signatures[idx].signature);\n            return tx;\n        });\n        return transactions;\n    }\n    async signMessage(data) {\n        const response = await this.provider.request({\n            method: \"sign_message\",\n            params: {\n                data\n            }\n        });\n        return response;\n    }\n    async getGaslessPublicKey() {\n        const response = await this.provider.request({\n            method: \"get_gasless_public_key\",\n            params: []\n        });\n        return response;\n    }\n    // async connect(): Promise<boolean> {\n    //   const response = (await this.provider.request({\n    //     method: \"connect\",\n    //     params: {},\n    //   })) as boolean;\n    //   return response;\n    // }\n    handleDappStorageKey(useLocalStorage) {\n        const localStorageKey = `${configuration.localStorageKeyPrefix}${window.location.hostname}`;\n        let dappStorageKey = \"\";\n        if (isLocalStorageAvailable && useLocalStorage) {\n            const storedKey = window.localStorage.getItem(localStorageKey);\n            if (storedKey) dappStorageKey = storedKey;\n            else {\n                const generatedKey = `torus-app-${getWindowId()}`;\n                window.localStorage.setItem(localStorageKey, generatedKey);\n                dappStorageKey = generatedKey;\n            }\n        }\n        this.dappStorageKey = dappStorageKey;\n        return dappStorageKey;\n    }\n    async _setupWeb3(providerParams) {\n        log.info(\"setupWeb3 running\");\n        // setup background connection\n        const providerStream = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.BasePostMessageStream({\n            name: \"embed_torus\",\n            target: \"iframe_torus\",\n            targetWindow: this.torusIframe.contentWindow\n        });\n        // We create another LocalMessageDuplexStream for communication between dapp <> iframe\n        const communicationStream = new _toruslabs_openlogin_jrpc__WEBPACK_IMPORTED_MODULE_5__.BasePostMessageStream({\n            name: \"embed_communication\",\n            target: \"iframe_communication\",\n            targetWindow: this.torusIframe.contentWindow\n        });\n        // compose the inPage provider\n        const inPageProvider = new TorusInPageProvider(providerStream, {});\n        const communicationProvider = new TorusCommunicationProvider(communicationStream, {});\n        inPageProvider.tryWindowHandle = (payload, cb)=>{\n            const _payload = payload;\n            if (!Array.isArray(_payload) && PROVIDER_UNSAFE_METHODS.includes(_payload.method)) {\n                if (!this.communicationProvider.isLoggedIn) throw new Error(\"User Not Logged In\");\n                const windowId = getWindowId();\n                communicationProvider._handleWindow(windowId, {\n                    target: \"_blank\",\n                    features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)\n                });\n                // for inPageProvider methods sending windowId in request instead of params\n                // as params might be positional.\n                _payload.windowId = windowId;\n            }\n            inPageProvider._rpcEngine.handle(_payload, cb);\n        };\n        communicationProvider.tryWindowHandle = (payload, cb)=>{\n            const _payload = payload;\n            if (!Array.isArray(_payload) && COMMUNICATION_UNSAFE_METHODS.includes(_payload.method)) {\n                const windowId = getWindowId();\n                communicationProvider._handleWindow(windowId, {\n                    target: \"_blank\",\n                    features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW) // todo: are these features generic for all\n                });\n                // for communication methods sending window id in jrpc req params\n                _payload.params.windowId = windowId;\n            }\n            communicationProvider._rpcEngine.handle(_payload, cb);\n        };\n        // detect solana_requestAccounts and pipe to enable for now\n        const detectAccountRequestPrototypeModifier = (m)=>{\n            const originalMethod = inPageProvider[m];\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const self = this;\n            inPageProvider[m] = function providerFunc(request, cb) {\n                const { method, params = [] } = request;\n                if (method === \"solana_requestAccounts\") {\n                    if (!cb) return self.login({\n                        loginProvider: params[0]\n                    });\n                    self.login({\n                        loginProvider: params[0]\n                    })// eslint-disable-next-line promise/no-callback-in-promise\n                    .then((res)=>cb(null, res))// eslint-disable-next-line promise/no-callback-in-promise\n                    .catch((err)=>cb(err));\n                }\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                return originalMethod.apply(this, [\n                    request,\n                    cb\n                ]);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            };\n        };\n        // Detects call to solana_requestAccounts in request & sendAsync and passes to login\n        detectAccountRequestPrototypeModifier(\"request\");\n        detectAccountRequestPrototypeModifier(\"sendAsync\");\n        detectAccountRequestPrototypeModifier(\"send\");\n        const proxiedInPageProvider = new Proxy(inPageProvider, {\n            // straight up lie that we deleted the property so that it doesn't\n            // throw an error in strict mode\n            deleteProperty: ()=>true\n        });\n        const proxiedCommunicationProvider = new Proxy(communicationProvider, {\n            // straight up lie that we deleted the property so that it doesn't\n            // throw an error in strict mode\n            deleteProperty: ()=>true\n        });\n        this.provider = proxiedInPageProvider;\n        this.communicationProvider = proxiedCommunicationProvider;\n        await Promise.all([\n            inPageProvider._initializeState(),\n            communicationProvider._initializeState(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()(_babel_runtime_helpers_objectSpread2__WEBPACK_IMPORTED_MODULE_0___default()({}, providerParams), {}, {\n                dappStorageKey: this.dappStorageKey,\n                torusAlertContainer: this.torusAlertContainer,\n                torusIframe: this.torusIframe\n            }))\n        ]);\n        log.debug(\"Torus - injected provider\");\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9zb2xhbmEtZW1iZWQvZGlzdC9zb2xhbmFFbWJlZC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlFO0FBQ0c7QUFDeEI7QUFDaUk7QUFDekg7QUFDcUk7QUFDNUg7QUFDckM7QUFDUTtBQUNLO0FBRXJDLElBQUlxQixVQUFVO0FBRWQscURBQXFELEdBQ3JELFNBQVNDLFNBQVNDLE1BQU07SUFDdEIsT0FBT0EsV0FBVyxRQUFRLE9BQU9BLFdBQVcsWUFBWSxPQUFPQSxPQUFPQyxJQUFJLEtBQUs7QUFDakY7QUFDQSxTQUFTQyxpQkFBaUJGLE1BQU07SUFDOUIsT0FBT0QsU0FBU0MsV0FBV0EsT0FBT0csUUFBUSxLQUFLLFNBQVMsT0FBT0gsT0FBT0ksTUFBTSxLQUFLLGNBQWMsT0FBT0osT0FBT0ssY0FBYyxLQUFLO0FBQ2xJO0FBQ0EsU0FBU0MsaUJBQWlCTixNQUFNO0lBQzlCLE9BQU9ELFNBQVNDLFdBQVdBLE9BQU9PLFFBQVEsS0FBSyxTQUFTLE9BQU9QLE9BQU9RLEtBQUssS0FBSyxjQUFjLE9BQU9SLE9BQU9TLGNBQWMsS0FBSztBQUNqSTtBQUNBLFNBQVNDLGVBQWVWLE1BQU07SUFDNUIsT0FBT0UsaUJBQWlCRixXQUFXTSxpQkFBaUJOO0FBQ3REO0FBRUEsSUFBSVcsV0FBVztJQUNiQyxRQUFRO1FBQ05DLGNBQWMsSUFBTTtRQUNwQkMseUJBQXlCLElBQU07UUFDL0JDLGlCQUFpQkMsQ0FBQUEsU0FBVSxDQUFDLDZFQUE2RSxFQUFFQSxPQUFPLDhCQUE4QixDQUFDO1FBQ2pKQyxxQkFBcUIsSUFBTTtRQUMzQkMsZ0JBQWdCQyxDQUFBQSxvQkFBcUIsQ0FBQyxnREFBZ0QsRUFBRUEsa0JBQWtCLENBQUMsQ0FBQztRQUM1R0Msb0JBQW9CLElBQU0sQ0FBQyw4Q0FBOEMsQ0FBQztRQUMxRUMsc0JBQXNCLElBQU0sQ0FBQyx5Q0FBeUMsQ0FBQztRQUN2RUMsc0JB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LElBQUlxTSxLQUFLLENBQUM7SUFDWjtBQUNGO0FBRXFIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc29sLXBvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvQHRvcnVzbGFicy9zb2xhbmEtZW1iZWQvZGlzdC9zb2xhbmFFbWJlZC5lc20uanM/MDA4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFNwcmVhZDInO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVMb2dnZXJNaWRkbGV3YXJlLCBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUywgQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TLCBQUk9WSURFUl9KUlBDX01FVEhPRFMsIFBST1ZJREVSX05PVElGSUNBVElPTlMgfSBmcm9tICdAdG9ydXNsYWJzL2Jhc2UtY29udHJvbGxlcnMnO1xuaW1wb3J0IHsgc2V0QVBJS2V5IH0gZnJvbSAnQHRvcnVzbGFicy9odHRwLWhlbHBlcnMnO1xuaW1wb3J0IHsgU2FmZUV2ZW50RW1pdHRlciwgT2JqZWN0TXVsdGlwbGV4LCBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlLCBKUlBDRW5naW5lLCBjcmVhdGVJZFJlbWFwTWlkZGxld2FyZSwgZ2V0UnBjUHJvbWlzZUNhbGxiYWNrLCBCYXNlUG9zdE1lc3NhZ2VTdHJlYW0gfSBmcm9tICdAdG9ydXNsYWJzL29wZW5sb2dpbi1qcnBjJztcbmltcG9ydCB7IGV0aEVycm9ycywgRXRoZXJldW1ScGNFcnJvciB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcbmltcG9ydCBwdW1wIGZyb20gJ3B1bXAnO1xuaW1wb3J0IGxvZ2xldmVsIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBkZXF1YWwgZnJvbSAnZmFzdC1kZWVwLWVxdWFsJztcblxudmFyIHZlcnNpb24gPSBcIjIuMS4wXCI7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtICE9PSBudWxsICYmIHR5cGVvZiBzdHJlYW0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHN0cmVhbS5waXBlID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBpc1dyaXRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICByZXR1cm4gaXNTdHJlYW0oc3RyZWFtKSAmJiBzdHJlYW0ud3JpdGFibGUgIT09IGZhbHNlICYmIHR5cGVvZiBzdHJlYW0uX3dyaXRlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHN0cmVhbS5fd3JpdGFibGVTdGF0ZSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIGlzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gIHJldHVybiBpc1N0cmVhbShzdHJlYW0pICYmIHN0cmVhbS5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgdHlwZW9mIHN0cmVhbS5fcmVhZCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUgPT09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBpc0R1cGxleFN0cmVhbShzdHJlYW0pIHtcbiAgcmV0dXJuIGlzV3JpdGFibGVTdHJlYW0oc3RyZWFtKSAmJiBpc1JlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XG59XG5cbnZhciBtZXNzYWdlcyA9IHtcbiAgZXJyb3JzOiB7XG4gICAgZGlzY29ubmVjdGVkOiAoKSA9PiBcIlRvcnVzOiBMb3N0IGNvbm5lY3Rpb24gdG8gVG9ydXMuXCIsXG4gICAgcGVybWFuZW50bHlEaXNjb25uZWN0ZWQ6ICgpID0+IFwiVG9ydXM6IERpc2Nvbm5lY3RlZCBmcm9tIGlmcmFtZS4gUGFnZSByZWxvYWQgcmVxdWlyZWQuXCIsXG4gICAgdW5zdXBwb3J0ZWRTeW5jOiBtZXRob2QgPT4gYFRvcnVzOiBUaGUgVG9ydXMgRXRoZXJldW0gcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBzeW5jaHJvbm91cyBtZXRob2RzIGxpa2UgJHttZXRob2R9IHdpdGhvdXQgYSBjYWxsYmFjayBwYXJhbWV0ZXIuYCxcbiAgICBpbnZhbGlkRHVwbGV4U3RyZWFtOiAoKSA9PiBcIk11c3QgcHJvdmlkZSBhIE5vZGUuanMtc3R5bGUgZHVwbGV4IHN0cmVhbS5cIixcbiAgICBpbnZhbGlkT3B0aW9uczogbWF4RXZlbnRMaXN0ZW5lcnMgPT4gYEludmFsaWQgb3B0aW9ucy4gUmVjZWl2ZWQ6IHsgbWF4RXZlbnRMaXN0ZW5lcnM6ICR7bWF4RXZlbnRMaXN0ZW5lcnN9fWAsXG4gICAgaW52YWxpZFJlcXVlc3RBcmdzOiAoKSA9PiBgRXhwZWN0ZWQgYSBzaW5nbGUsIG5vbi1hcnJheSwgb2JqZWN0IGFyZ3VtZW50LmAsXG4gICAgaW52YWxpZFJlcXVlc3RNZXRob2Q6ICgpID0+IGAnYXJncy5tZXRob2QnIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLmAsXG4gICAgaW52YWxpZFJlcXVlc3RQYXJhbXM6ICgpID0+IGAnYXJncy5wYXJhbXMnIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFycmF5IGlmIHByb3ZpZGVkLmAsXG4gICAgaW52YWxpZExvZ2dlck9iamVjdDogKCkgPT4gYCdhcmdzLmxvZ2dlcicgbXVzdCBiZSBhbiBvYmplY3QgaWYgcHJvdmlkZWQuYCxcbiAgICBpbnZhbGlkTG9nZ2VyTWV0aG9kOiBtZXRob2QgPT4gYCdhcmdzLmxvZ2dlcicgbXVzdCBpbmNsdWRlIHJlcXVpcmVkIG1ldGhvZCAnJHttZXRob2R9Jy5gXG4gIH0sXG4gIGluZm86IHtcbiAgICBjb25uZWN0ZWQ6IGNoYWluSWQgPT4gYFRvcnVzOiBDb25uZWN0ZWQgdG8gY2hhaW4gd2l0aCBJRCBcIiR7Y2hhaW5JZH1cIi5gXG4gIH0sXG4gIHdhcm5pbmdzOiB7fVxufTtcblxuY29uc3QgUEFZTUVOVF9QUk9WSURFUiA9IHtcbiAgTU9PTlBBWTogXCJtb29ucGF5XCIsXG4gIFdZUkU6IFwid3lyZVwiLFxuICBSQU1QTkVUV09SSzogXCJyYW1wbmV0d29ya1wiLFxuICBYQU5QT09MOiBcInhhbnBvb2xcIixcbiAgTUVSQ1VSWU86IFwibWVyY3VyeW9cIixcbiAgVFJBTlNBSzogXCJ0cmFuc2FrXCJcbn07XG5jb25zdCBUT1JVU19CVUlMRF9FTlYgPSB7XG4gIFBST0RVQ1RJT046IFwicHJvZHVjdGlvblwiLFxuICBERVZFTE9QTUVOVDogXCJkZXZlbG9wbWVudFwiLFxuICBURVNUSU5HOiBcInRlc3RpbmdcIlxufTtcbmNvbnN0IEJVVFRPTl9QT1NJVElPTiA9IHtcbiAgQk9UVE9NX0xFRlQ6IFwiYm90dG9tLWxlZnRcIixcbiAgVE9QX0xFRlQ6IFwidG9wLWxlZnRcIixcbiAgQk9UVE9NX1JJR0hUOiBcImJvdHRvbS1yaWdodFwiLFxuICBUT1BfUklHSFQ6IFwidG9wLXJpZ2h0XCJcbn07XG5jb25zdCBMT0dJTl9QUk9WSURFUiA9IHtcbiAgR09PR0xFOiBcImdvb2dsZVwiLFxuICBGQUNFQk9PSzogXCJmYWNlYm9va1wiLFxuICBSRURESVQ6IFwicmVkZGl0XCIsXG4gIERJU0NPUkQ6IFwiZGlzY29yZFwiLFxuICBUV0lUQ0g6IFwidHdpdGNoXCIsXG4gIEFQUExFOiBcImFwcGxlXCIsXG4gIExJTkU6IFwibGluZVwiLFxuICBHSVRIVUI6IFwiZ2l0aHViXCIsXG4gIEtBS0FPOiBcImtha2FvXCIsXG4gIExJTktFRElOOiBcImxpbmtlZGluXCIsXG4gIFRXSVRURVI6IFwidHdpdHRlclwiLFxuICBXRUlCTzogXCJ3ZWlib1wiLFxuICBXRUNIQVQ6IFwid2VjaGF0XCIsXG4gIEVNQUlMX1BBU1NXT1JETEVTUzogXCJlbWFpbF9wYXNzd29yZGxlc3NcIlxufTtcblxuY29uc3QgdHJhbnNsYXRpb25zID0ge1xuICBlbjoge1xuICAgIGVtYmVkOiB7XG4gICAgICBjb250aW51ZTogXCJDb250aW51ZVwiLFxuICAgICAgYWN0aW9uUmVxdWlyZWQ6IFwiQXV0aG9yaXphdGlvbiByZXF1aXJlZFwiLFxuICAgICAgcGVuZGluZ0FjdGlvbjogXCJDbGljayBjb250aW51ZSB0byBwcm9jZWVkIHdpdGggeW91ciByZXF1ZXN0IGluIGEgcG9wdXBcIixcbiAgICAgIGNvb2tpZXNSZXF1aXJlZDogXCJDb29raWVzIFJlcXVpcmVkXCIsXG4gICAgICBlbmFibGVDb29raWVzOiBcIlBsZWFzZSBlbmFibGUgY29va2llcyBpbiB5b3VyIGJyb3dzZXIgcHJlZmVyZW5jZXMgdG8gYWNjZXNzIFRvcnVzXCIsXG4gICAgICBjbGlja0hlcmU6IFwiTW9yZSBJbmZvXCJcbiAgICB9XG4gIH0sXG4gIGRlOiB7XG4gICAgZW1iZWQ6IHtcbiAgICAgIGNvbnRpbnVlOiBcIkZvcnRzZXR6ZW5cIixcbiAgICAgIGFjdGlvblJlcXVpcmVkOiBcIkF1dG9yaXNpZXJ1bmcgZXJmb3JkZXJsaWNoXCIsXG4gICAgICBwZW5kaW5nQWN0aW9uOiBcIktsaWNrZW4gU2llIGluIGVpbmVtIFBvcHVwIGF1ZiBXZWl0ZXIsIHVtIG1pdCBJaHJlciBBbmZyYWdlIGZvcnR6dWZhaHJlblwiLFxuICAgICAgY29va2llc1JlcXVpcmVkOiBcIkNvb2tpZXMgYmVuw7Z0aWd0XCIsXG4gICAgICBlbmFibGVDb29raWVzOiBcIkJpdHRlIGFrdGl2aWVyZW4gU2llIENvb2tpZXMgaW4gSWhyZW4gQnJvd3NlcmVpbnN0ZWxsdW5nZW4sIHVtIGF1ZiBUb3J1cyB6dXp1Z3JlaWZlblwiLFxuICAgICAgY2xpY2tIZXJlOiBcIk1laHIgSW5mb1wiXG4gICAgfVxuICB9LFxuICBqYToge1xuICAgIGVtYmVkOiB7XG4gICAgICBjb250aW51ZTogXCLntpnntprjgZnjgotcIixcbiAgICAgIGFjdGlvblJlcXVpcmVkOiBcIuiqjeiovOOBjOW/heimgeOBp+OBmVwiLFxuICAgICAgcGVuZGluZ0FjdGlvbjogXCLntprooYzjgpLjgq/jg6rjg4Pjgq/jgZfjgabjgIHjg53jg4Pjg5fjgqLjg4Pjg5fjgafjg6rjgq/jgqjjgrnjg4jjgpLntprooYzjgZfjgb7jgZlcIixcbiAgICAgIGNvb2tpZXNSZXF1aXJlZDogXCLlv4XopoHjgarjgq/jg4Pjgq3jg7xcIixcbiAgICAgIGVuYWJsZUNvb2tpZXM6IFwiVG9ydXPjgavjgqLjgq/jgrvjgrnjgZnjgovjgavjga/jgIHjg5bjg6njgqbjgrbjga7oqK3lrprjgadDb29raWXjgpLmnInlirnjgavjgZfjgabjgY/jgaDjgZXjgYTjgIJcIixcbiAgICAgIGNsaWNrSGVyZTogXCLoqbPjgZfjgY/jga9cIlxuICAgIH1cbiAgfSxcbiAga286IHtcbiAgICBlbWJlZDoge1xuICAgICAgY29udGludWU6IFwi6rOE7IaN7ZWY64ukXCIsXG4gICAgICBhY3Rpb25SZXF1aXJlZDogXCLsirnsnbgg7ZWE7JqUXCIsXG4gICAgICBwZW5kaW5nQWN0aW9uOiBcIu2MneyXheyXkOyEnCDsmpTssq3snYQg7KeE7ZaJ7ZWY66Ck66m0IOqzhOyGjeydhCDtgbTrpq3tlZjsi63si5zsmKQuXCIsXG4gICAgICBjb29raWVzUmVxdWlyZWQ6IFwi7L+g7YKkIO2VhOyalFwiLFxuICAgICAgZW5hYmxlQ29va2llczogXCLruIzrnbzsmrDsoIAg7ZmY6rK9IOyEpOygleyXkOyEnCDsv6DtgqTrpbwg7Zmc7ISx7ZmU7ZWY7JesIFRvcnVz7JeQIOyVoeyEuOyKpO2VmOyLreyLnOyYpC5cIixcbiAgICAgIGNsaWNrSGVyZTogXCLrjZQg66eO7J2AIOygleuztFwiXG4gICAgfVxuICB9LFxuICB6aDoge1xuICAgIGVtYmVkOiB7XG4gICAgICBjb250aW51ZTogXCLnu6fnu61cIixcbiAgICAgIGFjdGlvblJlcXVpcmVkOiBcIumcgOimgeaOiOadg1wiLFxuICAgICAgcGVuZGluZ0FjdGlvbjogXCLljZXlh7vnu6fnu63ku6XlnKjlvLnlh7rnqpflj6PkuK3nu6fnu63mgqjnmoTor7fmsYJcIixcbiAgICAgIGNvb2tpZXNSZXF1aXJlZDogXCLlv4XloatDb29raWVcIixcbiAgICAgIGVuYWJsZUNvb2tpZXM6IFwi6K+35Zyo5oKo55qE5rWP6KeI5Zmo6aaW6YCJ6aG55Lit5ZCv55SoY29va2ll5Lul6K6/6ZeuVG9ydXPjgIJcIixcbiAgICAgIGNsaWNrSGVyZTogXCLmm7TlpJrkv6Hmga9cIlxuICAgIH1cbiAgfVxufTtcbnZhciBjb25maWd1cmF0aW9uID0ge1xuICBzdXBwb3J0ZWRWZXJpZmllckxpc3Q6IFtMT0dJTl9QUk9WSURFUi5HT09HTEUsIExPR0lOX1BST1ZJREVSLlJFRERJVCwgTE9HSU5fUFJPVklERVIuRElTQ09SRF0sXG4gIGFwaTogXCJodHRwczovL2FwaS50b3IudXNcIixcbiAgdHJhbnNsYXRpb25zLFxuICBwcm9kVG9ydXNVcmw6IFwiXCIsXG4gIGxvY2FsU3RvcmFnZUtleVByZWZpeDogYHRvcnVzLWBcbn07XG5cbnZhciBsb2cgPSBsb2dsZXZlbC5nZXRMb2dnZXIoXCJzb2xhbmEtZW1iZWRcIik7XG5cbi8vIHV0aWxpdHkgZnVuY3Rpb25zXG5cbi8qKlxuICoganNvbi1ycGMtZW5naW5lIG1pZGRsZXdhcmUgdGhhdCBsb2dzIFJQQyBlcnJvcnMgYW5kIGFuZCB2YWxpZGF0ZXMgcmVxLm1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gbG9nIC0gVGhlIGxvZ2dpbmcgQVBJIHRvIHVzZS5cbiAqIEByZXR1cm5zICBqc29uLXJwYy1lbmdpbmUgbWlkZGxld2FyZSBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBjcmVhdGVFcnJvck1pZGRsZXdhcmUoKSB7XG4gIHJldHVybiAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAvLyBqc29uLXJwYy1lbmdpbmUgd2lsbCB0ZXJtaW5hdGUgdGhlIHJlcXVlc3Qgd2hlbiBpdCBub3RpY2VzIHRoaXMgZXJyb3JcbiAgICBpZiAodHlwZW9mIHJlcS5tZXRob2QgIT09IFwic3RyaW5nXCIgfHwgIXJlcS5tZXRob2QpIHtcbiAgICAgIHJlcy5lcnJvciA9IGV0aEVycm9ycy5ycGMuaW52YWxpZFJlcXVlc3Qoe1xuICAgICAgICBtZXNzYWdlOiBgVGhlIHJlcXVlc3QgJ21ldGhvZCcgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuYCxcbiAgICAgICAgZGF0YTogcmVxXG4gICAgICB9KTtcbiAgICB9XG4gICAgbmV4dChkb25lID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXJyb3JcbiAgICAgIH0gPSByZXM7XG4gICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9XG4gICAgICBsb2cuZXJyb3IoYFRvcnVzIC0gUlBDIEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBMb2dzIGEgc3RyZWFtIGRpc2Nvbm5lY3Rpb24gZXJyb3IuIEVtaXRzIGFuICdlcnJvcicgaWYgZ2l2ZW4gYW5cbiAqIEV2ZW50RW1pdHRlciB0aGF0IGhhcyBsaXN0ZW5lcnMgZm9yIHRoZSAnZXJyb3InIGV2ZW50LlxuICpcbiAqIEBwYXJhbSBsb2cgLSBUaGUgbG9nZ2luZyBBUEkgdG8gdXNlLlxuICogQHBhcmFtIHJlbW90ZUxhYmVsIC0gVGhlIGxhYmVsIG9mIHRoZSBkaXNjb25uZWN0ZWQgc3RyZWFtLlxuICogQHBhcmFtIGVycm9yIC0gVGhlIGFzc29jaWF0ZWQgZXJyb3IgdG8gbG9nLlxuICogQHBhcmFtIGVtaXR0ZXIgLSBUaGUgbG9nZ2luZyBBUEkgdG8gdXNlLlxuICovXG5mdW5jdGlvbiBsb2dTdHJlYW1EaXNjb25uZWN0V2FybmluZyhyZW1vdGVMYWJlbCwgZXJyb3IsIGVtaXR0ZXIpIHtcbiAgbGV0IHdhcm5pbmdNc2cgPSBgVG9ydXM6IExvc3QgY29ubmVjdGlvbiB0byBcIiR7cmVtb3RlTGFiZWx9XCIuYDtcbiAgaWYgKGVycm9yPy5zdGFjaykge1xuICAgIHdhcm5pbmdNc2cgKz0gYFxcbiR7ZXJyb3Iuc3RhY2t9YDtcbiAgfVxuICBsb2cud2Fybih3YXJuaW5nTXNnKTtcbiAgaWYgKGVtaXR0ZXIgJiYgZW1pdHRlci5saXN0ZW5lckNvdW50KFwiZXJyb3JcIikgPiAwKSB7XG4gICAgZW1pdHRlci5lbWl0KFwiZXJyb3JcIiwgd2FybmluZ01zZyk7XG4gIH1cbn1cbmNvbnN0IGdldFdpbmRvd0lkID0gKCkgPT4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5jb25zdCBnZXRUb3J1c1VybCA9IGFzeW5jIGJ1aWxkRW52ID0+IHtcbiAgbGV0IHRvcnVzVXJsO1xuICBsZXQgbG9nTGV2ZWw7XG4gIC8vIGNvbnN0IHZlcnNpb25Vc2VkID0gdmVyc2lvbjtcbiAgLy8gbG9nLmluZm8oXCJzb2xhbmEgZW1iZWQgdmVyc2lvbiB1c2VkOiBcIiwgdmVyc2lvblVzZWQpO1xuICBzd2l0Y2ggKGJ1aWxkRW52KSB7XG4gICAgY2FzZSBcInRlc3RpbmdcIjpcbiAgICAgIHRvcnVzVXJsID0gXCJodHRwczovL3NvbGFuYS10ZXN0aW5nLnRvci51c1wiO1xuICAgICAgbG9nTGV2ZWwgPSBcImRlYnVnXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZGV2ZWxvcG1lbnRcIjpcbiAgICAgIHRvcnVzVXJsID0gXCJodHRwOi8vbG9jYWxob3N0OjgwODBcIjtcbiAgICAgIGxvZ0xldmVsID0gXCJkZWJ1Z1wiO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRvcnVzVXJsID0gYGh0dHBzOi8vc29sYW5hLnRvci51c2A7XG4gICAgICBsb2dMZXZlbCA9IFwiZXJyb3JcIjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9ydXNVcmwsXG4gICAgbG9nTGV2ZWxcbiAgfTtcbn07XG5jb25zdCBnZXRVc2VyTGFuZ3VhZ2UgPSAoKSA9PiB7XG4gIGxldCB1c2VyTGFuZ3VhZ2UgPSB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlIHx8IFwiZW4tVVNcIjtcbiAgY29uc3QgdXNlckxhbmd1YWdlcyA9IHVzZXJMYW5ndWFnZS5zcGxpdChcIi1cIik7XG4gIHVzZXJMYW5ndWFnZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maWd1cmF0aW9uLnRyYW5zbGF0aW9ucywgdXNlckxhbmd1YWdlc1swXSkgPyB1c2VyTGFuZ3VhZ2VzWzBdIDogXCJlblwiO1xuICByZXR1cm4gdXNlckxhbmd1YWdlO1xufTtcbmNvbnN0IEZFQVRVUkVTX1BST1ZJREVSX0NIQU5HRV9XSU5ET1cgPSB7XG4gIGhlaWdodDogNjYwLFxuICB3aWR0aDogMzc1XG59O1xuY29uc3QgRkVBVFVSRVNfREVGQVVMVF9XQUxMRVRfV0lORE9XID0ge1xuICBoZWlnaHQ6IDc0MCxcbiAgd2lkdGg6IDEzMTVcbn07XG5jb25zdCBGRUFUVVJFU19ERUZBVUxUX1BPUFVQX1dJTkRPVyA9IHtcbiAgaGVpZ2h0OiA3MDAsXG4gIHdpZHRoOiAxMjAwXG59O1xuY29uc3QgRkVBVFVSRVNfQ09ORklSTV9XSU5ET1cgPSB7XG4gIGhlaWdodDogNjAwLFxuICB3aWR0aDogNDAwXG59O1xuZnVuY3Rpb24gc3RvcmFnZUF2YWlsYWJsZSh0eXBlKSB7XG4gIGxldCBzdG9yYWdlO1xuICB0cnkge1xuICAgIHN0b3JhZ2UgPSB3aW5kb3dbdHlwZV07XG4gICAgY29uc3QgeCA9IFwiX19zdG9yYWdlX3Rlc3RfX1wiO1xuICAgIHN0b3JhZ2Uuc2V0SXRlbSh4LCB4KTtcbiAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oeCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZSA9IGVycm9yO1xuICAgIHJldHVybiBlICYmIChcbiAgICAvLyBldmVyeXRoaW5nIGV4Y2VwdCBGaXJlZm94XG4gICAgZS5jb2RlID09PSAyMiB8fFxuICAgIC8vIEZpcmVmb3hcbiAgICBlLmNvZGUgPT09IDEwMTQgfHxcbiAgICAvLyB0ZXN0IG5hbWUgZmllbGQgdG9vLCBiZWNhdXNlIGNvZGUgbWlnaHQgbm90IGJlIHByZXNlbnRcbiAgICAvLyBldmVyeXRoaW5nIGV4Y2VwdCBGaXJlZm94XG4gICAgZS5uYW1lID09PSBcIlF1b3RhRXhjZWVkZWRFcnJvclwiIHx8XG4gICAgLy8gRmlyZWZveFxuICAgIGUubmFtZSA9PT0gXCJOU19FUlJPUl9ET01fUVVPVEFfUkVBQ0hFRFwiKSAmJlxuICAgIC8vIGFja25vd2xlZGdlIFF1b3RhRXhjZWVkZWRFcnJvciBvbmx5IGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGFscmVhZHkgc3RvcmVkXG4gICAgc3RvcmFnZSAmJiBzdG9yYWdlLmxlbmd0aCAhPT0gMDtcbiAgfVxufVxuXG4vKipcbiAqIHBvcHVwIGhhbmRsZXIgdXRpbHNcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wdXBGZWF0dXJlcyhfcmVmKSB7XG4gIGxldCB7XG4gICAgd2lkdGg6IHcsXG4gICAgaGVpZ2h0OiBoXG4gIH0gPSBfcmVmO1xuICAvLyBGaXhlcyBkdWFsLXNjcmVlbiBwb3NpdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9zdCBicm93c2VycyAgICAgIEZpcmVmb3hcbiAgY29uc3QgZHVhbFNjcmVlbkxlZnQgPSB3aW5kb3cuc2NyZWVuTGVmdCAhPT0gdW5kZWZpbmVkID8gd2luZG93LnNjcmVlbkxlZnQgOiB3aW5kb3cuc2NyZWVuWDtcbiAgY29uc3QgZHVhbFNjcmVlblRvcCA9IHdpbmRvdy5zY3JlZW5Ub3AgIT09IHVuZGVmaW5lZCA/IHdpbmRvdy5zY3JlZW5Ub3AgOiB3aW5kb3cuc2NyZWVuWTtcbiAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCA/IHdpbmRvdy5pbm5lcldpZHRoIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIDogd2luZG93LnNjcmVlbi53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ID8gd2luZG93LmlubmVySGVpZ2h0IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgOiB3aW5kb3cuc2NyZWVuLmhlaWdodDtcbiAgY29uc3Qgc3lzdGVtWm9vbSA9IDE7IC8vIE5vIHJlbGlhYmxlIGVzdGltYXRlXG5cbiAgY29uc3QgbGVmdCA9IE1hdGguYWJzKCh3aWR0aCAtIHcpIC8gMiAvIHN5c3RlbVpvb20gKyBkdWFsU2NyZWVuTGVmdCk7XG4gIGNvbnN0IHRvcCA9IE1hdGguYWJzKChoZWlnaHQgLSBoKSAvIDIgLyBzeXN0ZW1ab29tICsgZHVhbFNjcmVlblRvcCk7XG4gIGNvbnN0IGZlYXR1cmVzID0gYHRpdGxlYmFyPTAsdG9vbGJhcj0wLHN0YXR1cz0wLGxvY2F0aW9uPTAsbWVudWJhcj0wLGhlaWdodD0ke2ggLyBzeXN0ZW1ab29tfSx3aWR0aD0ke3cgLyBzeXN0ZW1ab29tfSx0b3A9JHt0b3B9LGxlZnQ9JHtsZWZ0fWA7XG4gIHJldHVybiBmZWF0dXJlcztcbn1cblxuY2xhc3MgQmFzZVByb3ZpZGVyIGV4dGVuZHMgU2FmZUV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25TdHJlYW0sIF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgbWF4RXZlbnRMaXN0ZW5lcnMgPSAxMDAsXG4gICAgICBqc29uUnBjU3RyZWFtTmFtZSA9IFwicHJvdmlkZXJcIlxuICAgIH0gPSBfcmVmO1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGluZyB0aGF0IHRoaXMgcHJvdmlkZXIgaXMgYSBUb3J1cyBwcm92aWRlci5cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc1RvcnVzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JwY0VuZ2luZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImpzb25ScGNDb25uZWN0aW9uRXZlbnRzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3N0YXRlXCIsIHZvaWQgMCk7XG4gICAgaWYgKCFpc0R1cGxleFN0cmVhbShjb25uZWN0aW9uU3RyZWFtKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLmVycm9ycy5pbnZhbGlkRHVwbGV4U3RyZWFtKCkpO1xuICAgIH1cbiAgICB0aGlzLmlzVG9ydXMgPSB0cnVlO1xuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKG1heEV2ZW50TGlzdGVuZXJzKTtcbiAgICB0aGlzLl9oYW5kbGVDb25uZWN0ID0gdGhpcy5faGFuZGxlQ29ubmVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2hhbmRsZURpc2Nvbm5lY3QgPSB0aGlzLl9oYW5kbGVEaXNjb25uZWN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlU3RyZWFtRGlzY29ubmVjdCA9IHRoaXMuX2hhbmRsZVN0cmVhbURpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ycGNSZXF1ZXN0ID0gdGhpcy5fcnBjUmVxdWVzdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2luaXRpYWxpemVTdGF0ZSA9IHRoaXMuX2luaXRpYWxpemVTdGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVxdWVzdCA9IHRoaXMucmVxdWVzdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2VuZEFzeW5jID0gdGhpcy5zZW5kQXN5bmMuYmluZCh0aGlzKTtcbiAgICAvLyB0aGlzLmVuYWJsZSA9IHRoaXMuZW5hYmxlLmJpbmQodGhpcyk7XG5cbiAgICAvLyBzZXR1cCBjb25uZWN0aW9uU3RyZWFtIG11bHRpcGxleGluZ1xuICAgIGNvbnN0IG11eCA9IG5ldyBPYmplY3RNdWx0aXBsZXgoKTtcbiAgICBwdW1wKGNvbm5lY3Rpb25TdHJlYW0sIG11eCwgY29ubmVjdGlvblN0cmVhbSwgdGhpcy5faGFuZGxlU3RyZWFtRGlzY29ubmVjdC5iaW5kKHRoaXMsIFwiVG9ydXNcIikpO1xuXG4gICAgLy8gaWdub3JlIHBoaXNoaW5nIHdhcm5pbmcgbWVzc2FnZSAoaGFuZGxlZCBlbHNld2hlcmUpXG4gICAgbXV4Lmlnbm9yZVN0cmVhbShcInBoaXNoaW5nXCIpO1xuXG4gICAgLy8gc2V0dXAgb3duIGV2ZW50IGxpc3RlbmVyc1xuICAgIC8vIGNvbm5lY3QgdG8gYXN5bmMgcHJvdmlkZXJcblxuICAgIGNvbnN0IGpzb25ScGNDb25uZWN0aW9uID0gY3JlYXRlU3RyZWFtTWlkZGxld2FyZSgpO1xuICAgIHB1bXAoanNvblJwY0Nvbm5lY3Rpb24uc3RyZWFtLCBtdXguY3JlYXRlU3RyZWFtKGpzb25ScGNTdHJlYW1OYW1lKSwganNvblJwY0Nvbm5lY3Rpb24uc3RyZWFtLCB0aGlzLl9oYW5kbGVTdHJlYW1EaXNjb25uZWN0LmJpbmQodGhpcywgXCJUb3J1cyBScGNQcm92aWRlclwiKSk7XG5cbiAgICAvLyBoYW5kbGUgUlBDIHJlcXVlc3RzIHZpYSBkYXBwLXNpZGUgcnBjIGVuZ2luZVxuICAgIGNvbnN0IHJwY0VuZ2luZSA9IG5ldyBKUlBDRW5naW5lKCk7XG4gICAgcnBjRW5naW5lLnB1c2goY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUoKSk7XG4gICAgcnBjRW5naW5lLnB1c2goY3JlYXRlRXJyb3JNaWRkbGV3YXJlKCkpO1xuICAgIHJwY0VuZ2luZS5wdXNoKGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUoe1xuICAgICAgb3JpZ2luOiBsb2NhdGlvbi5vcmlnaW5cbiAgICB9KSk7XG4gICAgcnBjRW5naW5lLnB1c2goanNvblJwY0Nvbm5lY3Rpb24ubWlkZGxld2FyZSk7XG4gICAgdGhpcy5fcnBjRW5naW5lID0gcnBjRW5naW5lO1xuICAgIHRoaXMuanNvblJwY0Nvbm5lY3Rpb25FdmVudHMgPSBqc29uUnBjQ29ubmVjdGlvbi5ldmVudHM7XG4gIH1cblxuICAvKipcbiAgICogU3VibWl0cyBhbiBSUEMgcmVxdWVzdCBmb3IgdGhlIGdpdmVuIG1ldGhvZCwgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1zLlxuICAgKiBSZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIG1ldGhvZCBjYWxsLCBvciByZWplY3RzIG9uIGVycm9yLlxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdChhcmdzKSB7XG4gICAgaWYgKCFhcmdzIHx8IHR5cGVvZiBhcmdzICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkoYXJncykpIHtcbiAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFJlcXVlc3Qoe1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlcy5lcnJvcnMuaW52YWxpZFJlcXVlc3RBcmdzKCksXG4gICAgICAgIGRhdGE6IGFyZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtZXRob2QsXG4gICAgICBwYXJhbXNcbiAgICB9ID0gYXJncztcbiAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJzdHJpbmdcIiB8fCBtZXRob2QubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRSZXF1ZXN0KHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZXMuZXJyb3JzLmludmFsaWRSZXF1ZXN0TWV0aG9kKCksXG4gICAgICAgIGRhdGE6IGFyZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zKSAmJiAodHlwZW9mIHBhcmFtcyAhPT0gXCJvYmplY3RcIiB8fCBwYXJhbXMgPT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBldGhFcnJvcnMucnBjLmludmFsaWRSZXF1ZXN0KHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZXMuZXJyb3JzLmludmFsaWRSZXF1ZXN0UGFyYW1zKCksXG4gICAgICAgIGRhdGE6IGFyZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fcnBjUmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcGFyYW1zXG4gICAgICB9LCBnZXRScGNQcm9taXNlQ2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFN1Ym1pdHMgYW4gUlBDIHJlcXVlc3QgcGVyIHRoZSBnaXZlbiBKU09OLVJQQyByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHNlbmQocGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9ycGNSZXF1ZXN0KHBheWxvYWQsIGNhbGxiYWNrKTtcbiAgfVxuICAvKipcbiAgICogU3VibWl0cyBhbiBSUEMgcmVxdWVzdCBwZXIgdGhlIGdpdmVuIEpTT04tUlBDIHJlcXVlc3Qgb2JqZWN0LlxuICAgKi9cbiAgc2VuZEFzeW5jKHBheWxvYWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fcnBjUmVxdWVzdChwYXlsb2FkLCBnZXRScGNQcm9taXNlQ2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBsb3N0IHRvIGNyaXRpY2FsIHN0cmVhbXMuXG4gICAqXG4gICAqIGVtaXRzIFRvcnVzSW5wYWdlUHJvdmlkZXIjZGlzY29ubmVjdFxuICAgKi9cbiAgX2hhbmRsZVN0cmVhbURpc2Nvbm5lY3Qoc3RyZWFtTmFtZSwgZXJyb3IpIHtcbiAgICBsb2dTdHJlYW1EaXNjb25uZWN0V2FybmluZyhzdHJlYW1OYW1lLCBlcnJvciwgdGhpcyk7XG4gICAgdGhpcy5faGFuZGxlRGlzY29ubmVjdChmYWxzZSwgZXJyb3IgPyBlcnJvci5tZXNzYWdlIDogdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8vIFByaXZhdGUgTWV0aG9kc1xuICAvLz0gPT09PT09PT09PT09PT09PT09PVxuICAvKipcbiAgICogQ29uc3RydWN0b3IgaGVscGVyLlxuICAgKiBQb3B1bGF0ZXMgaW5pdGlhbCBzdGF0ZSBieSBjYWxsaW5nICd3YWxsZXRfZ2V0UHJvdmlkZXJTdGF0ZScgYW5kIGVtaXRzXG4gICAqIG5lY2Vzc2FyeSBldmVudHMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBSUEMgbWV0aG9kLiBGb3J3YXJkcyByZXF1ZXN0cyB0byBiYWNrZ3JvdW5kIHZpYSB0aGUgUlBDIGVuZ2luZS5cbiAgICogQWxzbyByZW1hcCBpZHMgaW5ib3VuZCBhbmQgb3V0Ym91bmRcbiAgICovXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHByb3ZpZGVyIGJlY29tZXMgY29ubmVjdGVkLCB1cGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCBlbWl0c1xuICAgKiByZXF1aXJlZCBldmVudHMuIElkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBjaGFpbklkIC0gVGhlIElEIG9mIHRoZSBuZXdseSBjb25uZWN0ZWQgY2hhaW4uXG4gICAqIGVtaXRzIFRvcnVzSW5QYWdlUHJvdmlkZXIjY29ubmVjdFxuICAgKi9cblxuICAvKipcbiAgICogV2hlbiB0aGUgcHJvdmlkZXIgYmVjb21lcyBkaXNjb25uZWN0ZWQsIHVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIGVtaXRzXG4gICAqIHJlcXVpcmVkIGV2ZW50cy4gSWRlbXBvdGVudCB3aXRoIHJlc3BlY3QgdG8gdGhlIGlzUmVjb3ZlcmFibGUgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBFcnJvciBjb2RlcyBwZXIgdGhlIENsb3NlRXZlbnQgc3RhdHVzIGNvZGVzIGFzIHJlcXVpcmVkIGJ5IEVJUC0xMTkzOlxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudCNTdGF0dXNfY29kZXNcbiAgICpcbiAgICogQHBhcmFtIGlzUmVjb3ZlcmFibGUgLSBXaGV0aGVyIHRoZSBkaXNjb25uZWN0aW9uIGlzIHJlY292ZXJhYmxlLlxuICAgKiBAcGFyYW0gZXJyb3JNZXNzYWdlIC0gQSBjdXN0b20gZXJyb3IgbWVzc2FnZS5cbiAgICogZW1pdHMgVG9ydXNJbnBhZ2VQcm92aWRlciNkaXNjb25uZWN0XG4gICAqL1xufVxuXG5jb25zdCBodG1sVG9FbGVtZW50ID0gaHRtbCA9PiB7XG4gIGNvbnN0IHRlbXBsYXRlID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgY29uc3QgdHJpbW1lZEh0bWwgPSBodG1sLnRyaW0oKTsgLy8gTmV2ZXIgcmV0dXJuIGEgdGV4dCBub2RlIG9mIHdoaXRlc3BhY2UgYXMgdGhlIHJlc3VsdFxuICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0cmltbWVkSHRtbDtcbiAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RDaGlsZDtcbn07XG5mdW5jdGlvbiBpc0xlZ2FjeVRyYW5zYWN0aW9uSW5zdGFuY2UodHJhbnNhY3Rpb24pIHtcbiAgcmV0dXJuIHRyYW5zYWN0aW9uLnZlcnNpb24gPT09IHVuZGVmaW5lZDtcbn1cblxuY2xhc3MgUG9wdXBIYW5kbGVyIGV4dGVuZHMgU2FmZUV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgdXJsLFxuICAgICAgdGFyZ2V0LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICB0aW1lb3V0ID0gMzAwMDBcbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcigpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVybFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhcmdldFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZlYXR1cmVzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2luZG93XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2luZG93VGltZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpQ2xvc2VkV2luZG93XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidGltZW91dFwiLCB2b2lkIDApO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0IHx8IFwiX2JsYW5rXCI7XG4gICAgdGhpcy5mZWF0dXJlcyA9IGZlYXR1cmVzIHx8IGdldFBvcHVwRmVhdHVyZXMoRkVBVFVSRVNfREVGQVVMVF9QT1BVUF9XSU5ET1cpO1xuICAgIHRoaXMud2luZG93ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2luZG93VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pQ2xvc2VkV2luZG93ID0gZmFsc2U7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICB0aGlzLl9zZXR1cFRpbWVyKCk7XG4gIH1cbiAgX3NldHVwVGltZXIoKSB7XG4gICAgdGhpcy53aW5kb3dUaW1lciA9IE51bWJlcihzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy53aW5kb3cgJiYgdGhpcy53aW5kb3cuY2xvc2VkKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy53aW5kb3dUaW1lcik7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghdGhpcy5pQ2xvc2VkV2luZG93KSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pQ2xvc2VkV2luZG93ID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy53aW5kb3cgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0sIHRoaXMudGltZW91dCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy53aW5kb3cgPT09IHVuZGVmaW5lZCkgY2xlYXJJbnRlcnZhbCh0aGlzLndpbmRvd1RpbWVyKTtcbiAgICB9LCA1MDApKTtcbiAgfVxuICBvcGVuKCkge1xuICAgIHRoaXMud2luZG93ID0gd2luZG93Lm9wZW4odGhpcy51cmwuaHJlZiwgdGhpcy50YXJnZXQsIHRoaXMuZmVhdHVyZXMpO1xuICAgIGlmICh0aGlzLndpbmRvdz8uZm9jdXMpIHRoaXMud2luZG93LmZvY3VzKCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHRoaXMuaUNsb3NlZFdpbmRvdyA9IHRydWU7XG4gICAgaWYgKHRoaXMud2luZG93KSB0aGlzLndpbmRvdy5jbG9zZSgpO1xuICB9XG4gIHJlZGlyZWN0KGxvY2F0aW9uUmVwbGFjZU9uUmVkaXJlY3QpIHtcbiAgICBpZiAobG9jYXRpb25SZXBsYWNlT25SZWRpcmVjdCkge1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UodGhpcy51cmwuaHJlZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdGhpcy51cmwuaHJlZjtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgVG9ydXNDb21tdW5pY2F0aW9uUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUHJvdmlkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uU3RyZWFtLCBfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIG1heEV2ZW50TGlzdGVuZXJzID0gMTAwLFxuICAgICAganNvblJwY1N0cmVhbU5hbWUgPSBcInByb3ZpZGVyXCJcbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcihjb25uZWN0aW9uU3RyZWFtLCB7XG4gICAgICBtYXhFdmVudExpc3RlbmVycyxcbiAgICAgIGpzb25ScGNTdHJlYW1OYW1lXG4gICAgfSk7XG5cbiAgICAvLyBwcml2YXRlIHN0YXRlXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZW1iZWRUcmFuc2xhdGlvbnNcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3J1c1VybFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhcHBTdG9yYWdlS2V5XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2luZG93UmVmc1wiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyeVdpbmRvd0hhbmRsZVwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcnVzQWxlcnRDb250YWluZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3J1c0lmcmFtZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuX3N0YXRlID0gX29iamVjdFNwcmVhZCh7fSwgVG9ydXNDb21tdW5pY2F0aW9uUHJvdmlkZXIuX2RlZmF1bHRTdGF0ZSk7XG5cbiAgICAvLyBwdWJsaWMgc3RhdGVcbiAgICB0aGlzLnRvcnVzVXJsID0gXCJcIjtcbiAgICB0aGlzLmRhcHBTdG9yYWdlS2V5ID0gXCJcIjtcbiAgICBjb25zdCBsYW5ndWFnZVRyYW5zbGF0aW9ucyA9IGNvbmZpZ3VyYXRpb24udHJhbnNsYXRpb25zW2dldFVzZXJMYW5ndWFnZSgpXTtcbiAgICB0aGlzLmVtYmVkVHJhbnNsYXRpb25zID0gbGFuZ3VhZ2VUcmFuc2xhdGlvbnMuZW1iZWQ7XG4gICAgdGhpcy53aW5kb3dSZWZzID0ge307XG5cbiAgICAvLyBzZXR1cCBvd24gZXZlbnQgbGlzdGVuZXJzXG5cbiAgICAvLyBFSVAtMTE5MyBjb25uZWN0XG4gICAgdGhpcy5vbihcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbkhhbmRsZXIgPSBwYXlsb2FkID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH0gPSBwYXlsb2FkO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TLklGUkFNRV9TVEFUVVMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlzRnVsbFNjcmVlbixcbiAgICAgICAgICByaWRcbiAgICAgICAgfSA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5fZGlzcGxheUlmcmFtZSh7XG4gICAgICAgICAgaXNGdWxsOiBpc0Z1bGxTY3JlZW4sXG4gICAgICAgICAgcmlkOiByaWRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIG1ldGhvZCB3aGVuIHdhbGxldCBhZGRzIHZlcnNpb25pbmcgYW5kIHN0b3BzIHN1cHBvcnRpbmcgdGhpcyBtZXRob2RcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcImNyZWF0ZV93aW5kb3dcIikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2luZG93SWQsXG4gICAgICAgICAgdXJsXG4gICAgICAgIH0gPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwQmxvY2tBbGVydCh3aW5kb3dJZCwgdXJsKTtcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMuQ0xPU0VfV0lORE9XKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUNsb3NlV2luZG93KHBhcmFtcyk7XG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TLlVTRVJfTE9HR0VEX0lOKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjdXJyZW50TG9naW5Qcm92aWRlclxuICAgICAgICB9ID0gcGFyYW1zO1xuICAgICAgICB0aGlzLl9zdGF0ZS5pc0xvZ2dlZEluID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc3RhdGUuY3VycmVudExvZ2luUHJvdmlkZXIgPSBjdXJyZW50TG9naW5Qcm92aWRlcjtcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBDT01NVU5JQ0FUSU9OX05PVElGSUNBVElPTlMuVVNFUl9MT0dHRURfT1VUKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlLmlzTG9nZ2VkSW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdGUuY3VycmVudExvZ2luUHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9kaXNwbGF5SWZyYW1lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmpzb25ScGNDb25uZWN0aW9uRXZlbnRzLm9uKFwibm90aWZpY2F0aW9uXCIsIG5vdGlmaWNhdGlvbkhhbmRsZXIpO1xuICB9XG4gIGdldCBpc0xvZ2dlZEluKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5pc0xvZ2dlZEluO1xuICB9XG4gIGdldCBpc0lGcmFtZUZ1bGxTY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmlzSUZyYW1lRnVsbFNjcmVlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGluUGFnZSBwcm92aWRlciBpcyBjb25uZWN0ZWQgdG8gVG9ydXMuXG4gICAqL1xuICBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQ7XG4gIH1cbiAgYXN5bmMgX2luaXRpYWxpemVTdGF0ZShwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0b3J1c1VybCxcbiAgICAgICAgZGFwcFN0b3JhZ2VLZXksXG4gICAgICAgIHRvcnVzQWxlcnRDb250YWluZXIsXG4gICAgICAgIHRvcnVzSWZyYW1lXG4gICAgICB9ID0gcGFyYW1zO1xuICAgICAgdGhpcy50b3J1c1VybCA9IHRvcnVzVXJsO1xuICAgICAgdGhpcy5kYXBwU3RvcmFnZUtleSA9IGRhcHBTdG9yYWdlS2V5O1xuICAgICAgdGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyID0gdG9ydXNBbGVydENvbnRhaW5lcjtcbiAgICAgIHRoaXMudG9ydXNJZnJhbWUgPSB0b3J1c0lmcmFtZTtcbiAgICAgIHRoaXMudG9ydXNJZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgICAvLyBvbmx5IGRvIHRoaXMgaWYgaWZyYW1lIGlzIG5vdCBmdWxsIHNjcmVlblxuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlLmlzSUZyYW1lRnVsbFNjcmVlbikgdGhpcy5fZGlzcGxheUlmcmFtZSgpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGN1cnJlbnRMb2dpblByb3ZpZGVyLFxuICAgICAgICBpc0xvZ2dlZEluXG4gICAgICB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5HRVRfUFJPVklERVJfU1RBVEUsXG4gICAgICAgIHBhcmFtczogW11cbiAgICAgIH0pO1xuXG4gICAgICAvLyBpbmRpY2F0ZSB0aGF0IHdlJ3ZlIGNvbm5lY3RlZCwgZm9yIEVJUC0xMTkzIGNvbXBsaWFuY2VcbiAgICAgIHRoaXMuX2hhbmRsZUNvbm5lY3QoY3VycmVudExvZ2luUHJvdmlkZXIsIGlzTG9nZ2VkSW4pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJUb3J1czogRmFpbGVkIHRvIGdldCBpbml0aWFsIHN0YXRlLiBQbGVhc2UgcmVwb3J0IHRoaXMgYnVnLlwiLCBlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGxvZy5pbmZvKFwiaW5pdGlhbGl6ZWQgY29tbXVuaWNhdGlvbiBzdGF0ZVwiKTtcbiAgICAgIHRoaXMuX3N0YXRlLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChcIl9pbml0aWFsaXplZFwiKTtcbiAgICB9XG4gIH1cbiAgX2hhbmRsZVdpbmRvdyh3aW5kb3dJZCkge1xuICAgIGxldCB7XG4gICAgICB1cmwsXG4gICAgICB0YXJnZXQsXG4gICAgICBmZWF0dXJlc1xuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTCh1cmwgfHwgYCR7dGhpcy50b3J1c1VybH0vcmVkaXJlY3Q/d2luZG93SWQ9JHt3aW5kb3dJZH1gKTtcbiAgICBpZiAodGhpcy5kYXBwU3RvcmFnZUtleSkge1xuICAgICAgLy8gSWYgbXVsdGlwbGUgaW5zdGFuY2VzLCBpdCByZXR1cm5zIHRoZSBmaXJzdCBvbmVcbiAgICAgIGlmIChmaW5hbFVybC5oYXNoKSBmaW5hbFVybC5oYXNoICs9IGAmZGFwcFN0b3JhZ2VLZXk9JHt0aGlzLmRhcHBTdG9yYWdlS2V5fWA7ZWxzZSBmaW5hbFVybC5oYXNoID0gYCNkYXBwU3RvcmFnZUtleT0ke3RoaXMuZGFwcFN0b3JhZ2VLZXl9YDtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlZFdpbmRvdyA9IG5ldyBQb3B1cEhhbmRsZXIoe1xuICAgICAgdXJsOiBmaW5hbFVybCxcbiAgICAgIHRhcmdldCxcbiAgICAgIGZlYXR1cmVzXG4gICAgfSk7XG4gICAgaGFuZGxlZFdpbmRvdy5vcGVuKCk7XG4gICAgaWYgKCFoYW5kbGVkV2luZG93LndpbmRvdykge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXBCbG9ja0FsZXJ0KHdpbmRvd0lkLCBmaW5hbFVybC5ocmVmKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQWRkIHRvIGNvbGxlY3Rpb24gb25seSBpZiB3aW5kb3cgaXMgb3BlbmVkXG4gICAgdGhpcy53aW5kb3dSZWZzW3dpbmRvd0lkXSA9IGhhbmRsZWRXaW5kb3c7XG4gICAgLy8gV2UgdGVsbCB0aGUgaWZyYW1lIHRoYXQgdGhlIHdpbmRvdyBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgb3BlbmVkXG4gICAgdGhpcy5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJvcGVuZWRfd2luZG93XCIsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgd2luZG93SWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICBoYW5kbGVkV2luZG93Lm9uY2UoXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAvLyB1c2VyIGNsb3NlZCB0aGUgd2luZG93XG4gICAgICBkZWxldGUgdGhpcy53aW5kb3dSZWZzW3dpbmRvd0lkXTtcbiAgICAgIHRoaXMucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuQ0xPU0VEX1dJTkRPVyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgd2luZG93SWRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2Rpc3BsYXlJZnJhbWUoKSB7XG4gICAgbGV0IHtcbiAgICAgIGlzRnVsbCA9IGZhbHNlLFxuICAgICAgcmlkID0gXCJcIlxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNvbnN0IHN0eWxlID0ge307XG4gICAgLy8gc2V0IHBoYXNlXG4gICAgaWYgKCFpc0Z1bGwpIHtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSB0aGlzLl9zdGF0ZS50b3J1c1dpZGdldFZpc2liaWxpdHkgPyBcImJsb2NrXCIgOiBcIm5vbmVcIjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IFwiNzBweFwiO1xuICAgICAgc3R5bGUud2lkdGggPSBcIjcwcHhcIjtcbiAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUuYnV0dG9uUG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBCVVRUT05fUE9TSVRJT04uVE9QX0xFRlQ6XG4gICAgICAgICAgc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgICBzdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICAgICAgICBzdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgIHN0eWxlLmJvdHRvbSA9IFwiYXV0b1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJVVFRPTl9QT1NJVElPTi5UT1BfUklHSFQ6XG4gICAgICAgICAgc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgICBzdHlsZS5yaWdodCA9IFwiMHB4XCI7XG4gICAgICAgICAgc3R5bGUubGVmdCA9IFwiYXV0b1wiO1xuICAgICAgICAgIHN0eWxlLmJvdHRvbSA9IFwiYXV0b1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJVVFRPTl9QT1NJVElPTi5CT1RUT01fUklHSFQ6XG4gICAgICAgICAgc3R5bGUuYm90dG9tID0gXCIwcHhcIjtcbiAgICAgICAgICBzdHlsZS5yaWdodCA9IFwiMHB4XCI7XG4gICAgICAgICAgc3R5bGUudG9wID0gXCJhdXRvXCI7XG4gICAgICAgICAgc3R5bGUubGVmdCA9IFwiYXV0b1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJVVFRPTl9QT1NJVElPTi5CT1RUT01fTEVGVDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzdHlsZS5ib3R0b20gPSBcIjBweFwiO1xuICAgICAgICAgIHN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgICAgICAgIHN0eWxlLnRvcCA9IFwiYXV0b1wiO1xuICAgICAgICAgIHN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBzdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgICBzdHlsZS50b3AgPSBcIjBweFwiO1xuICAgICAgc3R5bGUucmlnaHQgPSBcIjBweFwiO1xuICAgICAgc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICBzdHlsZS5ib3R0b20gPSBcIjBweFwiO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHRoaXMudG9ydXNJZnJhbWUuc3R5bGUsIHN0eWxlKTtcbiAgICB0aGlzLl9zdGF0ZS5pc0lGcmFtZUZ1bGxTY3JlZW4gPSBpc0Z1bGw7XG4gICAgdGhpcy5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuSUZSQU1FX1NUQVRVUyxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBpc0lGcmFtZUZ1bGxTY3JlZW46IGlzRnVsbCxcbiAgICAgICAgcmlkXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaGlkZVRvcnVzQnV0dG9uKCkge1xuICAgIHRoaXMuX3N0YXRlLnRvcnVzV2lkZ2V0VmlzaWJpbGl0eSA9IGZhbHNlO1xuICAgIHRoaXMuX2Rpc3BsYXlJZnJhbWUoKTtcbiAgfVxuICBzaG93VG9ydXNCdXR0b24oKSB7XG4gICAgdGhpcy5fc3RhdGUudG9ydXNXaWRnZXRWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9kaXNwbGF5SWZyYW1lKCk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgUlBDIG1ldGhvZC4gRm9yd2FyZHMgcmVxdWVzdHMgdG8gYmFja2dyb3VuZCB2aWEgdGhlIFJQQyBlbmdpbmUuXG4gICAqIEFsc28gcmVtYXAgaWRzIGluYm91bmQgYW5kIG91dGJvdW5kXG4gICAqL1xuICBfcnBjUmVxdWVzdChwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGNiID0gY2FsbGJhY2s7XG4gICAgY29uc3QgX3BheWxvYWQgPSBwYXlsb2FkO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShfcGF5bG9hZCkpIHtcbiAgICAgIGlmICghX3BheWxvYWQuanNvbnJwYykge1xuICAgICAgICBfcGF5bG9hZC5qc29ucnBjID0gXCIyLjBcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50cnlXaW5kb3dIYW5kbGUoX3BheWxvYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwcm92aWRlciBiZWNvbWVzIGNvbm5lY3RlZCwgdXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgZW1pdHNcbiAgICogcmVxdWlyZWQgZXZlbnRzLiBJZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gY3VycmVudExvZ2luUHJvdmlkZXIgLSBUaGUgbG9naW4gUHJvdmlkZXJcbiAgICogZW1pdHMgVG9ydXNJbnBhZ2VQcm92aWRlciNjb25uZWN0XG4gICAqL1xuICBfaGFuZGxlQ29ubmVjdChjdXJyZW50TG9naW5Qcm92aWRlciwgaXNMb2dnZWRJbikge1xuICAgIGlmICghdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIiwge1xuICAgICAgICBjdXJyZW50TG9naW5Qcm92aWRlcixcbiAgICAgICAgaXNMb2dnZWRJblxuICAgICAgfSk7XG4gICAgICBsb2cuZGVidWcobWVzc2FnZXMuaW5mby5jb25uZWN0ZWQoY3VycmVudExvZ2luUHJvdmlkZXIpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGUgcHJvdmlkZXIgYmVjb21lcyBkaXNjb25uZWN0ZWQsIHVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIGVtaXRzXG4gICAqIHJlcXVpcmVkIGV2ZW50cy4gSWRlbXBvdGVudCB3aXRoIHJlc3BlY3QgdG8gdGhlIGlzUmVjb3ZlcmFibGUgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBFcnJvciBjb2RlcyBwZXIgdGhlIENsb3NlRXZlbnQgc3RhdHVzIGNvZGVzIGFzIHJlcXVpcmVkIGJ5IEVJUC0xMTkzOlxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudCNTdGF0dXNfY29kZXNcbiAgICpcbiAgICogQHBhcmFtIGlzUmVjb3ZlcmFibGUgLSBXaGV0aGVyIHRoZSBkaXNjb25uZWN0aW9uIGlzIHJlY292ZXJhYmxlLlxuICAgKiBAcGFyYW0gZXJyb3JNZXNzYWdlIC0gQSBjdXN0b20gZXJyb3IgbWVzc2FnZS5cbiAgICogZW1pdHMgVG9ydXNJbnBhZ2VQcm92aWRlciNkaXNjb25uZWN0XG4gICAqL1xuICBfaGFuZGxlRGlzY29ubmVjdChpc1JlY292ZXJhYmxlLCBlcnJvck1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgfHwgIXRoaXMuX3N0YXRlLmlzUGVybWFuZW50bHlEaXNjb25uZWN0ZWQgJiYgIWlzUmVjb3ZlcmFibGUpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICBsZXQgZXJyb3I7XG4gICAgICBpZiAoaXNSZWNvdmVyYWJsZSkge1xuICAgICAgICBlcnJvciA9IG5ldyBFdGhlcmV1bVJwY0Vycm9yKDEwMTMsXG4gICAgICAgIC8vIFRyeSBhZ2FpbiBsYXRlclxuICAgICAgICBlcnJvck1lc3NhZ2UgfHwgbWVzc2FnZXMuZXJyb3JzLmRpc2Nvbm5lY3RlZCgpKTtcbiAgICAgICAgbG9nLmRlYnVnKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yID0gbmV3IEV0aGVyZXVtUnBjRXJyb3IoMTAxMSxcbiAgICAgICAgLy8gSW50ZXJuYWwgZXJyb3JcbiAgICAgICAgZXJyb3JNZXNzYWdlIHx8IG1lc3NhZ2VzLmVycm9ycy5wZXJtYW5lbnRseURpc2Nvbm5lY3RlZCgpKTtcbiAgICAgICAgbG9nLmVycm9yKGVycm9yKTtcbiAgICAgICAgdGhpcy5fc3RhdGUuY3VycmVudExvZ2luUHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGF0ZS5pc0xvZ2dlZEluID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXRlLnRvcnVzV2lkZ2V0VmlzaWJpbGl0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0ZS5pc0lGcmFtZUZ1bGxTY3JlZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdGUuaXNQZXJtYW5lbnRseURpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgaWYgdGhlIGlmcmFtZSB3YW50cyB0byBjbG9zZSB0aGUgd2luZG93IGNhdXNlIGl0IGlzIGRvbmUgcHJvY2Vzc2luZyB0aGUgcmVxdWVzdFxuICBfaGFuZGxlQ2xvc2VXaW5kb3cocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2luZG93SWRcbiAgICB9ID0gcGFyYW1zO1xuICAgIGlmICh0aGlzLndpbmRvd1JlZnNbd2luZG93SWRdKSB7XG4gICAgICB0aGlzLndpbmRvd1JlZnNbd2luZG93SWRdLmNsb3NlKCk7XG4gICAgICBkZWxldGUgdGhpcy53aW5kb3dSZWZzW3dpbmRvd0lkXTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX2NyZWF0ZVBvcHVwQmxvY2tBbGVydCh3aW5kb3dJZCwgdXJsKSB7XG4gICAgY29uc3QgbG9nb1VybCA9IHRoaXMuZ2V0TG9nb1VybCgpO1xuICAgIGNvbnN0IHRvcnVzQWxlcnQgPSBodG1sVG9FbGVtZW50KCc8ZGl2IGlkPVwidG9ydXNBbGVydFwiIGNsYXNzPVwidG9ydXMtYWxlcnQtLXYyXCI+JyArIGA8ZGl2IGlkPVwidG9ydXNBbGVydF9fbG9nb1wiPjxpbWcgc3JjPVwiJHtsb2dvVXJsfVwiIC8+PC9kaXY+YCArIFwiPGRpdj5cIiArIGA8aDEgaWQ9XCJ0b3J1c0FsZXJ0X190aXRsZVwiPiR7dGhpcy5lbWJlZFRyYW5zbGF0aW9ucy5hY3Rpb25SZXF1aXJlZH08L2gxPmAgKyBgPHAgaWQ9XCJ0b3J1c0FsZXJ0X19kZXNjXCI+JHt0aGlzLmVtYmVkVHJhbnNsYXRpb25zLnBlbmRpbmdBY3Rpb259PC9wPmAgKyBcIjwvZGl2PlwiICsgXCI8L2Rpdj5cIik7XG4gICAgY29uc3Qgc3VjY2Vzc0FsZXJ0ID0gaHRtbFRvRWxlbWVudChgPGRpdj48YSBpZD1cInRvcnVzQWxlcnRfX2J0blwiPiR7dGhpcy5lbWJlZFRyYW5zbGF0aW9ucy5jb250aW51ZX08L2E+PC9kaXY+YCk7XG4gICAgY29uc3QgYnRuQ29udGFpbmVyID0gaHRtbFRvRWxlbWVudCgnPGRpdiBpZD1cInRvcnVzQWxlcnRfX2J0bi1jb250YWluZXJcIj48L2Rpdj4nKTtcbiAgICBidG5Db250YWluZXIuYXBwZW5kQ2hpbGQoc3VjY2Vzc0FsZXJ0KTtcbiAgICB0b3J1c0FsZXJ0LmFwcGVuZENoaWxkKGJ0bkNvbnRhaW5lcik7XG4gICAgY29uc3QgYmluZE9uTG9hZCA9ICgpID0+IHtcbiAgICAgIHN1Y2Nlc3NBbGVydC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9oYW5kbGVXaW5kb3cod2luZG93SWQsIHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgIGZlYXR1cmVzOiBnZXRQb3B1cEZlYXR1cmVzKEZFQVRVUkVTX0NPTkZJUk1fV0lORE9XKVxuICAgICAgICB9KTtcbiAgICAgICAgdG9ydXNBbGVydC5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMudG9ydXNBbGVydENvbnRhaW5lci5jaGlsZHJlbi5sZW5ndGggPT09IDApIHRoaXMudG9ydXNBbGVydENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGF0dGFjaE9uTG9hZCA9ICgpID0+IHtcbiAgICAgIHRoaXMudG9ydXNBbGVydENvbnRhaW5lci5hcHBlbmRDaGlsZCh0b3J1c0FsZXJ0KTtcbiAgICB9O1xuICAgIGF0dGFjaE9uTG9hZCgpO1xuICAgIGJpbmRPbkxvYWQoKTtcbiAgICB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgfVxuICBnZXRMb2dvVXJsKCkge1xuICAgIGNvbnN0IGxvZ29VcmwgPSBgJHt0aGlzLnRvcnVzVXJsfS9pbWFnZXMvdG9ydXNfaWNvbi1ibHVlLnN2Z2A7XG4gICAgcmV0dXJuIGxvZ29Vcmw7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShUb3J1c0NvbW11bmljYXRpb25Qcm92aWRlciwgXCJfZGVmYXVsdFN0YXRlXCIsIHtcbiAgYnV0dG9uUG9zaXRpb246IFwiYm90dG9tLWxlZnRcIixcbiAgY3VycmVudExvZ2luUHJvdmlkZXI6IG51bGwsXG4gIGlzSUZyYW1lRnVsbFNjcmVlbjogZmFsc2UsXG4gIGhhc0VtaXR0ZWRDb25uZWN0aW9uOiBmYWxzZSxcbiAgdG9ydXNXaWRnZXRWaXNpYmlsaXR5OiBmYWxzZSxcbiAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICBpc0xvZ2dlZEluOiBmYWxzZSxcbiAgaXNQZXJtYW5lbnRseURpc2Nvbm5lY3RlZDogZmFsc2UsXG4gIGlzQ29ubmVjdGVkOiBmYWxzZVxufSk7XG5cbmNsYXNzIFRvcnVzSW5QYWdlUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUHJvdmlkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uU3RyZWFtLCBfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIG1heEV2ZW50TGlzdGVuZXJzID0gMTAwLFxuICAgICAganNvblJwY1N0cmVhbU5hbWUgPSBcInByb3ZpZGVyXCJcbiAgICB9ID0gX3JlZjtcbiAgICBzdXBlcihjb25uZWN0aW9uU3RyZWFtLCB7XG4gICAgICBtYXhFdmVudExpc3RlbmVycyxcbiAgICAgIGpzb25ScGNTdHJlYW1OYW1lXG4gICAgfSk7XG5cbiAgICAvLyBwcml2YXRlIHN0YXRlXG4gICAgLyoqXG4gICAgICogVGhlIGNoYWluIElEIG9mIHRoZSBjdXJyZW50bHkgY29ubmVjdGVkIFNvbGFuYSBjaGFpbi5cbiAgICAgKiBTZWUgW2NoYWluSWQubmV0d29ya117QGxpbmsgaHR0cHM6Ly9jaGFpbmlkLm5ldHdvcmt9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYWluSWRcIiwgdm9pZCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgdXNlcidzIGN1cnJlbnRseSBzZWxlY3RlZCBTb2xhbmEgYWRkcmVzcy5cbiAgICAgKiBJZiBudWxsLCBUb3J1cyBpcyBlaXRoZXIgbG9ja2VkIG9yIHRoZSB1c2VyIGhhcyBub3QgcGVybWl0dGVkIGFueVxuICAgICAqIGFkZHJlc3NlcyB0byBiZSB2aWV3ZWQuXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2VsZWN0ZWRBZGRyZXNzXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidHJ5V2luZG93SGFuZGxlXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5fc3RhdGUgPSBfb2JqZWN0U3ByZWFkKHt9LCBUb3J1c0luUGFnZVByb3ZpZGVyLl9kZWZhdWx0U3RhdGUpO1xuXG4gICAgLy8gcHVibGljIHN0YXRlXG4gICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgPSBudWxsO1xuICAgIHRoaXMuY2hhaW5JZCA9IG51bGw7XG4gICAgdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkID0gdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlQ2hhaW5DaGFuZ2VkID0gdGhpcy5faGFuZGxlQ2hhaW5DaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkID0gdGhpcy5faGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkLmJpbmQodGhpcyk7XG5cbiAgICAvLyBzZXR1cCBvd24gZXZlbnQgbGlzdGVuZXJzXG5cbiAgICAvLyBFSVAtMTE5MyBjb25uZWN0XG4gICAgdGhpcy5vbihcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIGNvbnN0IGpzb25ScGNOb3RpZmljYXRpb25IYW5kbGVyID0gcGF5bG9hZCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcGFyYW1zXG4gICAgICB9ID0gcGF5bG9hZDtcbiAgICAgIGlmIChtZXRob2QgPT09IFBST1ZJREVSX05PVElGSUNBVElPTlMuQUNDT1VOVFNfQ0hBTkdFRCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVBY2NvdW50c0NoYW5nZWQocGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBQUk9WSURFUl9OT1RJRklDQVRJT05TLlVOTE9DS19TVEFURV9DSEFOR0VEKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZVVubG9ja1N0YXRlQ2hhbmdlZChwYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFBST1ZJREVSX05PVElGSUNBVElPTlMuQ0hBSU5fQ0hBTkdFRCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVDaGFpbkNoYW5nZWQocGFyYW1zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8ganNvbiBycGMgbm90aWZpY2F0aW9uIGxpc3RlbmVyXG4gICAgdGhpcy5qc29uUnBjQ29ubmVjdGlvbkV2ZW50cy5vbihcIm5vdGlmaWNhdGlvblwiLCBqc29uUnBjTm90aWZpY2F0aW9uSGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpbnBhZ2UgcHJvdmlkZXIgaXMgY29ubmVjdGVkIHRvIFRvcnVzLlxuICAgKi9cbiAgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkO1xuICB9XG5cbiAgLy8gUHJpdmF0ZSBNZXRob2RzXG4gIC8vPSA9PT09PT09PT09PT09PT09PT09XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBoZWxwZXIuXG4gICAqIFBvcHVsYXRlcyBpbml0aWFsIHN0YXRlIGJ5IGNhbGxpbmcgJ3dhbGxldF9nZXRQcm92aWRlclN0YXRlJyBhbmQgZW1pdHNcbiAgICogbmVjZXNzYXJ5IGV2ZW50cy5cbiAgICovXG4gIGFzeW5jIF9pbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIGlzVW5sb2NrZWRcbiAgICAgIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IFBST1ZJREVSX0pSUENfTUVUSE9EUy5HRVRfUFJPVklERVJfU1RBVEUsXG4gICAgICAgIHBhcmFtczogW11cbiAgICAgIH0pO1xuXG4gICAgICAvLyBpbmRpY2F0ZSB0aGF0IHdlJ3ZlIGNvbm5lY3RlZCwgZm9yIEVJUC0xMTkzIGNvbXBsaWFuY2VcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIiwge1xuICAgICAgICBjaGFpbklkXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2hhbmRsZUNoYWluQ2hhbmdlZCh7XG4gICAgICAgIGNoYWluSWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkKHtcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIGlzVW5sb2NrZWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkKGFjY291bnRzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmVycm9yKFwiVG9ydXM6IEZhaWxlZCB0byBnZXQgaW5pdGlhbCBzdGF0ZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy5cIiwgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBsb2cuaW5mbyhcImluaXRpYWxpemVkIHByb3ZpZGVyIHN0YXRlXCIpO1xuICAgICAgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KFwiX2luaXRpYWxpemVkXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBSUEMgbWV0aG9kLiBGb3J3YXJkcyByZXF1ZXN0cyB0byBiYWNrZ3JvdW5kIHZpYSB0aGUgUlBDIGVuZ2luZS5cbiAgICogQWxzbyByZW1hcCBpZHMgaW5ib3VuZCBhbmQgb3V0Ym91bmRcbiAgICovXG4gIF9ycGNSZXF1ZXN0KHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgbGV0IGlzSW50ZXJuYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIGxldCBjYiA9IGNhbGxiYWNrO1xuICAgIGNvbnN0IF9wYXlsb2FkID0gcGF5bG9hZDtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoX3BheWxvYWQpKSB7XG4gICAgICBpZiAoIV9wYXlsb2FkLmpzb25ycGMpIHtcbiAgICAgICAgX3BheWxvYWQuanNvbnJwYyA9IFwiMi4wXCI7XG4gICAgICB9XG4gICAgICBpZiAoX3BheWxvYWQubWV0aG9kID09PSBcInNvbGFuYV9hY2NvdW50c1wiIHx8IF9wYXlsb2FkLm1ldGhvZCA9PT0gXCJzb2xhbmFfcmVxdWVzdEFjY291bnRzXCIpIHtcbiAgICAgICAgLy8gaGFuZGxlIGFjY291bnRzIGNoYW5naW5nXG4gICAgICAgIGNiID0gKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkKHJlcy5yZXN1bHQgfHwgW10sIF9wYXlsb2FkLm1ldGhvZCA9PT0gXCJzb2xhbmFfYWNjb3VudHNcIiwgaXNJbnRlcm5hbCk7XG4gICAgICAgICAgY2FsbGJhY2soZXJyLCByZXMpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChfcGF5bG9hZC5tZXRob2QgPT09IFwid2FsbGV0X2dldFByb3ZpZGVyU3RhdGVcIikge1xuICAgICAgICB0aGlzLl9ycGNFbmdpbmUuaGFuZGxlKHBheWxvYWQsIGNiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRyeVdpbmRvd0hhbmRsZShfcGF5bG9hZCwgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHByb3ZpZGVyIGJlY29tZXMgY29ubmVjdGVkLCB1cGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCBlbWl0c1xuICAgKiByZXF1aXJlZCBldmVudHMuIElkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBjaGFpbklkIC0gVGhlIElEIG9mIHRoZSBuZXdseSBjb25uZWN0ZWQgY2hhaW4uXG4gICAqIGVtaXRzIFRvcnVzSW5wYWdlUHJvdmlkZXIjY29ubmVjdFxuICAgKi9cbiAgX2hhbmRsZUNvbm5lY3QoY2hhaW5JZCkge1xuICAgIGlmICghdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIiwge1xuICAgICAgICBjaGFpbklkXG4gICAgICB9KTtcbiAgICAgIGxvZy5kZWJ1ZyhtZXNzYWdlcy5pbmZvLmNvbm5lY3RlZChjaGFpbklkKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHByb3ZpZGVyIGJlY29tZXMgZGlzY29ubmVjdGVkLCB1cGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCBlbWl0c1xuICAgKiByZXF1aXJlZCBldmVudHMuIElkZW1wb3RlbnQgd2l0aCByZXNwZWN0IHRvIHRoZSBpc1JlY292ZXJhYmxlIHBhcmFtZXRlci5cbiAgICpcbiAgICogRXJyb3IgY29kZXMgcGVyIHRoZSBDbG9zZUV2ZW50IHN0YXR1cyBjb2RlcyBhcyByZXF1aXJlZCBieSBFSVAtMTE5MzpcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnQjU3RhdHVzX2NvZGVzXG4gICAqXG4gICAqIEBwYXJhbSBpc1JlY292ZXJhYmxlIC0gV2hldGhlciB0aGUgZGlzY29ubmVjdGlvbiBpcyByZWNvdmVyYWJsZS5cbiAgICogQHBhcmFtIGVycm9yTWVzc2FnZSAtIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UuXG4gICAqIGVtaXRzIFRvcnVzSW5wYWdlUHJvdmlkZXIjZGlzY29ubmVjdFxuICAgKi9cbiAgX2hhbmRsZURpc2Nvbm5lY3QoaXNSZWNvdmVyYWJsZSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkIHx8ICF0aGlzLl9zdGF0ZS5pc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkICYmICFpc1JlY292ZXJhYmxlKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgbGV0IGVycm9yO1xuICAgICAgaWYgKGlzUmVjb3ZlcmFibGUpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXRoZXJldW1ScGNFcnJvcigxMDEzLFxuICAgICAgICAvLyBUcnkgYWdhaW4gbGF0ZXJcbiAgICAgICAgZXJyb3JNZXNzYWdlIHx8IG1lc3NhZ2VzLmVycm9ycy5kaXNjb25uZWN0ZWQoKSk7XG4gICAgICAgIGxvZy5kZWJ1ZyhlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvciA9IG5ldyBFdGhlcmV1bVJwY0Vycm9yKDEwMTEsXG4gICAgICAgIC8vIEludGVybmFsIGVycm9yXG4gICAgICAgIGVycm9yTWVzc2FnZSB8fCBtZXNzYWdlcy5lcnJvcnMucGVybWFuZW50bHlEaXNjb25uZWN0ZWQoKSk7XG4gICAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0YXRlLmFjY291bnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGF0ZS5pc1VubG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXRlLmlzUGVybWFuZW50bHlEaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGFjY291bnRzIG1heSBoYXZlIGNoYW5nZWQuXG4gICAqL1xuICBfaGFuZGxlQWNjb3VudHNDaGFuZ2VkKGFjY291bnRzKSB7XG4gICAgbGV0IGlzRXRoQWNjb3VudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGxldCBpc0ludGVybmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAvLyBkZWZlbnNpdmUgcHJvZ3JhbW1pbmdcbiAgICBsZXQgZmluYWxBY2NvdW50cyA9IGFjY291bnRzO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShmaW5hbEFjY291bnRzKSkge1xuICAgICAgbG9nLmVycm9yKFwiVG9ydXM6IFJlY2VpdmVkIG5vbi1hcnJheSBhY2NvdW50cyBwYXJhbWV0ZXIuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuXCIsIGZpbmFsQWNjb3VudHMpO1xuICAgICAgZmluYWxBY2NvdW50cyA9IFtdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgYWNjb3VudHMpIHtcbiAgICAgIGlmICh0eXBlb2YgYWNjb3VudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsb2cuZXJyb3IoXCJUb3J1czogUmVjZWl2ZWQgbm9uLXN0cmluZyBhY2NvdW50LiBQbGVhc2UgcmVwb3J0IHRoaXMgYnVnLlwiLCBhY2NvdW50cyk7XG4gICAgICAgIGZpbmFsQWNjb3VudHMgPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZW1pdCBhY2NvdW50c0NoYW5nZWQgaWYgYW55dGhpbmcgYWJvdXQgdGhlIGFjY291bnRzIGFycmF5IGhhcyBjaGFuZ2VkXG4gICAgaWYgKCFkZXF1YWwodGhpcy5fc3RhdGUuYWNjb3VudHMsIGZpbmFsQWNjb3VudHMpKSB7XG4gICAgICAvLyB3ZSBzaG91bGQgYWx3YXlzIGhhdmUgdGhlIGNvcnJlY3QgYWNjb3VudHMgZXZlbiBiZWZvcmUgc29sYW5hX2FjY291bnRzXG4gICAgICAvLyByZXR1cm5zLCBleGNlcHQgaW4gY2FzZXMgd2hlcmUgaXNJbnRlcm5hbCBpcyB0cnVlXG4gICAgICBpZiAoaXNFdGhBY2NvdW50cyAmJiBBcnJheS5pc0FycmF5KHRoaXMuX3N0YXRlLmFjY291bnRzKSAmJiB0aGlzLl9zdGF0ZS5hY2NvdW50cy5sZW5ndGggPiAwICYmICFpc0ludGVybmFsKSB7XG4gICAgICAgIGxvZy5lcnJvcignVG9ydXM6IFwic29sYW5hX2FjY291bnRzXCIgdW5leHBlY3RlZGx5IHVwZGF0ZWQgYWNjb3VudHMuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuJywgZmluYWxBY2NvdW50cyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGF0ZS5hY2NvdW50cyA9IGZpbmFsQWNjb3VudHM7XG4gICAgICB0aGlzLmVtaXQoXCJhY2NvdW50c0NoYW5nZWRcIiwgZmluYWxBY2NvdW50cyk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHNlbGVjdGVkQWRkcmVzc1xuICAgIGlmICh0aGlzLnNlbGVjdGVkQWRkcmVzcyAhPT0gZmluYWxBY2NvdW50c1swXSkge1xuICAgICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgPSBmaW5hbEFjY291bnRzWzBdIHx8IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwb24gcmVjZWlwdCBvZiBhIG5ldyBjaGFpbklkIGFuZCBuZXR3b3JrVmVyc2lvbiwgZW1pdHMgY29ycmVzcG9uZGluZ1xuICAgKiBldmVudHMgYW5kIHNldHMgcmVsZXZhbnQgcHVibGljIHN0YXRlLlxuICAgKiBEb2VzIG5vdGhpbmcgaWYgbmVpdGhlciB0aGUgY2hhaW5JZCBub3IgdGhlIG5ldHdvcmtWZXJzaW9uIGFyZSBkaWZmZXJlbnRcbiAgICogZnJvbSBleGlzdGluZyB2YWx1ZXMuXG4gICAqXG4gICAqIGVtaXRzIFRvcnVzSW5wYWdlUHJvdmlkZXIjY2hhaW5DaGFuZ2VkXG4gICAqIEBwYXJhbSBuZXR3b3JrSW5mbyAtIEFuIG9iamVjdCB3aXRoIG5ldHdvcmsgaW5mby5cbiAgICovXG4gIF9oYW5kbGVDaGFpbkNoYW5nZWQoKSB7XG4gICAgbGV0IHtcbiAgICAgIGNoYWluSWRcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBpZiAoIWNoYWluSWQpIHtcbiAgICAgIGxvZy5lcnJvcihcIlRvcnVzOiBSZWNlaXZlZCBpbnZhbGlkIG5ldHdvcmsgcGFyYW1ldGVycy4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy5cIiwge1xuICAgICAgICBjaGFpbklkXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoYWluSWQgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICB0aGlzLl9oYW5kbGVEaXNjb25uZWN0KHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oYW5kbGVDb25uZWN0KGNoYWluSWQpO1xuICAgICAgaWYgKGNoYWluSWQgIT09IHRoaXMuY2hhaW5JZCkge1xuICAgICAgICB0aGlzLmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJjaGFpbkNoYW5nZWRcIiwgdGhpcy5jaGFpbklkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcG9uIHJlY2VpcHQgb2YgYSBuZXcgaXNVbmxvY2tlZCBzdGF0ZSwgc2V0cyByZWxldmFudCBwdWJsaWMgc3RhdGUuXG4gICAqIENhbGxzIHRoZSBhY2NvdW50cyBjaGFuZ2VkIGhhbmRsZXIgd2l0aCB0aGUgcmVjZWl2ZWQgYWNjb3VudHMsIG9yIGFuIGVtcHR5XG4gICAqIGFycmF5LlxuICAgKlxuICAgKiBEb2VzIG5vdGhpbmcgaWYgdGhlIHJlY2VpdmVkIHZhbHVlIGlzIGVxdWFsIHRvIHRoZSBleGlzdGluZyB2YWx1ZS5cbiAgICogVGhlcmUgYXJlIG5vIGxvY2svdW5sb2NrIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGJhZy5cbiAgICovXG4gIF9oYW5kbGVVbmxvY2tTdGF0ZUNoYW5nZWQoKSB7XG4gICAgbGV0IHtcbiAgICAgIGFjY291bnRzLFxuICAgICAgaXNVbmxvY2tlZFxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGlmICh0eXBlb2YgaXNVbmxvY2tlZCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGxvZy5lcnJvcihcIlRvcnVzOiBSZWNlaXZlZCBpbnZhbGlkIGlzVW5sb2NrZWQgcGFyYW1ldGVyLiBQbGVhc2UgcmVwb3J0IHRoaXMgYnVnLlwiLCB7XG4gICAgICAgIGlzVW5sb2NrZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNVbmxvY2tlZCAhPT0gdGhpcy5fc3RhdGUuaXNVbmxvY2tlZCkge1xuICAgICAgdGhpcy5fc3RhdGUuaXNVbmxvY2tlZCA9IGlzVW5sb2NrZWQ7XG4gICAgICB0aGlzLl9oYW5kbGVBY2NvdW50c0NoYW5nZWQoYWNjb3VudHMgfHwgW10pO1xuICAgIH1cbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KFRvcnVzSW5QYWdlUHJvdmlkZXIsIFwiX2RlZmF1bHRTdGF0ZVwiLCB7XG4gIGFjY291bnRzOiBudWxsLFxuICBpc0Nvbm5lY3RlZDogZmFsc2UsXG4gIGlzVW5sb2NrZWQ6IGZhbHNlLFxuICBpbml0aWFsaXplZDogZmFsc2UsXG4gIGlzUGVybWFuZW50bHlEaXNjb25uZWN0ZWQ6IGZhbHNlLFxuICBoYXNFbWl0dGVkQ29ubmVjdGlvbjogZmFsc2Vcbn0pO1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gaW1hZ2UgVVJMIGV4aXN0c1xuICovXG5mdW5jdGlvbiBpbWdFeGlzdHModXJsKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSh0cnVlKTtcbiAgICAgIGltZy5vbmVycm9yID0gKCkgPT4gcmVzb2x2ZShmYWxzZSk7XG4gICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChlKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEV4dHJhY3RzIGEgbmFtZSBmb3IgdGhlIHNpdGUgZnJvbSB0aGUgRE9NXG4gKi9cbmNvbnN0IGdldFNpdGVOYW1lID0gd2luZG93ID0+IHtcbiAgY29uc3Qge1xuICAgIGRvY3VtZW50XG4gIH0gPSB3aW5kb3c7XG4gIGNvbnN0IHNpdGVOYW1lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCA+IG1ldGFbcHJvcGVydHk9XCJvZzpzaXRlX25hbWVcIl0nKTtcbiAgaWYgKHNpdGVOYW1lKSB7XG4gICAgcmV0dXJuIHNpdGVOYW1lLmNvbnRlbnQ7XG4gIH1cbiAgY29uc3QgbWV0YVRpdGxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCA+IG1ldGFbbmFtZT1cInRpdGxlXCJdJyk7XG4gIGlmIChtZXRhVGl0bGUpIHtcbiAgICByZXR1cm4gbWV0YVRpdGxlLmNvbnRlbnQ7XG4gIH1cbiAgaWYgKGRvY3VtZW50LnRpdGxlICYmIGRvY3VtZW50LnRpdGxlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZG9jdW1lbnQudGl0bGU7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbn07XG5cbi8qKlxuICogRXh0cmFjdHMgYW4gaWNvbiBmb3IgdGhlIHNpdGUgZnJvbSB0aGUgRE9NXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFNpdGVJY29uKHdpbmRvdykge1xuICB0cnkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRvY3VtZW50XG4gICAgfSA9IHdpbmRvdztcblxuICAgIC8vIFVzZSB0aGUgc2l0ZSdzIGZhdmljb24gaWYgaXQgZXhpc3RzXG4gICAgbGV0IGljb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkID4gbGlua1tyZWw9XCJzaG9ydGN1dCBpY29uXCJdJyk7XG4gICAgaWYgKGljb24gJiYgKGF3YWl0IGltZ0V4aXN0cyhpY29uLmhyZWYpKSkge1xuICAgICAgcmV0dXJuIGljb24uaHJlZjtcbiAgICB9XG5cbiAgICAvLyBTZWFyY2ggdGhyb3VnaCBhdmFpbGFibGUgaWNvbnMgaW4gbm8gcGFydGljdWxhciBvcmRlclxuICAgIGljb24gPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2hlYWQgPiBsaW5rW3JlbD1cImljb25cIl0nKSkuZmluZChfaWNvbiA9PiBCb29sZWFuKF9pY29uLmhyZWYpKTtcbiAgICBpZiAoaWNvbiAmJiAoYXdhaXQgaW1nRXhpc3RzKGljb24uaHJlZikpKSB7XG4gICAgICByZXR1cm4gaWNvbi5ocmVmO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgc2l0ZSBtZXRhZGF0YSBhbmQgcmV0dXJucyBpdFxuICpcbiAqL1xuY29uc3QgZ2V0U2l0ZU1ldGFkYXRhID0gYXN5bmMgKCkgPT4gKHtcbiAgbmFtZTogZ2V0U2l0ZU5hbWUod2luZG93KSxcbiAgaWNvbjogYXdhaXQgZ2V0U2l0ZUljb24od2luZG93KVxufSk7XG5cbmNvbnN0IFBST1ZJREVSX1VOU0FGRV9NRVRIT0RTID0gW1wic2VuZF90cmFuc2FjdGlvblwiLCBcInNpZ25fdHJhbnNhY3Rpb25cIiwgXCJzaWduX2FsbF90cmFuc2FjdGlvbnNcIiwgXCJzaWduX21lc3NhZ2VcIiwgXCJjb25uZWN0XCJdO1xuY29uc3QgQ09NTVVOSUNBVElPTl9VTlNBRkVfTUVUSE9EUyA9IFtDT01NVU5JQ0FUSU9OX0pSUENfTUVUSE9EUy5TRVRfUFJPVklERVJdO1xuY29uc3QgaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUgPSBzdG9yYWdlQXZhaWxhYmxlKFwibG9jYWxTdG9yYWdlXCIpO1xuXG4vLyBwcmVsb2FkIGZvciBpZnJhbWUgZG9lc24ndCB3b3JrIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU5MzI2N1xuKGFzeW5jIGZ1bmN0aW9uIHByZUxvYWRJZnJhbWUoKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICAgIGNvbnN0IHRvcnVzSWZyYW1lSHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvcnVzVXJsXG4gICAgfSA9IGF3YWl0IGdldFRvcnVzVXJsKFwicHJvZHVjdGlvblwiKTtcbiAgICB0b3J1c0lmcmFtZUh0bWwuaHJlZiA9IGAke3RvcnVzVXJsfS9mcmFtZWA7XG4gICAgdG9ydXNJZnJhbWVIdG1sLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICB0b3J1c0lmcmFtZUh0bWwudHlwZSA9IFwidGV4dC9odG1sXCI7XG4gICAgdG9ydXNJZnJhbWVIdG1sLnJlbCA9IFwicHJlZmV0Y2hcIjtcbiAgICBpZiAodG9ydXNJZnJhbWVIdG1sLnJlbExpc3QgJiYgdG9ydXNJZnJhbWVIdG1sLnJlbExpc3Quc3VwcG9ydHMpIHtcbiAgICAgIGlmICh0b3J1c0lmcmFtZUh0bWwucmVsTGlzdC5zdXBwb3J0cyhcInByZWZldGNoXCIpKSB7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodG9ydXNJZnJhbWVIdG1sKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nLndhcm4oZXJyb3IpO1xuICB9XG59KSgpO1xuY2xhc3MgVG9ydXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQge1xuICAgICAgbW9kYWxaSW5kZXggPSA5OTk5OVxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzSW5pdGlhbGl6ZWRcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3J1c0FsZXJ0XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibW9kYWxaSW5kZXhcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJhbGVydFpJbmRleFwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcXVlc3RlZExvZ2luUHJvdmlkZXJcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm92aWRlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbW11bmljYXRpb25Qcm92aWRlclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhcHBTdG9yYWdlS2V5XCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNUb3B1cEhpZGRlblwiLCBmYWxzZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9ydXNBbGVydENvbnRhaW5lclwiLCB2b2lkIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcnVzVXJsXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9ydXNJZnJhbWVcIiwgdm9pZCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdHlsZUxpbmtcIiwgdm9pZCAwKTtcbiAgICB0aGlzLnRvcnVzVXJsID0gXCJcIjtcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy8gaW5pdCBkb25lXG4gICAgdGhpcy5yZXF1ZXN0ZWRMb2dpblByb3ZpZGVyID0gbnVsbDtcbiAgICB0aGlzLm1vZGFsWkluZGV4ID0gbW9kYWxaSW5kZXg7XG4gICAgdGhpcy5hbGVydFpJbmRleCA9IG1vZGFsWkluZGV4ICsgMTAwMDtcbiAgICB0aGlzLmRhcHBTdG9yYWdlS2V5ID0gXCJcIjtcbiAgfVxuICBnZXQgaXNMb2dnZWRJbigpIHtcbiAgICBpZiAoIXRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLmlzTG9nZ2VkSW47XG4gIH1cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICBsZXQge1xuICAgICAgYnVpbGRFbnYgPSBUT1JVU19CVUlMRF9FTlYuUFJPRFVDVElPTixcbiAgICAgIGVuYWJsZUxvZ2dpbmcgPSBmYWxzZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBzaG93VG9ydXNCdXR0b24gPSBmYWxzZSxcbiAgICAgIHVzZUxvY2FsU3RvcmFnZSA9IGZhbHNlLFxuICAgICAgYnV0dG9uUG9zaXRpb24gPSBCVVRUT05fUE9TSVRJT04uQk9UVE9NX0xFRlQsXG4gICAgICBhcGlLZXkgPSBcInRvcnVzLWRlZmF1bHRcIixcbiAgICAgIGV4dHJhUGFyYW1zID0ge30sXG4gICAgICB3aGl0ZUxhYmVsXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBpbml0aWFsaXplZFwiKTtcbiAgICBzZXRBUElLZXkoYXBpS2V5KTtcbiAgICBjb25zdCB7XG4gICAgICB0b3J1c1VybCxcbiAgICAgIGxvZ0xldmVsXG4gICAgfSA9IGF3YWl0IGdldFRvcnVzVXJsKGJ1aWxkRW52KTtcbiAgICBsb2cuZW5hYmxlQWxsKCk7XG4gICAgbG9nLmluZm8odG9ydXNVcmwsIFwidXJsIGxvYWRlZFwiKTtcbiAgICBsb2cuaW5mbyhgU29sYW5hIEVtYmVkIFZlcnNpb24gOiR7dmVyc2lvbn1gKTtcbiAgICB0aGlzLnRvcnVzVXJsID0gdG9ydXNVcmw7XG4gICAgbG9nLnNldERlZmF1bHRMZXZlbChsb2dMZXZlbCk7XG4gICAgaWYgKGVuYWJsZUxvZ2dpbmcpIGxvZy5lbmFibGVBbGwoKTtlbHNlIGxvZy5kaXNhYmxlQWxsKCk7XG4gICAgY29uc3QgZGFwcFN0b3JhZ2VLZXkgPSB0aGlzLmhhbmRsZURhcHBTdG9yYWdlS2V5KHVzZUxvY2FsU3RvcmFnZSk7XG4gICAgY29uc3QgdG9ydXNJZnJhbWVVcmwgPSBuZXcgVVJMKHRvcnVzVXJsKTtcbiAgICBpZiAodG9ydXNJZnJhbWVVcmwucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpKSB0b3J1c0lmcmFtZVVybC5wYXRobmFtZSArPSBcImZyYW1lXCI7ZWxzZSB0b3J1c0lmcmFtZVVybC5wYXRobmFtZSArPSBcIi9mcmFtZVwiO1xuICAgIGNvbnN0IGhhc2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgaWYgKGRhcHBTdG9yYWdlS2V5KSBoYXNoUGFyYW1zLmFwcGVuZChcImRhcHBTdG9yYWdlS2V5XCIsIGRhcHBTdG9yYWdlS2V5KTtcbiAgICBoYXNoUGFyYW1zLmFwcGVuZChcIm9yaWdpblwiLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICB0b3J1c0lmcmFtZVVybC5oYXNoID0gaGFzaFBhcmFtcy50b1N0cmluZygpO1xuXG4gICAgLy8gSWZyYW1lIGNvZGVcbiAgICB0aGlzLnRvcnVzSWZyYW1lID0gaHRtbFRvRWxlbWVudChgPGlmcmFtZVxuICAgICAgICBpZD1cInRvcnVzSWZyYW1lXCJcbiAgICAgICAgY2xhc3M9XCJ0b3J1c0lmcmFtZVwiXG4gICAgICAgIHNyYz1cIiR7dG9ydXNJZnJhbWVVcmwuaHJlZn1cIlxuICAgICAgICBzdHlsZT1cImRpc3BsYXk6IG5vbmU7IHBvc2l0aW9uOiBmaXhlZDsgdG9wOiAwOyByaWdodDogMDsgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTsgYm9yZGVyOiBub25lOyBib3JkZXItcmFkaXVzOiAwOyB6LWluZGV4OiAke3RoaXMubW9kYWxaSW5kZXgudG9TdHJpbmcoKX1cIlxuICAgICAgPjwvaWZyYW1lPmApO1xuICAgIHRoaXMudG9ydXNBbGVydENvbnRhaW5lciA9IGh0bWxUb0VsZW1lbnQoYDxkaXYgaWQ9XCJ0b3J1c0FsZXJ0Q29udGFpbmVyXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmU7IHotaW5kZXg6ICR7dGhpcy5hbGVydFpJbmRleC50b1N0cmluZygpfVwiPjwvZGl2PmApO1xuICAgIHRoaXMuc3R5bGVMaW5rID0gaHRtbFRvRWxlbWVudChgPGxpbmsgaHJlZj1cIiR7dG9ydXNVcmx9L2Nzcy93aWRnZXQuY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiIHR5cGU9XCJ0ZXh0L2Nzc1wiPmApO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnRvcnVzSWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCBkYXBwTWV0YWRhdGEgPSBhd2FpdCBnZXRTaXRlTWV0YWRhdGEoKTtcbiAgICAgICAgICAvLyBzZW5kIGluaXQgcGFyYW1zIGhlcmVcbiAgICAgICAgICB0aGlzLnRvcnVzSWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYnV0dG9uUG9zaXRpb24sXG4gICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICBuZXR3b3JrLFxuICAgICAgICAgICAgZGFwcE1ldGFkYXRhLFxuICAgICAgICAgICAgZXh0cmFQYXJhbXMsXG4gICAgICAgICAgICB3aGl0ZUxhYmVsXG4gICAgICAgICAgfSwgdG9ydXNJZnJhbWVVcmwub3JpZ2luKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFdlYjMoe1xuICAgICAgICAgICAgdG9ydXNVcmxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc2hvd1RvcnVzQnV0dG9uKSB0aGlzLnNob3dUb3J1c0J1dHRvbigpO1xuICAgICAgICAgIGlmICh3aGl0ZUxhYmVsPy50b3B1cEhpZGUpIHRoaXMuaXNUb3B1cEhpZGRlbiA9IHdoaXRlTGFiZWwudG9wdXBIaWRlO2Vsc2UgdGhpcy5oaWRlVG9ydXNCdXR0b24oKTtcbiAgICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgd2luZG93LnRvcnVzID0gdGhpcztcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLnN0eWxlTGluayk7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMudG9ydXNJZnJhbWUpO1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnRvcnVzQWxlcnRDb250YWluZXIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBsb2dpbigpIHtcbiAgICBsZXQgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbCBpbml0KCkgZmlyc3RcIik7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVxdWVzdGVkTG9naW5Qcm92aWRlciA9IHBhcmFtcy5sb2dpblByb3ZpZGVyIHx8IG51bGw7XG4gICAgICBpZiAoIXRoaXMucmVxdWVzdGVkTG9naW5Qcm92aWRlcikge1xuICAgICAgICB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5fZGlzcGxheUlmcmFtZSh7XG4gICAgICAgICAgaXNGdWxsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gSWYgdXNlciBpcyBhbHJlYWR5IGxvZ2dlZCBpbiwgd2UgYXNzdW1lIHRoZXkgaGF2ZSBnaXZlbiBhY2Nlc3MgdG8gdGhlIHdlYnNpdGVcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gV2UgdXNlIHRoaXMgbWV0aG9kIGJlY2F1c2Ugd2Ugd2FudCB0byB1cGRhdGUgaW5QYWdlIHByb3ZpZGVyIHN0YXRlIHdpdGggYWNjb3VudCBpbmZvXG4gICAgICAgIHRoaXMucHJvdmlkZXIuX3JwY1JlcXVlc3Qoe1xuICAgICAgICAgIG1ldGhvZDogXCJzb2xhbmFfcmVxdWVzdEFjY291bnRzXCIsXG4gICAgICAgICAgcGFyYW1zOiBbdGhpcy5yZXF1ZXN0ZWRMb2dpblByb3ZpZGVyLCBwYXJhbXMubG9naW5faGludF1cbiAgICAgICAgfSwgZ2V0UnBjUHJvbWlzZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCkpO1xuICAgICAgfSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIHdvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGp1c3QgaW4gY2FzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9naW4gZmFpbGVkXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXCJsb2dpbiBmYWlsZWRcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5pc0lGcmFtZUZ1bGxTY3JlZW4pIHRoaXMuY29tbXVuaWNhdGlvblByb3ZpZGVyLl9kaXNwbGF5SWZyYW1lKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGxvZ2luV2l0aFByaXZhdGVLZXkobG9naW5QYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbCBpbml0KCkgZmlyc3RcIik7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZUtleSxcbiAgICAgIHVzZXJJbmZvXG4gICAgfSA9IGxvZ2luUGFyYW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN1Y2Nlc3NcbiAgICB9ID0gYXdhaXQgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwibG9naW5fd2l0aF9wcml2YXRlX2tleVwiLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHByaXZhdGVLZXksXG4gICAgICAgIHVzZXJJbmZvXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFzdWNjZXNzKSB0aHJvdyBuZXcgRXJyb3IoXCJMb2dpbiBGYWlsZWRcIik7XG4gIH1cbiAgYXN5bmMgbG9nb3V0KCkge1xuICAgIGlmICghdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuaXNMb2dnZWRJbikgdGhyb3cgbmV3IEVycm9yKFwiTm90IGxvZ2dlZCBpblwiKTtcbiAgICBhd2FpdCB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuTE9HT1VULFxuICAgICAgcGFyYW1zOiBbXVxuICAgIH0pO1xuICAgIHRoaXMucmVxdWVzdGVkTG9naW5Qcm92aWRlciA9IG51bGw7XG4gIH1cbiAgYXN5bmMgY2xlYW5VcCgpIHtcbiAgICBpZiAodGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuaXNMb2dnZWRJbikge1xuICAgICAgYXdhaXQgdGhpcy5sb2dvdXQoKTtcbiAgICB9XG4gICAgdGhpcy5jbGVhckluaXQoKTtcbiAgfVxuICBjbGVhckluaXQoKSB7XG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCB8fCBlbGVtZW50IGluc3RhbmNlb2YgRG9jdW1lbnQ7XG4gICAgfVxuICAgIGlmIChpc0VsZW1lbnQodGhpcy5zdHlsZUxpbmspICYmIHdpbmRvdy5kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMuc3R5bGVMaW5rKSkge1xuICAgICAgdGhpcy5zdHlsZUxpbmsucmVtb3ZlKCk7XG4gICAgICB0aGlzLnN0eWxlTGluayA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudCh0aGlzLnRvcnVzSWZyYW1lKSAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLnRvcnVzSWZyYW1lKSkge1xuICAgICAgdGhpcy50b3J1c0lmcmFtZS5yZW1vdmUoKTtcbiAgICAgIHRoaXMudG9ydXNJZnJhbWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc0VsZW1lbnQodGhpcy50b3J1c0FsZXJ0Q29udGFpbmVyKSAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLnRvcnVzQWxlcnRDb250YWluZXIpKSB7XG4gICAgICB0aGlzLnRvcnVzQWxlcnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIucmVtb3ZlKCk7XG4gICAgICB0aGlzLnRvcnVzQWxlcnRDb250YWluZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICB9XG4gIGhpZGVUb3J1c0J1dHRvbigpIHtcbiAgICB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5oaWRlVG9ydXNCdXR0b24oKTtcbiAgfVxuICBzaG93VG9ydXNCdXR0b24oKSB7XG4gICAgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuc2hvd1RvcnVzQnV0dG9uKCk7XG4gIH1cbiAgYXN5bmMgc2V0UHJvdmlkZXIocGFyYW1zKSB7XG4gICAgYXdhaXQgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlNFVF9QUk9WSURFUixcbiAgICAgIHBhcmFtczogX29iamVjdFNwcmVhZCh7fSwgcGFyYW1zKVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNob3dXYWxsZXQocGF0aCkge1xuICAgIGxldCBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNvbnN0IGluc3RhbmNlSWQgPSBhd2FpdCB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogQ09NTVVOSUNBVElPTl9KUlBDX01FVEhPRFMuV0FMTEVUX0lOU1RBTkNFX0lELFxuICAgICAgcGFyYW1zOiBbXVxuICAgIH0pO1xuICAgIGNvbnN0IGZpbmFsUGF0aCA9IHBhdGggPyBgLyR7cGF0aH1gIDogXCJcIjtcbiAgICBjb25zdCBmaW5hbFVybCA9IG5ldyBVUkwoYCR7dGhpcy50b3J1c1VybH0vd2FsbGV0JHtmaW5hbFBhdGh9YCk7XG4gICAgLy8gVXNpbmcgVVJMIGNvbnN0cnVjdG9yIHRvIHByZXZlbnQganMgaW5qZWN0aW9uIGFuZCBhbGxvdyBwYXJhbWV0ZXIgdmFsaWRhdGlvbi4hXG4gICAgZmluYWxVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImluc3RhbmNlSWRcIiwgaW5zdGFuY2VJZCk7XG4gICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKHggPT4ge1xuICAgICAgZmluYWxVcmwuc2VhcmNoUGFyYW1zLmFwcGVuZCh4LCBwYXJhbXNbeF0pO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmRhcHBTdG9yYWdlS2V5KSB7XG4gICAgICBmaW5hbFVybC5oYXNoID0gYCNkYXBwU3RvcmFnZUtleT0ke3RoaXMuZGFwcFN0b3JhZ2VLZXl9YDtcbiAgICB9XG4gICAgLy8gTm8gbmVlZCB0byB0cmFjayB0aGlzIHdpbmRvdyBzdGF0ZS4gSGVuY2UsIG5vIF9oYW5kbGVXaW5kb3cgY2FsbC5cbiAgICBjb25zdCB3YWxsZXRXaW5kb3cgPSBuZXcgUG9wdXBIYW5kbGVyKHtcbiAgICAgIHVybDogZmluYWxVcmwsXG4gICAgICBmZWF0dXJlczogZ2V0UG9wdXBGZWF0dXJlcyhGRUFUVVJFU19ERUZBVUxUX1dBTExFVF9XSU5ET1cpXG4gICAgfSk7XG4gICAgd2FsbGV0V2luZG93Lm9wZW4oKTtcbiAgfVxuICBhc3luYyBnZXRVc2VySW5mbygpIHtcbiAgICBjb25zdCB1c2VySW5mb1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlVTRVJfSU5GTyxcbiAgICAgIHBhcmFtczogW11cbiAgICB9KTtcbiAgICByZXR1cm4gdXNlckluZm9SZXNwb25zZTtcbiAgfVxuICBhc3luYyBpbml0aWF0ZVRvcHVwKHByb3ZpZGVyLCBwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkgdGhyb3cgbmV3IEVycm9yKFwiVG9ydXMgaXMgbm90IGluaXRpYWxpemVkXCIpO1xuICAgIGNvbnN0IHdpbmRvd0lkID0gZ2V0V2luZG93SWQoKTtcbiAgICB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlci5faGFuZGxlV2luZG93KHdpbmRvd0lkKTtcbiAgICBjb25zdCB0b3B1cFJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IENPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTLlRPUFVQLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHdpbmRvd0lkXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvcHVwUmVzcG9uc2U7XG4gIH1cblxuICAvLyBTb2xhbmEgc3BlY2lmaWMgQVBJXG4gIGFzeW5jIGdldEFjY291bnRzKCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJnZXRBY2NvdW50c1wiLFxuICAgICAgcGFyYW1zOiBbXVxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBpc0xlZ2FjeVRyYW5zYWN0aW9uID0gaXNMZWdhY3lUcmFuc2FjdGlvbkluc3RhbmNlKHRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBtZXNzYWdlID0gaXNMZWdhY3lUcmFuc2FjdGlvbiA/IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSh7XG4gICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogZmFsc2VcbiAgICB9KS50b1N0cmluZyhcImhleFwiKSA6IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpKS50b1N0cmluZyhcImhleFwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwic2VuZF90cmFuc2FjdGlvblwiLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIGlzTGVnYWN5VHJhbnNhY3Rpb25cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICAvLyBzdXBwb3J0IHNlbmRPcHRpb25zXG4gIGFzeW5jIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpc0xlZ2FjeVRyYW5zYWN0aW9uID0gaXNMZWdhY3lUcmFuc2FjdGlvbkluc3RhbmNlKHRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBtZXNzYWdlID0gaXNMZWdhY3lUcmFuc2FjdGlvbiA/IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSh7XG4gICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogZmFsc2VcbiAgICB9KS50b1N0cmluZyhcImhleFwiKSA6IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpKS50b1N0cmluZyhcImhleFwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwic2VuZF90cmFuc2FjdGlvblwiLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGlzTGVnYWN5VHJhbnNhY3Rpb25cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgc2lnbmF0dXJlOiByZXNwb25zZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgaXNMZWdhY3lUcmFuc2FjdGlvbiA9IGlzTGVnYWN5VHJhbnNhY3Rpb25JbnN0YW5jZSh0cmFuc2FjdGlvbik7XG4gICAgY29uc3QgbWVzc2FnZSA9IGlzTGVnYWN5VHJhbnNhY3Rpb24gPyB0cmFuc2FjdGlvbi5zZXJpYWxpemVNZXNzYWdlKCkudG9TdHJpbmcoXCJoZXhcIikgOiBCdWZmZXIuZnJvbSh0cmFuc2FjdGlvbi5tZXNzYWdlLnNlcmlhbGl6ZSgpKS50b1N0cmluZyhcImhleFwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwic2lnbl90cmFuc2FjdGlvblwiLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VPbmx5OiB0cnVlLFxuICAgICAgICBpc0xlZ2FjeVRyYW5zYWN0aW9uXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyByZWNvbnN0cnVjdCBzaWduYXR1cmUgcGFpclxuICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHtcbiAgICAgIHB1YmxpY0tleTogbmV3IFB1YmxpY0tleShwYXJzZWQucHVibGljS2V5KSxcbiAgICAgIHNpZ25hdHVyZTogQnVmZmVyLmZyb20ocGFyc2VkLnNpZ25hdHVyZSwgXCJoZXhcIilcbiAgICB9O1xuICAgIHRyYW5zYWN0aW9uLmFkZFNpZ25hdHVyZShzaWduYXR1cmUucHVibGljS2V5LCBzaWduYXR1cmUuc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gIH1cbiAgYXN5bmMgc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICBsZXQgaXNMZWdhY3lUcmFuc2FjdGlvbjtcbiAgICBjb25zdCBlbmNvZGVkTWVzc2FnZSA9IHRyYW5zYWN0aW9ucy5tYXAodHggPT4ge1xuICAgICAgaXNMZWdhY3lUcmFuc2FjdGlvbiA9IGlzTGVnYWN5VHJhbnNhY3Rpb25JbnN0YW5jZSh0eCk7XG4gICAgICByZXR1cm4gaXNMZWdhY3lUcmFuc2FjdGlvbiA/IHR4LnNlcmlhbGl6ZU1lc3NhZ2UoKS50b1N0cmluZyhcImhleFwiKSA6IEJ1ZmZlci5mcm9tKHR4Lm1lc3NhZ2Uuc2VyaWFsaXplKCkpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwic2lnbl9hbGxfdHJhbnNhY3Rpb25zXCIsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWVzc2FnZTogZW5jb2RlZE1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2VPbmx5OiB0cnVlLFxuICAgICAgICBpc0xlZ2FjeVRyYW5zYWN0aW9uXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyByZWNvbnN0cnVjdCBzaWduYXR1cmUgcGFpcnNcbiAgICBjb25zdCBzaWduYXR1cmVzID0gcmVzcG9uc2VzLm1hcChpdGVtID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoaXRlbSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwdWJsaWNLZXk6IG5ldyBQdWJsaWNLZXkocGFyc2VkLnB1YmxpY0tleSksXG4gICAgICAgIHNpZ25hdHVyZTogQnVmZmVyLmZyb20ocGFyc2VkLnNpZ25hdHVyZSwgXCJoZXhcIilcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdHJhbnNhY3Rpb25zLmZvckVhY2goKHR4LCBpZHgpID0+IHtcbiAgICAgIHR4LmFkZFNpZ25hdHVyZShzaWduYXR1cmVzW2lkeF0ucHVibGljS2V5LCBzaWduYXR1cmVzW2lkeF0uc2lnbmF0dXJlKTtcbiAgICAgIHJldHVybiB0eDtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25zO1xuICB9XG4gIGFzeW5jIHNpZ25NZXNzYWdlKGRhdGEpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6IFwic2lnbl9tZXNzYWdlXCIsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgZGF0YVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBhc3luYyBnZXRHYXNsZXNzUHVibGljS2V5KCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJnZXRfZ2FzbGVzc19wdWJsaWNfa2V5XCIsXG4gICAgICBwYXJhbXM6IFtdXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgLy8gYXN5bmMgY29ubmVjdCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgLy8gICBjb25zdCByZXNwb25zZSA9IChhd2FpdCB0aGlzLnByb3ZpZGVyLnJlcXVlc3Qoe1xuICAvLyAgICAgbWV0aG9kOiBcImNvbm5lY3RcIixcbiAgLy8gICAgIHBhcmFtczoge30sXG4gIC8vICAgfSkpIGFzIGJvb2xlYW47XG4gIC8vICAgcmV0dXJuIHJlc3BvbnNlO1xuICAvLyB9XG5cbiAgaGFuZGxlRGFwcFN0b3JhZ2VLZXkodXNlTG9jYWxTdG9yYWdlKSB7XG4gICAgY29uc3QgbG9jYWxTdG9yYWdlS2V5ID0gYCR7Y29uZmlndXJhdGlvbi5sb2NhbFN0b3JhZ2VLZXlQcmVmaXh9JHt3aW5kb3cubG9jYXRpb24uaG9zdG5hbWV9YDtcbiAgICBsZXQgZGFwcFN0b3JhZ2VLZXkgPSBcIlwiO1xuICAgIGlmIChpc0xvY2FsU3RvcmFnZUF2YWlsYWJsZSAmJiB1c2VMb2NhbFN0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IHN0b3JlZEtleSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShsb2NhbFN0b3JhZ2VLZXkpO1xuICAgICAgaWYgKHN0b3JlZEtleSkgZGFwcFN0b3JhZ2VLZXkgPSBzdG9yZWRLZXk7ZWxzZSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZEtleSA9IGB0b3J1cy1hcHAtJHtnZXRXaW5kb3dJZCgpfWA7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbFN0b3JhZ2VLZXksIGdlbmVyYXRlZEtleSk7XG4gICAgICAgIGRhcHBTdG9yYWdlS2V5ID0gZ2VuZXJhdGVkS2V5O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRhcHBTdG9yYWdlS2V5ID0gZGFwcFN0b3JhZ2VLZXk7XG4gICAgcmV0dXJuIGRhcHBTdG9yYWdlS2V5O1xuICB9XG4gIGFzeW5jIF9zZXR1cFdlYjMocHJvdmlkZXJQYXJhbXMpIHtcbiAgICBsb2cuaW5mbyhcInNldHVwV2ViMyBydW5uaW5nXCIpO1xuICAgIC8vIHNldHVwIGJhY2tncm91bmQgY29ubmVjdGlvblxuICAgIGNvbnN0IHByb3ZpZGVyU3RyZWFtID0gbmV3IEJhc2VQb3N0TWVzc2FnZVN0cmVhbSh7XG4gICAgICBuYW1lOiBcImVtYmVkX3RvcnVzXCIsXG4gICAgICB0YXJnZXQ6IFwiaWZyYW1lX3RvcnVzXCIsXG4gICAgICB0YXJnZXRXaW5kb3c6IHRoaXMudG9ydXNJZnJhbWUuY29udGVudFdpbmRvd1xuICAgIH0pO1xuXG4gICAgLy8gV2UgY3JlYXRlIGFub3RoZXIgTG9jYWxNZXNzYWdlRHVwbGV4U3RyZWFtIGZvciBjb21tdW5pY2F0aW9uIGJldHdlZW4gZGFwcCA8PiBpZnJhbWVcbiAgICBjb25zdCBjb21tdW5pY2F0aW9uU3RyZWFtID0gbmV3IEJhc2VQb3N0TWVzc2FnZVN0cmVhbSh7XG4gICAgICBuYW1lOiBcImVtYmVkX2NvbW11bmljYXRpb25cIixcbiAgICAgIHRhcmdldDogXCJpZnJhbWVfY29tbXVuaWNhdGlvblwiLFxuICAgICAgdGFyZ2V0V2luZG93OiB0aGlzLnRvcnVzSWZyYW1lLmNvbnRlbnRXaW5kb3dcbiAgICB9KTtcblxuICAgIC8vIGNvbXBvc2UgdGhlIGluUGFnZSBwcm92aWRlclxuICAgIGNvbnN0IGluUGFnZVByb3ZpZGVyID0gbmV3IFRvcnVzSW5QYWdlUHJvdmlkZXIocHJvdmlkZXJTdHJlYW0sIHt9KTtcbiAgICBjb25zdCBjb21tdW5pY2F0aW9uUHJvdmlkZXIgPSBuZXcgVG9ydXNDb21tdW5pY2F0aW9uUHJvdmlkZXIoY29tbXVuaWNhdGlvblN0cmVhbSwge30pO1xuICAgIGluUGFnZVByb3ZpZGVyLnRyeVdpbmRvd0hhbmRsZSA9IChwYXlsb2FkLCBjYikgPT4ge1xuICAgICAgY29uc3QgX3BheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KF9wYXlsb2FkKSAmJiBQUk9WSURFUl9VTlNBRkVfTUVUSE9EUy5pbmNsdWRlcyhfcGF5bG9hZC5tZXRob2QpKSB7XG4gICAgICAgIGlmICghdGhpcy5jb21tdW5pY2F0aW9uUHJvdmlkZXIuaXNMb2dnZWRJbikgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBOb3QgTG9nZ2VkIEluXCIpO1xuICAgICAgICBjb25zdCB3aW5kb3dJZCA9IGdldFdpbmRvd0lkKCk7XG4gICAgICAgIGNvbW11bmljYXRpb25Qcm92aWRlci5faGFuZGxlV2luZG93KHdpbmRvd0lkLCB7XG4gICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgIGZlYXR1cmVzOiBnZXRQb3B1cEZlYXR1cmVzKEZFQVRVUkVTX0NPTkZJUk1fV0lORE9XKVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZm9yIGluUGFnZVByb3ZpZGVyIG1ldGhvZHMgc2VuZGluZyB3aW5kb3dJZCBpbiByZXF1ZXN0IGluc3RlYWQgb2YgcGFyYW1zXG4gICAgICAgIC8vIGFzIHBhcmFtcyBtaWdodCBiZSBwb3NpdGlvbmFsLlxuICAgICAgICBfcGF5bG9hZC53aW5kb3dJZCA9IHdpbmRvd0lkO1xuICAgICAgfVxuICAgICAgaW5QYWdlUHJvdmlkZXIuX3JwY0VuZ2luZS5oYW5kbGUoX3BheWxvYWQsIGNiKTtcbiAgICB9O1xuICAgIGNvbW11bmljYXRpb25Qcm92aWRlci50cnlXaW5kb3dIYW5kbGUgPSAocGF5bG9hZCwgY2IpID0+IHtcbiAgICAgIGNvbnN0IF9wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShfcGF5bG9hZCkgJiYgQ09NTVVOSUNBVElPTl9VTlNBRkVfTUVUSE9EUy5pbmNsdWRlcyhfcGF5bG9hZC5tZXRob2QpKSB7XG4gICAgICAgIGNvbnN0IHdpbmRvd0lkID0gZ2V0V2luZG93SWQoKTtcbiAgICAgICAgY29tbXVuaWNhdGlvblByb3ZpZGVyLl9oYW5kbGVXaW5kb3cod2luZG93SWQsIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgZmVhdHVyZXM6IGdldFBvcHVwRmVhdHVyZXMoRkVBVFVSRVNfUFJPVklERVJfQ0hBTkdFX1dJTkRPVykgLy8gdG9kbzogYXJlIHRoZXNlIGZlYXR1cmVzIGdlbmVyaWMgZm9yIGFsbFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZm9yIGNvbW11bmljYXRpb24gbWV0aG9kcyBzZW5kaW5nIHdpbmRvdyBpZCBpbiBqcnBjIHJlcSBwYXJhbXNcbiAgICAgICAgX3BheWxvYWQucGFyYW1zLndpbmRvd0lkID0gd2luZG93SWQ7XG4gICAgICB9XG4gICAgICBjb21tdW5pY2F0aW9uUHJvdmlkZXIuX3JwY0VuZ2luZS5oYW5kbGUoX3BheWxvYWQsIGNiKTtcbiAgICB9O1xuXG4gICAgLy8gZGV0ZWN0IHNvbGFuYV9yZXF1ZXN0QWNjb3VudHMgYW5kIHBpcGUgdG8gZW5hYmxlIGZvciBub3dcbiAgICBjb25zdCBkZXRlY3RBY2NvdW50UmVxdWVzdFByb3RvdHlwZU1vZGlmaWVyID0gbSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IGluUGFnZVByb3ZpZGVyW21dO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGluUGFnZVByb3ZpZGVyW21dID0gZnVuY3Rpb24gcHJvdmlkZXJGdW5jKHJlcXVlc3QsIGNiKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgcGFyYW1zID0gW11cbiAgICAgICAgfSA9IHJlcXVlc3Q7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwic29sYW5hX3JlcXVlc3RBY2NvdW50c1wiKSB7XG4gICAgICAgICAgaWYgKCFjYikgcmV0dXJuIHNlbGYubG9naW4oe1xuICAgICAgICAgICAgbG9naW5Qcm92aWRlcjogcGFyYW1zWzBdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5sb2dpbih7XG4gICAgICAgICAgICBsb2dpblByb3ZpZGVyOiBwYXJhbXNbMF1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL25vLWNhbGxiYWNrLWluLXByb21pc2VcbiAgICAgICAgICAudGhlbihyZXMgPT4gY2IobnVsbCwgcmVzKSlcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJvbWlzZS9uby1jYWxsYmFjay1pbi1wcm9taXNlXG4gICAgICAgICAgLmNhdGNoKGVyciA9PiBjYihlcnIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIFtyZXF1ZXN0LCBjYl0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gRGV0ZWN0cyBjYWxsIHRvIHNvbGFuYV9yZXF1ZXN0QWNjb3VudHMgaW4gcmVxdWVzdCAmIHNlbmRBc3luYyBhbmQgcGFzc2VzIHRvIGxvZ2luXG4gICAgZGV0ZWN0QWNjb3VudFJlcXVlc3RQcm90b3R5cGVNb2RpZmllcihcInJlcXVlc3RcIik7XG4gICAgZGV0ZWN0QWNjb3VudFJlcXVlc3RQcm90b3R5cGVNb2RpZmllcihcInNlbmRBc3luY1wiKTtcbiAgICBkZXRlY3RBY2NvdW50UmVxdWVzdFByb3RvdHlwZU1vZGlmaWVyKFwic2VuZFwiKTtcbiAgICBjb25zdCBwcm94aWVkSW5QYWdlUHJvdmlkZXIgPSBuZXcgUHJveHkoaW5QYWdlUHJvdmlkZXIsIHtcbiAgICAgIC8vIHN0cmFpZ2h0IHVwIGxpZSB0aGF0IHdlIGRlbGV0ZWQgdGhlIHByb3BlcnR5IHNvIHRoYXQgaXQgZG9lc24ndFxuICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgaW4gc3RyaWN0IG1vZGVcbiAgICAgIGRlbGV0ZVByb3BlcnR5OiAoKSA9PiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgcHJveGllZENvbW11bmljYXRpb25Qcm92aWRlciA9IG5ldyBQcm94eShjb21tdW5pY2F0aW9uUHJvdmlkZXIsIHtcbiAgICAgIC8vIHN0cmFpZ2h0IHVwIGxpZSB0aGF0IHdlIGRlbGV0ZWQgdGhlIHByb3BlcnR5IHNvIHRoYXQgaXQgZG9lc24ndFxuICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgaW4gc3RyaWN0IG1vZGVcbiAgICAgIGRlbGV0ZVByb3BlcnR5OiAoKSA9PiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5wcm92aWRlciA9IHByb3hpZWRJblBhZ2VQcm92aWRlcjtcbiAgICB0aGlzLmNvbW11bmljYXRpb25Qcm92aWRlciA9IHByb3hpZWRDb21tdW5pY2F0aW9uUHJvdmlkZXI7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW2luUGFnZVByb3ZpZGVyLl9pbml0aWFsaXplU3RhdGUoKSwgY29tbXVuaWNhdGlvblByb3ZpZGVyLl9pbml0aWFsaXplU3RhdGUoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm92aWRlclBhcmFtcyksIHt9LCB7XG4gICAgICBkYXBwU3RvcmFnZUtleTogdGhpcy5kYXBwU3RvcmFnZUtleSxcbiAgICAgIHRvcnVzQWxlcnRDb250YWluZXI6IHRoaXMudG9ydXNBbGVydENvbnRhaW5lcixcbiAgICAgIHRvcnVzSWZyYW1lOiB0aGlzLnRvcnVzSWZyYW1lXG4gICAgfSkpXSk7XG4gICAgbG9nLmRlYnVnKFwiVG9ydXMgLSBpbmplY3RlZCBwcm92aWRlclwiKTtcbiAgfVxufVxuXG5leHBvcnQgeyBCVVRUT05fUE9TSVRJT04sIExPR0lOX1BST1ZJREVSLCBQQVlNRU5UX1BST1ZJREVSLCBUT1JVU19CVUlMRF9FTlYsIFRvcnVzSW5QYWdlUHJvdmlkZXIsIFRvcnVzIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJfb2JqZWN0U3ByZWFkIiwiX2RlZmluZVByb3BlcnR5IiwiUHVibGljS2V5IiwiY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSIsIkNPTU1VTklDQVRJT05fSlJQQ19NRVRIT0RTIiwiQ09NTVVOSUNBVElPTl9OT1RJRklDQVRJT05TIiwiUFJPVklERVJfSlJQQ19NRVRIT0RTIiwiUFJPVklERVJfTk9USUZJQ0FUSU9OUyIsInNldEFQSUtleSIsIlNhZmVFdmVudEVtaXR0ZXIiLCJPYmplY3RNdWx0aXBsZXgiLCJjcmVhdGVTdHJlYW1NaWRkbGV3YXJlIiwiSlJQQ0VuZ2luZSIsImNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlIiwiZ2V0UnBjUHJvbWlzZUNhbGxiYWNrIiwiQmFzZVBvc3RNZXNzYWdlU3RyZWFtIiwiZXRoRXJyb3JzIiwiRXRoZXJldW1ScGNFcnJvciIsInB1bXAiLCJsb2dsZXZlbCIsImRlcXVhbCIsInZlcnNpb24iLCJpc1N0cmVhbSIsInN0cmVhbSIsInBpcGUiLCJpc1dyaXRhYmxlU3RyZWFtIiwid3JpdGFibGUiLCJfd3JpdGUiLCJfd3JpdGFibGVTdGF0ZSIsImlzUmVhZGFibGVTdHJlYW0iLCJyZWFkYWJsZSIsIl9yZWFkIiwiX3JlYWRhYmxlU3RhdGUiLCJpc0R1cGxleFN0cmVhbSIsIm1lc3NhZ2VzIiwiZXJyb3JzIiwiZGlzY29ubmVjdGVkIiwicGVybWFuZW50bHlEaXNjb25uZWN0ZWQiLCJ1bnN1cHBvcnRlZFN5bmMiLCJtZXRob2QiLCJpbnZhbGlkRHVwbGV4U3RyZWFtIiwiaW52YWxpZE9wdGlvbnMiLCJtYXhFdmVudExpc3RlbmVycyIsImludmFsaWRSZXF1ZXN0QXJncyIsImludmFsaWRSZXF1ZXN0TWV0aG9kIiwiaW52YWxpZFJlcXVlc3RQYXJhbXMiLCJpbnZhbGlkTG9nZ2VyT2JqZWN0IiwiaW52YWxpZExvZ2dlck1ldGhvZCIsImluZm8iLCJjb25uZWN0ZWQiLCJjaGFpbklkIiwid2FybmluZ3MiLCJQQVlNRU5UX1BST1ZJREVSIiwiTU9PTlBBWSIsIldZUkUiLCJSQU1QTkVUV09SSyIsIlhBTlBPT0wiLCJNRVJDVVJZTyIsIlRSQU5TQUsiLCJUT1JVU19CVUlMRF9FTlYiLCJQUk9EVUNUSU9OIiwiREVWRUxPUE1FTlQiLCJURVNUSU5HIiwiQlVUVE9OX1BPU0lUSU9OIiwiQk9UVE9NX0xFRlQiLCJUT1BfTEVGVCIsIkJPVFRPTV9SSUdIVCIsIlRPUF9SSUdIVCIsIkxPR0lOX1BST1ZJREVSIiwiR09PR0xFIiwiRkFDRUJPT0siLCJSRURESVQiLCJESVNDT1JEIiwiVFdJVENIIiwiQVBQTEUiLCJMSU5FIiwiR0lUSFVCIiwiS0FLQU8iLCJMSU5LRURJTiIsIlRXSVRURVIiLCJXRUlCTyIsIldFQ0hBVCIsIkVNQUlMX1BBU1NXT1JETEVTUyIsInRyYW5zbGF0aW9ucyIsImVuIiwiZW1iZWQiLCJjb250aW51ZSIsImFjdGlvblJlcXVpcmVkIiwicGVuZGluZ0FjdGlvbiIsImNvb2tpZXNSZXF1aXJlZCIsImVuYWJsZUNvb2tpZXMiLCJjbGlja0hlcmUiLCJkZSIsImphIiwia28iLCJ6aCIsImNvbmZpZ3VyYXRpb24iLCJzdXBwb3J0ZWRWZXJpZmllckxpc3QiLCJhcGkiLCJwcm9kVG9ydXNVcmwiLCJsb2NhbFN0b3JhZ2VLZXlQcmVmaXgiLCJsb2ciLCJnZXRMb2dnZXIiLCJjcmVhdGVFcnJvck1pZGRsZXdhcmUiLCJyZXEiLCJyZXMiLCJuZXh0IiwiZXJyb3IiLCJycGMiLCJpbnZhbGlkUmVxdWVzdCIsIm1lc3NhZ2UiLCJkYXRhIiwiZG9uZSIsImxvZ1N0cmVhbURpc2Nvbm5lY3RXYXJuaW5nIiwicmVtb3RlTGFiZWwiLCJlbWl0dGVyIiwid2FybmluZ01zZyIsInN0YWNrIiwid2FybiIsImxpc3RlbmVyQ291bnQiLCJlbWl0IiwiZ2V0V2luZG93SWQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsImdldFRvcnVzVXJsIiwiYnVpbGRFbnYiLCJ0b3J1c1VybCIsImxvZ0xldmVsIiwiZ2V0VXNlckxhbmd1YWdlIiwidXNlckxhbmd1YWdlIiwid2luZG93IiwibmF2aWdhdG9yIiwibGFuZ3VhZ2UiLCJ1c2VyTGFuZ3VhZ2VzIiwic3BsaXQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJGRUFUVVJFU19QUk9WSURFUl9DSEFOR0VfV0lORE9XIiwiaGVpZ2h0Iiwid2lkdGgiLCJGRUFUVVJFU19ERUZBVUxUX1dBTExFVF9XSU5ET1ciLCJGRUFUVVJFU19ERUZBVUxUX1BPUFVQX1dJTkRPVyIsIkZFQVRVUkVTX0NPTkZJUk1fV0lORE9XIiwic3RvcmFnZUF2YWlsYWJsZSIsInR5cGUiLCJzdG9yYWdlIiwieCIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiZSIsImNvZGUiLCJuYW1lIiwibGVuZ3RoIiwiZ2V0UG9wdXBGZWF0dXJlcyIsIl9yZWYiLCJ3IiwiaCIsImR1YWxTY3JlZW5MZWZ0Iiwic2NyZWVuTGVmdCIsInVuZGVmaW5lZCIsInNjcmVlblgiLCJkdWFsU2NyZWVuVG9wIiwic2NyZWVuVG9wIiwic2NyZWVuWSIsImlubmVyV2lkdGgiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudFdpZHRoIiwic2NyZWVuIiwiaW5uZXJIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzeXN0ZW1ab29tIiwibGVmdCIsImFicyIsInRvcCIsImZlYXR1cmVzIiwiQmFzZVByb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJjb25uZWN0aW9uU3RyZWFtIiwianNvblJwY1N0cmVhbU5hbWUiLCJFcnJvciIsImlzVG9ydXMiLCJzZXRNYXhMaXN0ZW5lcnMiLCJfaGFuZGxlQ29ubmVjdCIsImJpbmQiLCJfaGFuZGxlRGlzY29ubmVjdCIsIl9oYW5kbGVTdHJlYW1EaXNjb25uZWN0IiwiX3JwY1JlcXVlc3QiLCJfaW5pdGlhbGl6ZVN0YXRlIiwicmVxdWVzdCIsInNlbmRBc3luYyIsIm11eCIsImlnbm9yZVN0cmVhbSIsImpzb25ScGNDb25uZWN0aW9uIiwiY3JlYXRlU3RyZWFtIiwicnBjRW5naW5lIiwicHVzaCIsIm9yaWdpbiIsImxvY2F0aW9uIiwibWlkZGxld2FyZSIsIl9ycGNFbmdpbmUiLCJqc29uUnBjQ29ubmVjdGlvbkV2ZW50cyIsImV2ZW50cyIsImFyZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJwYXJhbXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInNlbmQiLCJwYXlsb2FkIiwiY2FsbGJhY2siLCJzdHJlYW1OYW1lIiwiaHRtbFRvRWxlbWVudCIsImh0bWwiLCJ0ZW1wbGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJ0cmltbWVkSHRtbCIsInRyaW0iLCJpbm5lckhUTUwiLCJjb250ZW50IiwiZmlyc3RDaGlsZCIsImlzTGVnYWN5VHJhbnNhY3Rpb25JbnN0YW5jZSIsInRyYW5zYWN0aW9uIiwiUG9wdXBIYW5kbGVyIiwidXJsIiwidGFyZ2V0IiwidGltZW91dCIsIndpbmRvd1RpbWVyIiwiaUNsb3NlZFdpbmRvdyIsIl9zZXR1cFRpbWVyIiwiTnVtYmVyIiwic2V0SW50ZXJ2YWwiLCJjbG9zZWQiLCJjbGVhckludGVydmFsIiwic2V0VGltZW91dCIsIm9wZW4iLCJocmVmIiwiZm9jdXMiLCJjbG9zZSIsInJlZGlyZWN0IiwibG9jYXRpb25SZXBsYWNlT25SZWRpcmVjdCIsInJlcGxhY2UiLCJUb3J1c0NvbW11bmljYXRpb25Qcm92aWRlciIsIl9zdGF0ZSIsIl9kZWZhdWx0U3RhdGUiLCJkYXBwU3RvcmFnZUtleSIsImxhbmd1YWdlVHJhbnNsYXRpb25zIiwiZW1iZWRUcmFuc2xhdGlvbnMiLCJ3aW5kb3dSZWZzIiwib24iLCJpc0Nvbm5lY3RlZCIsIm5vdGlmaWNhdGlvbkhhbmRsZXIiLCJJRlJBTUVfU1RBVFVTIiwiaXNGdWxsU2NyZWVuIiwicmlkIiwiX2Rpc3BsYXlJZnJhbWUiLCJpc0Z1bGwiLCJ3aW5kb3dJZCIsIl9jcmVhdGVQb3B1cEJsb2NrQWxlcnQiLCJDTE9TRV9XSU5ET1ciLCJfaGFuZGxlQ2xvc2VXaW5kb3ciLCJVU0VSX0xPR0dFRF9JTiIsImN1cnJlbnRMb2dpblByb3ZpZGVyIiwiaXNMb2dnZWRJbiIsIlVTRVJfTE9HR0VEX09VVCIsImlzSUZyYW1lRnVsbFNjcmVlbiIsInRvcnVzQWxlcnRDb250YWluZXIiLCJ0b3J1c0lmcmFtZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJHRVRfUFJPVklERVJfU1RBVEUiLCJpbml0aWFsaXplZCIsIl9oYW5kbGVXaW5kb3ciLCJhcmd1bWVudHMiLCJmaW5hbFVybCIsIlVSTCIsImhhc2giLCJoYW5kbGVkV2luZG93Iiwib25jZSIsIkNMT1NFRF9XSU5ET1ciLCJzdHlsZSIsImRpc3BsYXkiLCJ0b3J1c1dpZGdldFZpc2liaWxpdHkiLCJidXR0b25Qb3NpdGlvbiIsInJpZ2h0IiwiYm90dG9tIiwiYXNzaWduIiwiaGlkZVRvcnVzQnV0dG9uIiwic2hvd1RvcnVzQnV0dG9uIiwiY2IiLCJfcGF5bG9hZCIsImpzb25ycGMiLCJ0cnlXaW5kb3dIYW5kbGUiLCJkZWJ1ZyIsImlzUmVjb3ZlcmFibGUiLCJlcnJvck1lc3NhZ2UiLCJpc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkIiwibG9nb1VybCIsImdldExvZ29VcmwiLCJ0b3J1c0FsZXJ0Iiwic3VjY2Vzc0FsZXJ0IiwiYnRuQ29udGFpbmVyIiwiYXBwZW5kQ2hpbGQiLCJiaW5kT25Mb2FkIiwicmVtb3ZlIiwiY2hpbGRyZW4iLCJhdHRhY2hPbkxvYWQiLCJoYXNFbWl0dGVkQ29ubmVjdGlvbiIsIlRvcnVzSW5QYWdlUHJvdmlkZXIiLCJzZWxlY3RlZEFkZHJlc3MiLCJfaGFuZGxlQWNjb3VudHNDaGFuZ2VkIiwiX2hhbmRsZUNoYWluQ2hhbmdlZCIsIl9oYW5kbGVVbmxvY2tTdGF0ZUNoYW5nZWQiLCJqc29uUnBjTm90aWZpY2F0aW9uSGFuZGxlciIsIkFDQ09VTlRTX0NIQU5HRUQiLCJVTkxPQ0tfU1RBVEVfQ0hBTkdFRCIsIkNIQUlOX0NIQU5HRUQiLCJhY2NvdW50cyIsImlzVW5sb2NrZWQiLCJpc0ludGVybmFsIiwiZXJyIiwicmVzdWx0IiwiaGFuZGxlIiwiaXNFdGhBY2NvdW50cyIsImZpbmFsQWNjb3VudHMiLCJhY2NvdW50IiwiaW1nRXhpc3RzIiwiaW1nIiwib25sb2FkIiwib25lcnJvciIsInNyYyIsImdldFNpdGVOYW1lIiwic2l0ZU5hbWUiLCJxdWVyeVNlbGVjdG9yIiwibWV0YVRpdGxlIiwidGl0bGUiLCJob3N0bmFtZSIsImdldFNpdGVJY29uIiwiaWNvbiIsImZyb20iLCJxdWVyeVNlbGVjdG9yQWxsIiwiZmluZCIsIl9pY29uIiwiQm9vbGVhbiIsImdldFNpdGVNZXRhZGF0YSIsIlBST1ZJREVSX1VOU0FGRV9NRVRIT0RTIiwiQ09NTVVOSUNBVElPTl9VTlNBRkVfTUVUSE9EUyIsIlNFVF9QUk9WSURFUiIsImlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwicHJlTG9hZElmcmFtZSIsInRvcnVzSWZyYW1lSHRtbCIsImNyb3NzT3JpZ2luIiwicmVsIiwicmVsTGlzdCIsInN1cHBvcnRzIiwiaGVhZCIsIlRvcnVzIiwibW9kYWxaSW5kZXgiLCJpc0luaXRpYWxpemVkIiwicmVxdWVzdGVkTG9naW5Qcm92aWRlciIsImFsZXJ0WkluZGV4IiwiY29tbXVuaWNhdGlvblByb3ZpZGVyIiwiaW5pdCIsImVuYWJsZUxvZ2dpbmciLCJuZXR3b3JrIiwidXNlTG9jYWxTdG9yYWdlIiwiYXBpS2V5IiwiZXh0cmFQYXJhbXMiLCJ3aGl0ZUxhYmVsIiwiZW5hYmxlQWxsIiwic2V0RGVmYXVsdExldmVsIiwiZGlzYWJsZUFsbCIsImhhbmRsZURhcHBTdG9yYWdlS2V5IiwidG9ydXNJZnJhbWVVcmwiLCJwYXRobmFtZSIsImVuZHNXaXRoIiwiaGFzaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImFwcGVuZCIsInN0eWxlTGluayIsImRhcHBNZXRhZGF0YSIsImNvbnRlbnRXaW5kb3ciLCJwb3N0TWVzc2FnZSIsIl9zZXR1cFdlYjMiLCJ0b3B1cEhpZGUiLCJpc1RvcHVwSGlkZGVuIiwidG9ydXMiLCJib2R5IiwibG9naW4iLCJsb2dpblByb3ZpZGVyIiwicHJvdmlkZXIiLCJsb2dpbl9oaW50IiwibG9naW5XaXRoUHJpdmF0ZUtleSIsImxvZ2luUGFyYW1zIiwicHJpdmF0ZUtleSIsInVzZXJJbmZvIiwic3VjY2VzcyIsImxvZ291dCIsIkxPR09VVCIsImNsZWFuVXAiLCJjbGVhckluaXQiLCJpc0VsZW1lbnQiLCJlbGVtZW50IiwiRWxlbWVudCIsIkRvY3VtZW50IiwiY29udGFpbnMiLCJzZXRQcm92aWRlciIsInNob3dXYWxsZXQiLCJwYXRoIiwiaW5zdGFuY2VJZCIsIldBTExFVF9JTlNUQU5DRV9JRCIsImZpbmFsUGF0aCIsInNlYXJjaFBhcmFtcyIsImtleXMiLCJmb3JFYWNoIiwid2FsbGV0V2luZG93IiwiZ2V0VXNlckluZm8iLCJ1c2VySW5mb1Jlc3BvbnNlIiwiVVNFUl9JTkZPIiwiaW5pdGlhdGVUb3B1cCIsInRvcHVwUmVzcG9uc2UiLCJUT1BVUCIsImdldEFjY291bnRzIiwicmVzcG9uc2UiLCJzZW5kVHJhbnNhY3Rpb24iLCJpc0xlZ2FjeVRyYW5zYWN0aW9uIiwic2VyaWFsaXplIiwicmVxdWlyZUFsbFNpZ25hdHVyZXMiLCJCdWZmZXIiLCJzaWduQW5kU2VuZFRyYW5zYWN0aW9uIiwib3B0aW9ucyIsInNpZ25hdHVyZSIsInNpZ25UcmFuc2FjdGlvbiIsInNlcmlhbGl6ZU1lc3NhZ2UiLCJtZXNzYWdlT25seSIsInBhcnNlZCIsIkpTT04iLCJwYXJzZSIsInB1YmxpY0tleSIsImFkZFNpZ25hdHVyZSIsInNpZ25BbGxUcmFuc2FjdGlvbnMiLCJ0cmFuc2FjdGlvbnMiLCJlbmNvZGVkTWVzc2FnZSIsIm1hcCIsInR4IiwicmVzcG9uc2VzIiwic2lnbmF0dXJlcyIsIml0ZW0iLCJpZHgiLCJzaWduTWVzc2FnZSIsImdldEdhc2xlc3NQdWJsaWNLZXkiLCJsb2NhbFN0b3JhZ2VLZXkiLCJzdG9yZWRLZXkiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiZ2VuZXJhdGVkS2V5IiwicHJvdmlkZXJQYXJhbXMiLCJwcm92aWRlclN0cmVhbSIsInRhcmdldFdpbmRvdyIsImNvbW11bmljYXRpb25TdHJlYW0iLCJpblBhZ2VQcm92aWRlciIsImluY2x1ZGVzIiwiZGV0ZWN0QWNjb3VudFJlcXVlc3RQcm90b3R5cGVNb2RpZmllciIsIm0iLCJvcmlnaW5hbE1ldGhvZCIsInNlbGYiLCJwcm92aWRlckZ1bmMiLCJ0aGVuIiwiY2F0Y2giLCJhcHBseSIsInByb3hpZWRJblBhZ2VQcm92aWRlciIsIlByb3h5IiwiZGVsZXRlUHJvcGVydHkiLCJwcm94aWVkQ29tbXVuaWNhdGlvblByb3ZpZGVyIiwiYWxsIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js\n");

/***/ })

};
;