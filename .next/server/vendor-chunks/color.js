/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/color";
exports.ids = ["vendor-chunks/color"];
exports.modules = {

/***/ "(ssr)/./node_modules/color/index.js":
/*!*************************************!*\
  !*** ./node_modules/color/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const colorString = __webpack_require__(/*! color-string */ \"(ssr)/./node_modules/color-string/index.js\");\nconst convert = __webpack_require__(/*! color-convert */ \"(ssr)/./node_modules/color-convert/index.js\");\nconst skippedModels = [\n    // To be honest, I don't really feel like keyword belongs in color convert, but eh.\n    \"keyword\",\n    // Gray conflicts with some method names, and has its own method defined.\n    \"gray\",\n    // Shouldn't really be in color-convert either...\n    \"hex\"\n];\nconst hashedModelKeys = {};\nfor (const model of Object.keys(convert)){\n    hashedModelKeys[[\n        ...convert[model].labels\n    ].sort().join(\"\")] = model;\n}\nconst limiters = {};\nfunction Color(object, model) {\n    if (!(this instanceof Color)) {\n        return new Color(object, model);\n    }\n    if (model && model in skippedModels) {\n        model = null;\n    }\n    if (model && !(model in convert)) {\n        throw new Error(\"Unknown model: \" + model);\n    }\n    let i;\n    let channels;\n    if (object == null) {\n        this.model = \"rgb\";\n        this.color = [\n            0,\n            0,\n            0\n        ];\n        this.valpha = 1;\n    } else if (object instanceof Color) {\n        this.model = object.model;\n        this.color = [\n            ...object.color\n        ];\n        this.valpha = object.valpha;\n    } else if (typeof object === \"string\") {\n        const result = colorString.get(object);\n        if (result === null) {\n            throw new Error(\"Unable to parse color from string: \" + object);\n        }\n        this.model = result.model;\n        channels = convert[this.model].channels;\n        this.color = result.value.slice(0, channels);\n        this.valpha = typeof result.value[channels] === \"number\" ? result.value[channels] : 1;\n    } else if (object.length > 0) {\n        this.model = model || \"rgb\";\n        channels = convert[this.model].channels;\n        const newArray = Array.prototype.slice.call(object, 0, channels);\n        this.color = zeroArray(newArray, channels);\n        this.valpha = typeof object[channels] === \"number\" ? object[channels] : 1;\n    } else if (typeof object === \"number\") {\n        // This is always RGB - can be converted later on.\n        this.model = \"rgb\";\n        this.color = [\n            object >> 16 & 0xFF,\n            object >> 8 & 0xFF,\n            object & 0xFF\n        ];\n        this.valpha = 1;\n    } else {\n        this.valpha = 1;\n        const keys = Object.keys(object);\n        if (\"alpha\" in object) {\n            keys.splice(keys.indexOf(\"alpha\"), 1);\n            this.valpha = typeof object.alpha === \"number\" ? object.alpha : 0;\n        }\n        const hashedKeys = keys.sort().join(\"\");\n        if (!(hashedKeys in hashedModelKeys)) {\n            throw new Error(\"Unable to parse color from object: \" + JSON.stringify(object));\n        }\n        this.model = hashedModelKeys[hashedKeys];\n        const { labels } = convert[this.model];\n        const color = [];\n        for(i = 0; i < labels.length; i++){\n            color.push(object[labels[i]]);\n        }\n        this.color = zeroArray(color);\n    }\n    // Perform limitations (clamping, etc.)\n    if (limiters[this.model]) {\n        channels = convert[this.model].channels;\n        for(i = 0; i < channels; i++){\n            const limit = limiters[this.model][i];\n            if (limit) {\n                this.color[i] = limit(this.color[i]);\n            }\n        }\n    }\n    this.valpha = Math.max(0, Math.min(1, this.valpha));\n    if (Object.freeze) {\n        Object.freeze(this);\n    }\n}\nColor.prototype = {\n    toString () {\n        return this.string();\n    },\n    toJSON () {\n        return this[this.model]();\n    },\n    string (places) {\n        let self = this.model in colorString.to ? this : this.rgb();\n        self = self.round(typeof places === \"number\" ? places : 1);\n        const args = self.valpha === 1 ? self.color : [\n            ...self.color,\n            this.valpha\n        ];\n        return colorString.to[self.model](args);\n    },\n    percentString (places) {\n        const self = this.rgb().round(typeof places === \"number\" ? places : 1);\n        const args = self.valpha === 1 ? self.color : [\n            ...self.color,\n            this.valpha\n        ];\n        return colorString.to.rgb.percent(args);\n    },\n    array () {\n        return this.valpha === 1 ? [\n            ...this.color\n        ] : [\n            ...this.color,\n            this.valpha\n        ];\n    },\n    object () {\n        const result = {};\n        const { channels } = convert[this.model];\n        const { labels } = convert[this.model];\n        for(let i = 0; i < channels; i++){\n            result[labels[i]] = this.color[i];\n        }\n        if (this.valpha !== 1) {\n            result.alpha = this.valpha;\n        }\n        return result;\n    },\n    unitArray () {\n        const rgb = this.rgb().color;\n        rgb[0] /= 255;\n        rgb[1] /= 255;\n        rgb[2] /= 255;\n        if (this.valpha !== 1) {\n            rgb.push(this.valpha);\n        }\n        return rgb;\n    },\n    unitObject () {\n        const rgb = this.rgb().object();\n        rgb.r /= 255;\n        rgb.g /= 255;\n        rgb.b /= 255;\n        if (this.valpha !== 1) {\n            rgb.alpha = this.valpha;\n        }\n        return rgb;\n    },\n    round (places) {\n        places = Math.max(places || 0, 0);\n        return new Color([\n            ...this.color.map(roundToPlace(places)),\n            this.valpha\n        ], this.model);\n    },\n    alpha (value) {\n        if (value !== undefined) {\n            return new Color([\n                ...this.color,\n                Math.max(0, Math.min(1, value))\n            ], this.model);\n        }\n        return this.valpha;\n    },\n    // Rgb\n    red: getset(\"rgb\", 0, maxfn(255)),\n    green: getset(\"rgb\", 1, maxfn(255)),\n    blue: getset(\"rgb\", 2, maxfn(255)),\n    hue: getset([\n        \"hsl\",\n        \"hsv\",\n        \"hsl\",\n        \"hwb\",\n        \"hcg\"\n    ], 0, (value)=>(value % 360 + 360) % 360),\n    saturationl: getset(\"hsl\", 1, maxfn(100)),\n    lightness: getset(\"hsl\", 2, maxfn(100)),\n    saturationv: getset(\"hsv\", 1, maxfn(100)),\n    value: getset(\"hsv\", 2, maxfn(100)),\n    chroma: getset(\"hcg\", 1, maxfn(100)),\n    gray: getset(\"hcg\", 2, maxfn(100)),\n    white: getset(\"hwb\", 1, maxfn(100)),\n    wblack: getset(\"hwb\", 2, maxfn(100)),\n    cyan: getset(\"cmyk\", 0, maxfn(100)),\n    magenta: getset(\"cmyk\", 1, maxfn(100)),\n    yellow: getset(\"cmyk\", 2, maxfn(100)),\n    black: getset(\"cmyk\", 3, maxfn(100)),\n    x: getset(\"xyz\", 0, maxfn(95.047)),\n    y: getset(\"xyz\", 1, maxfn(100)),\n    z: getset(\"xyz\", 2, maxfn(108.833)),\n    l: getset(\"lab\", 0, maxfn(100)),\n    a: getset(\"lab\", 1),\n    b: getset(\"lab\", 2),\n    keyword (value) {\n        if (value !== undefined) {\n            return new Color(value);\n        }\n        return convert[this.model].keyword(this.color);\n    },\n    hex (value) {\n        if (value !== undefined) {\n            return new Color(value);\n        }\n        return colorString.to.hex(this.rgb().round().color);\n    },\n    hexa (value) {\n        if (value !== undefined) {\n            return new Color(value);\n        }\n        const rgbArray = this.rgb().round().color;\n        let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();\n        if (alphaHex.length === 1) {\n            alphaHex = \"0\" + alphaHex;\n        }\n        return colorString.to.hex(rgbArray) + alphaHex;\n    },\n    rgbNumber () {\n        const rgb = this.rgb().color;\n        return (rgb[0] & 0xFF) << 16 | (rgb[1] & 0xFF) << 8 | rgb[2] & 0xFF;\n    },\n    luminosity () {\n        // http://www.w3.org/TR/WCAG20/#relativeluminancedef\n        const rgb = this.rgb().color;\n        const lum = [];\n        for (const [i, element] of rgb.entries()){\n            const chan = element / 255;\n            lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;\n        }\n        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n    },\n    contrast (color2) {\n        // http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n        const lum1 = this.luminosity();\n        const lum2 = color2.luminosity();\n        if (lum1 > lum2) {\n            return (lum1 + 0.05) / (lum2 + 0.05);\n        }\n        return (lum2 + 0.05) / (lum1 + 0.05);\n    },\n    level (color2) {\n        // https://www.w3.org/TR/WCAG/#contrast-enhanced\n        const contrastRatio = this.contrast(color2);\n        if (contrastRatio >= 7) {\n            return \"AAA\";\n        }\n        return contrastRatio >= 4.5 ? \"AA\" : \"\";\n    },\n    isDark () {\n        // YIQ equation from http://24ways.org/2010/calculating-color-contrast\n        const rgb = this.rgb().color;\n        const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 10000;\n        return yiq < 128;\n    },\n    isLight () {\n        return !this.isDark();\n    },\n    negate () {\n        const rgb = this.rgb();\n        for(let i = 0; i < 3; i++){\n            rgb.color[i] = 255 - rgb.color[i];\n        }\n        return rgb;\n    },\n    lighten (ratio) {\n        const hsl = this.hsl();\n        hsl.color[2] += hsl.color[2] * ratio;\n        return hsl;\n    },\n    darken (ratio) {\n        const hsl = this.hsl();\n        hsl.color[2] -= hsl.color[2] * ratio;\n        return hsl;\n    },\n    saturate (ratio) {\n        const hsl = this.hsl();\n        hsl.color[1] += hsl.color[1] * ratio;\n        return hsl;\n    },\n    desaturate (ratio) {\n        const hsl = this.hsl();\n        hsl.color[1] -= hsl.color[1] * ratio;\n        return hsl;\n    },\n    whiten (ratio) {\n        const hwb = this.hwb();\n        hwb.color[1] += hwb.color[1] * ratio;\n        return hwb;\n    },\n    blacken (ratio) {\n        const hwb = this.hwb();\n        hwb.color[2] += hwb.color[2] * ratio;\n        return hwb;\n    },\n    grayscale () {\n        // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n        const rgb = this.rgb().color;\n        const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n        return Color.rgb(value, value, value);\n    },\n    fade (ratio) {\n        return this.alpha(this.valpha - this.valpha * ratio);\n    },\n    opaquer (ratio) {\n        return this.alpha(this.valpha + this.valpha * ratio);\n    },\n    rotate (degrees) {\n        const hsl = this.hsl();\n        let hue = hsl.color[0];\n        hue = (hue + degrees) % 360;\n        hue = hue < 0 ? 360 + hue : hue;\n        hsl.color[0] = hue;\n        return hsl;\n    },\n    mix (mixinColor, weight) {\n        // Ported from sass implementation in C\n        // https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n        if (!mixinColor || !mixinColor.rgb) {\n            throw new Error('Argument to \"mix\" was not a Color instance, but rather an instance of ' + typeof mixinColor);\n        }\n        const color1 = mixinColor.rgb();\n        const color2 = this.rgb();\n        const p = weight === undefined ? 0.5 : weight;\n        const w = 2 * p - 1;\n        const a = color1.alpha() - color2.alpha();\n        const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;\n        const w2 = 1 - w1;\n        return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));\n    }\n};\n// Model conversion methods and static constructors\nfor (const model of Object.keys(convert)){\n    if (skippedModels.includes(model)) {\n        continue;\n    }\n    const { channels } = convert[model];\n    // Conversion methods\n    Color.prototype[model] = function(...args) {\n        if (this.model === model) {\n            return new Color(this);\n        }\n        if (args.length > 0) {\n            return new Color(args, model);\n        }\n        return new Color([\n            ...assertArray(convert[this.model][model].raw(this.color)),\n            this.valpha\n        ], model);\n    };\n    // 'static' construction methods\n    Color[model] = function(...args) {\n        let color = args[0];\n        if (typeof color === \"number\") {\n            color = zeroArray(args, channels);\n        }\n        return new Color(color, model);\n    };\n}\nfunction roundTo(number, places) {\n    return Number(number.toFixed(places));\n}\nfunction roundToPlace(places) {\n    return function(number) {\n        return roundTo(number, places);\n    };\n}\nfunction getset(model, channel, modifier) {\n    model = Array.isArray(model) ? model : [\n        model\n    ];\n    for (const m of model){\n        (limiters[m] || (limiters[m] = []))[channel] = modifier;\n    }\n    model = model[0];\n    return function(value) {\n        let result;\n        if (value !== undefined) {\n            if (modifier) {\n                value = modifier(value);\n            }\n            result = this[model]();\n            result.color[channel] = value;\n            return result;\n        }\n        result = this[model]().color[channel];\n        if (modifier) {\n            result = modifier(result);\n        }\n        return result;\n    };\n}\nfunction maxfn(max) {\n    return function(v) {\n        return Math.max(0, Math.min(max, v));\n    };\n}\nfunction assertArray(value) {\n    return Array.isArray(value) ? value : [\n        value\n    ];\n}\nfunction zeroArray(array, length) {\n    for(let i = 0; i < length; i++){\n        if (typeof array[i] !== \"number\") {\n            array[i] = 0;\n        }\n    }\n    return array;\n}\nmodule.exports = Color;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ci9pbmRleC5qcz82YWVmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbG9yU3RyaW5nID0gcmVxdWlyZSgnY29sb3Itc3RyaW5nJyk7XG5jb25zdCBjb252ZXJ0ID0gcmVxdWlyZSgnY29sb3ItY29udmVydCcpO1xuXG5jb25zdCBza2lwcGVkTW9kZWxzID0gW1xuXHQvLyBUbyBiZSBob25lc3QsIEkgZG9uJ3QgcmVhbGx5IGZlZWwgbGlrZSBrZXl3b3JkIGJlbG9uZ3MgaW4gY29sb3IgY29udmVydCwgYnV0IGVoLlxuXHQna2V5d29yZCcsXG5cblx0Ly8gR3JheSBjb25mbGljdHMgd2l0aCBzb21lIG1ldGhvZCBuYW1lcywgYW5kIGhhcyBpdHMgb3duIG1ldGhvZCBkZWZpbmVkLlxuXHQnZ3JheScsXG5cblx0Ly8gU2hvdWxkbid0IHJlYWxseSBiZSBpbiBjb2xvci1jb252ZXJ0IGVpdGhlci4uLlxuXHQnaGV4Jyxcbl07XG5cbmNvbnN0IGhhc2hlZE1vZGVsS2V5cyA9IHt9O1xuZm9yIChjb25zdCBtb2RlbCBvZiBPYmplY3Qua2V5cyhjb252ZXJ0KSkge1xuXHRoYXNoZWRNb2RlbEtleXNbWy4uLmNvbnZlcnRbbW9kZWxdLmxhYmVsc10uc29ydCgpLmpvaW4oJycpXSA9IG1vZGVsO1xufVxuXG5jb25zdCBsaW1pdGVycyA9IHt9O1xuXG5mdW5jdGlvbiBDb2xvcihvYmplY3QsIG1vZGVsKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb2xvcikpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKG9iamVjdCwgbW9kZWwpO1xuXHR9XG5cblx0aWYgKG1vZGVsICYmIG1vZGVsIGluIHNraXBwZWRNb2RlbHMpIHtcblx0XHRtb2RlbCA9IG51bGw7XG5cdH1cblxuXHRpZiAobW9kZWwgJiYgIShtb2RlbCBpbiBjb252ZXJ0KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBtb2RlbDogJyArIG1vZGVsKTtcblx0fVxuXG5cdGxldCBpO1xuXHRsZXQgY2hhbm5lbHM7XG5cblx0aWYgKG9iamVjdCA9PSBudWxsKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcblx0XHR0aGlzLm1vZGVsID0gJ3JnYic7XG5cdFx0dGhpcy5jb2xvciA9IFswLCAwLCAwXTtcblx0XHR0aGlzLnZhbHBoYSA9IDE7XG5cdH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgQ29sb3IpIHtcblx0XHR0aGlzLm1vZGVsID0gb2JqZWN0Lm1vZGVsO1xuXHRcdHRoaXMuY29sb3IgPSBbLi4ub2JqZWN0LmNvbG9yXTtcblx0XHR0aGlzLnZhbHBoYSA9IG9iamVjdC52YWxwaGE7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcblx0XHRjb25zdCByZXN1bHQgPSBjb2xvclN0cmluZy5nZXQob2JqZWN0KTtcblx0XHRpZiAocmVzdWx0ID09PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBjb2xvciBmcm9tIHN0cmluZzogJyArIG9iamVjdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5tb2RlbCA9IHJlc3VsdC5tb2RlbDtcblx0XHRjaGFubmVscyA9IGNvbnZlcnRbdGhpcy5tb2RlbF0uY2hhbm5lbHM7XG5cdFx0dGhpcy5jb2xvciA9IHJlc3VsdC52YWx1ZS5zbGljZSgwLCBjaGFubmVscyk7XG5cdFx0dGhpcy52YWxwaGEgPSB0eXBlb2YgcmVzdWx0LnZhbHVlW2NoYW5uZWxzXSA9PT0gJ251bWJlcicgPyByZXN1bHQudmFsdWVbY2hhbm5lbHNdIDogMTtcblx0fSBlbHNlIGlmIChvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdHRoaXMubW9kZWwgPSBtb2RlbCB8fCAncmdiJztcblx0XHRjaGFubmVscyA9IGNvbnZlcnRbdGhpcy5tb2RlbF0uY2hhbm5lbHM7XG5cdFx0Y29uc3QgbmV3QXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmplY3QsIDAsIGNoYW5uZWxzKTtcblx0XHR0aGlzLmNvbG9yID0gemVyb0FycmF5KG5ld0FycmF5LCBjaGFubmVscyk7XG5cdFx0dGhpcy52YWxwaGEgPSB0eXBlb2Ygb2JqZWN0W2NoYW5uZWxzXSA9PT0gJ251bWJlcicgPyBvYmplY3RbY2hhbm5lbHNdIDogMTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnbnVtYmVyJykge1xuXHRcdC8vIFRoaXMgaXMgYWx3YXlzIFJHQiAtIGNhbiBiZSBjb252ZXJ0ZWQgbGF0ZXIgb24uXG5cdFx0dGhpcy5tb2RlbCA9ICdyZ2InO1xuXHRcdHRoaXMuY29sb3IgPSBbXG5cdFx0XHQob2JqZWN0ID4+IDE2KSAmIDB4RkYsXG5cdFx0XHQob2JqZWN0ID4+IDgpICYgMHhGRixcblx0XHRcdG9iamVjdCAmIDB4RkYsXG5cdFx0XTtcblx0XHR0aGlzLnZhbHBoYSA9IDE7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy52YWxwaGEgPSAxO1xuXG5cdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cdFx0aWYgKCdhbHBoYScgaW4gb2JqZWN0KSB7XG5cdFx0XHRrZXlzLnNwbGljZShrZXlzLmluZGV4T2YoJ2FscGhhJyksIDEpO1xuXHRcdFx0dGhpcy52YWxwaGEgPSB0eXBlb2Ygb2JqZWN0LmFscGhhID09PSAnbnVtYmVyJyA/IG9iamVjdC5hbHBoYSA6IDA7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaGFzaGVkS2V5cyA9IGtleXMuc29ydCgpLmpvaW4oJycpO1xuXHRcdGlmICghKGhhc2hlZEtleXMgaW4gaGFzaGVkTW9kZWxLZXlzKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgY29sb3IgZnJvbSBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShvYmplY3QpKTtcblx0XHR9XG5cblx0XHR0aGlzLm1vZGVsID0gaGFzaGVkTW9kZWxLZXlzW2hhc2hlZEtleXNdO1xuXG5cdFx0Y29uc3Qge2xhYmVsc30gPSBjb252ZXJ0W3RoaXMubW9kZWxdO1xuXHRcdGNvbnN0IGNvbG9yID0gW107XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29sb3IucHVzaChvYmplY3RbbGFiZWxzW2ldXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jb2xvciA9IHplcm9BcnJheShjb2xvcik7XG5cdH1cblxuXHQvLyBQZXJmb3JtIGxpbWl0YXRpb25zIChjbGFtcGluZywgZXRjLilcblx0aWYgKGxpbWl0ZXJzW3RoaXMubW9kZWxdKSB7XG5cdFx0Y2hhbm5lbHMgPSBjb252ZXJ0W3RoaXMubW9kZWxdLmNoYW5uZWxzO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBjaGFubmVsczsgaSsrKSB7XG5cdFx0XHRjb25zdCBsaW1pdCA9IGxpbWl0ZXJzW3RoaXMubW9kZWxdW2ldO1xuXHRcdFx0aWYgKGxpbWl0KSB7XG5cdFx0XHRcdHRoaXMuY29sb3JbaV0gPSBsaW1pdCh0aGlzLmNvbG9yW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR0aGlzLnZhbHBoYSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHRoaXMudmFscGhhKSk7XG5cblx0aWYgKE9iamVjdC5mcmVlemUpIHtcblx0XHRPYmplY3QuZnJlZXplKHRoaXMpO1xuXHR9XG59XG5cbkNvbG9yLnByb3RvdHlwZSA9IHtcblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RyaW5nKCk7XG5cdH0sXG5cblx0dG9KU09OKCkge1xuXHRcdHJldHVybiB0aGlzW3RoaXMubW9kZWxdKCk7XG5cdH0sXG5cblx0c3RyaW5nKHBsYWNlcykge1xuXHRcdGxldCBzZWxmID0gdGhpcy5tb2RlbCBpbiBjb2xvclN0cmluZy50byA/IHRoaXMgOiB0aGlzLnJnYigpO1xuXHRcdHNlbGYgPSBzZWxmLnJvdW5kKHR5cGVvZiBwbGFjZXMgPT09ICdudW1iZXInID8gcGxhY2VzIDogMSk7XG5cdFx0Y29uc3QgYXJncyA9IHNlbGYudmFscGhhID09PSAxID8gc2VsZi5jb2xvciA6IFsuLi5zZWxmLmNvbG9yLCB0aGlzLnZhbHBoYV07XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnRvW3NlbGYubW9kZWxdKGFyZ3MpO1xuXHR9LFxuXG5cdHBlcmNlbnRTdHJpbmcocGxhY2VzKSB7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXMucmdiKCkucm91bmQodHlwZW9mIHBsYWNlcyA9PT0gJ251bWJlcicgPyBwbGFjZXMgOiAxKTtcblx0XHRjb25zdCBhcmdzID0gc2VsZi52YWxwaGEgPT09IDEgPyBzZWxmLmNvbG9yIDogWy4uLnNlbGYuY29sb3IsIHRoaXMudmFscGhhXTtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcudG8ucmdiLnBlcmNlbnQoYXJncyk7XG5cdH0sXG5cblx0YXJyYXkoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFscGhhID09PSAxID8gWy4uLnRoaXMuY29sb3JdIDogWy4uLnRoaXMuY29sb3IsIHRoaXMudmFscGhhXTtcblx0fSxcblxuXHRvYmplY3QoKSB7XG5cdFx0Y29uc3QgcmVzdWx0ID0ge307XG5cdFx0Y29uc3Qge2NoYW5uZWxzfSA9IGNvbnZlcnRbdGhpcy5tb2RlbF07XG5cdFx0Y29uc3Qge2xhYmVsc30gPSBjb252ZXJ0W3RoaXMubW9kZWxdO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGFubmVsczsgaSsrKSB7XG5cdFx0XHRyZXN1bHRbbGFiZWxzW2ldXSA9IHRoaXMuY29sb3JbaV07XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMudmFscGhhICE9PSAxKSB7XG5cdFx0XHRyZXN1bHQuYWxwaGEgPSB0aGlzLnZhbHBoYTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdHVuaXRBcnJheSgpIHtcblx0XHRjb25zdCByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXHRcdHJnYlswXSAvPSAyNTU7XG5cdFx0cmdiWzFdIC89IDI1NTtcblx0XHRyZ2JbMl0gLz0gMjU1O1xuXG5cdFx0aWYgKHRoaXMudmFscGhhICE9PSAxKSB7XG5cdFx0XHRyZ2IucHVzaCh0aGlzLnZhbHBoYSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJnYjtcblx0fSxcblxuXHR1bml0T2JqZWN0KCkge1xuXHRcdGNvbnN0IHJnYiA9IHRoaXMucmdiKCkub2JqZWN0KCk7XG5cdFx0cmdiLnIgLz0gMjU1O1xuXHRcdHJnYi5nIC89IDI1NTtcblx0XHRyZ2IuYiAvPSAyNTU7XG5cblx0XHRpZiAodGhpcy52YWxwaGEgIT09IDEpIHtcblx0XHRcdHJnYi5hbHBoYSA9IHRoaXMudmFscGhhO1xuXHRcdH1cblxuXHRcdHJldHVybiByZ2I7XG5cdH0sXG5cblx0cm91bmQocGxhY2VzKSB7XG5cdFx0cGxhY2VzID0gTWF0aC5tYXgocGxhY2VzIHx8IDAsIDApO1xuXHRcdHJldHVybiBuZXcgQ29sb3IoWy4uLnRoaXMuY29sb3IubWFwKHJvdW5kVG9QbGFjZShwbGFjZXMpKSwgdGhpcy52YWxwaGFdLCB0aGlzLm1vZGVsKTtcblx0fSxcblxuXHRhbHBoYSh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKFsuLi50aGlzLmNvbG9yLCBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB2YWx1ZSkpXSwgdGhpcy5tb2RlbCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMudmFscGhhO1xuXHR9LFxuXG5cdC8vIFJnYlxuXHRyZWQ6IGdldHNldCgncmdiJywgMCwgbWF4Zm4oMjU1KSksXG5cdGdyZWVuOiBnZXRzZXQoJ3JnYicsIDEsIG1heGZuKDI1NSkpLFxuXHRibHVlOiBnZXRzZXQoJ3JnYicsIDIsIG1heGZuKDI1NSkpLFxuXG5cdGh1ZTogZ2V0c2V0KFsnaHNsJywgJ2hzdicsICdoc2wnLCAnaHdiJywgJ2hjZyddLCAwLCB2YWx1ZSA9PiAoKHZhbHVlICUgMzYwKSArIDM2MCkgJSAzNjApLFxuXG5cdHNhdHVyYXRpb25sOiBnZXRzZXQoJ2hzbCcsIDEsIG1heGZuKDEwMCkpLFxuXHRsaWdodG5lc3M6IGdldHNldCgnaHNsJywgMiwgbWF4Zm4oMTAwKSksXG5cblx0c2F0dXJhdGlvbnY6IGdldHNldCgnaHN2JywgMSwgbWF4Zm4oMTAwKSksXG5cdHZhbHVlOiBnZXRzZXQoJ2hzdicsIDIsIG1heGZuKDEwMCkpLFxuXG5cdGNocm9tYTogZ2V0c2V0KCdoY2cnLCAxLCBtYXhmbigxMDApKSxcblx0Z3JheTogZ2V0c2V0KCdoY2cnLCAyLCBtYXhmbigxMDApKSxcblxuXHR3aGl0ZTogZ2V0c2V0KCdod2InLCAxLCBtYXhmbigxMDApKSxcblx0d2JsYWNrOiBnZXRzZXQoJ2h3YicsIDIsIG1heGZuKDEwMCkpLFxuXG5cdGN5YW46IGdldHNldCgnY215aycsIDAsIG1heGZuKDEwMCkpLFxuXHRtYWdlbnRhOiBnZXRzZXQoJ2NteWsnLCAxLCBtYXhmbigxMDApKSxcblx0eWVsbG93OiBnZXRzZXQoJ2NteWsnLCAyLCBtYXhmbigxMDApKSxcblx0YmxhY2s6IGdldHNldCgnY215aycsIDMsIG1heGZuKDEwMCkpLFxuXG5cdHg6IGdldHNldCgneHl6JywgMCwgbWF4Zm4oOTUuMDQ3KSksXG5cdHk6IGdldHNldCgneHl6JywgMSwgbWF4Zm4oMTAwKSksXG5cdHo6IGdldHNldCgneHl6JywgMiwgbWF4Zm4oMTA4LjgzMykpLFxuXG5cdGw6IGdldHNldCgnbGFiJywgMCwgbWF4Zm4oMTAwKSksXG5cdGE6IGdldHNldCgnbGFiJywgMSksXG5cdGI6IGdldHNldCgnbGFiJywgMiksXG5cblx0a2V5d29yZCh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29udmVydFt0aGlzLm1vZGVsXS5rZXl3b3JkKHRoaXMuY29sb3IpO1xuXHR9LFxuXG5cdGhleCh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHZhbHVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29sb3JTdHJpbmcudG8uaGV4KHRoaXMucmdiKCkucm91bmQoKS5jb2xvcik7XG5cdH0sXG5cblx0aGV4YSh2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHZhbHVlKTtcblx0XHR9XG5cblx0XHRjb25zdCByZ2JBcnJheSA9IHRoaXMucmdiKCkucm91bmQoKS5jb2xvcjtcblxuXHRcdGxldCBhbHBoYUhleCA9IE1hdGgucm91bmQodGhpcy52YWxwaGEgKiAyNTUpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRcdGlmIChhbHBoYUhleC5sZW5ndGggPT09IDEpIHtcblx0XHRcdGFscGhhSGV4ID0gJzAnICsgYWxwaGFIZXg7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnRvLmhleChyZ2JBcnJheSkgKyBhbHBoYUhleDtcblx0fSxcblxuXHRyZ2JOdW1iZXIoKSB7XG5cdFx0Y29uc3QgcmdiID0gdGhpcy5yZ2IoKS5jb2xvcjtcblx0XHRyZXR1cm4gKChyZ2JbMF0gJiAweEZGKSA8PCAxNikgfCAoKHJnYlsxXSAmIDB4RkYpIDw8IDgpIHwgKHJnYlsyXSAmIDB4RkYpO1xuXHR9LFxuXG5cdGx1bWlub3NpdHkoKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNyZWxhdGl2ZWx1bWluYW5jZWRlZlxuXHRcdGNvbnN0IHJnYiA9IHRoaXMucmdiKCkuY29sb3I7XG5cblx0XHRjb25zdCBsdW0gPSBbXTtcblx0XHRmb3IgKGNvbnN0IFtpLCBlbGVtZW50XSBvZiByZ2IuZW50cmllcygpKSB7XG5cdFx0XHRjb25zdCBjaGFuID0gZWxlbWVudCAvIDI1NTtcblx0XHRcdGx1bVtpXSA9IChjaGFuIDw9IDAuMDQwNDUpID8gY2hhbiAvIDEyLjkyIDogKChjaGFuICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcblx0XHR9XG5cblx0XHRyZXR1cm4gMC4yMTI2ICogbHVtWzBdICsgMC43MTUyICogbHVtWzFdICsgMC4wNzIyICogbHVtWzJdO1xuXHR9LFxuXG5cdGNvbnRyYXN0KGNvbG9yMikge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jY29udHJhc3QtcmF0aW9kZWZcblx0XHRjb25zdCBsdW0xID0gdGhpcy5sdW1pbm9zaXR5KCk7XG5cdFx0Y29uc3QgbHVtMiA9IGNvbG9yMi5sdW1pbm9zaXR5KCk7XG5cblx0XHRpZiAobHVtMSA+IGx1bTIpIHtcblx0XHRcdHJldHVybiAobHVtMSArIDAuMDUpIC8gKGx1bTIgKyAwLjA1KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKGx1bTIgKyAwLjA1KSAvIChsdW0xICsgMC4wNSk7XG5cdH0sXG5cblx0bGV2ZWwoY29sb3IyKSB7XG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL1dDQUcvI2NvbnRyYXN0LWVuaGFuY2VkXG5cdFx0Y29uc3QgY29udHJhc3RSYXRpbyA9IHRoaXMuY29udHJhc3QoY29sb3IyKTtcblx0XHRpZiAoY29udHJhc3RSYXRpbyA+PSA3KSB7XG5cdFx0XHRyZXR1cm4gJ0FBQSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChjb250cmFzdFJhdGlvID49IDQuNSkgPyAnQUEnIDogJyc7XG5cdH0sXG5cblx0aXNEYXJrKCkge1xuXHRcdC8vIFlJUSBlcXVhdGlvbiBmcm9tIGh0dHA6Ly8yNHdheXMub3JnLzIwMTAvY2FsY3VsYXRpbmctY29sb3ItY29udHJhc3Rcblx0XHRjb25zdCByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXHRcdGNvbnN0IHlpcSA9IChyZ2JbMF0gKiAyMTI2ICsgcmdiWzFdICogNzE1MiArIHJnYlsyXSAqIDcyMikgLyAxMDAwMDtcblx0XHRyZXR1cm4geWlxIDwgMTI4O1xuXHR9LFxuXG5cdGlzTGlnaHQoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmlzRGFyaygpO1xuXHR9LFxuXG5cdG5lZ2F0ZSgpIHtcblx0XHRjb25zdCByZ2IgPSB0aGlzLnJnYigpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2IuY29sb3JbaV0gPSAyNTUgLSByZ2IuY29sb3JbaV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJnYjtcblx0fSxcblxuXHRsaWdodGVuKHJhdGlvKSB7XG5cdFx0Y29uc3QgaHNsID0gdGhpcy5oc2woKTtcblx0XHRoc2wuY29sb3JbMl0gKz0gaHNsLmNvbG9yWzJdICogcmF0aW87XG5cdFx0cmV0dXJuIGhzbDtcblx0fSxcblxuXHRkYXJrZW4ocmF0aW8pIHtcblx0XHRjb25zdCBoc2wgPSB0aGlzLmhzbCgpO1xuXHRcdGhzbC5jb2xvclsyXSAtPSBoc2wuY29sb3JbMl0gKiByYXRpbztcblx0XHRyZXR1cm4gaHNsO1xuXHR9LFxuXG5cdHNhdHVyYXRlKHJhdGlvKSB7XG5cdFx0Y29uc3QgaHNsID0gdGhpcy5oc2woKTtcblx0XHRoc2wuY29sb3JbMV0gKz0gaHNsLmNvbG9yWzFdICogcmF0aW87XG5cdFx0cmV0dXJuIGhzbDtcblx0fSxcblxuXHRkZXNhdHVyYXRlKHJhdGlvKSB7XG5cdFx0Y29uc3QgaHNsID0gdGhpcy5oc2woKTtcblx0XHRoc2wuY29sb3JbMV0gLT0gaHNsLmNvbG9yWzFdICogcmF0aW87XG5cdFx0cmV0dXJuIGhzbDtcblx0fSxcblxuXHR3aGl0ZW4ocmF0aW8pIHtcblx0XHRjb25zdCBod2IgPSB0aGlzLmh3YigpO1xuXHRcdGh3Yi5jb2xvclsxXSArPSBod2IuY29sb3JbMV0gKiByYXRpbztcblx0XHRyZXR1cm4gaHdiO1xuXHR9LFxuXG5cdGJsYWNrZW4ocmF0aW8pIHtcblx0XHRjb25zdCBod2IgPSB0aGlzLmh3YigpO1xuXHRcdGh3Yi5jb2xvclsyXSArPSBod2IuY29sb3JbMl0gKiByYXRpbztcblx0XHRyZXR1cm4gaHdiO1xuXHR9LFxuXG5cdGdyYXlzY2FsZSgpIHtcblx0XHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYXlzY2FsZSNDb252ZXJ0aW5nX2NvbG9yX3RvX2dyYXlzY2FsZVxuXHRcdGNvbnN0IHJnYiA9IHRoaXMucmdiKCkuY29sb3I7XG5cdFx0Y29uc3QgdmFsdWUgPSByZ2JbMF0gKiAwLjMgKyByZ2JbMV0gKiAwLjU5ICsgcmdiWzJdICogMC4xMTtcblx0XHRyZXR1cm4gQ29sb3IucmdiKHZhbHVlLCB2YWx1ZSwgdmFsdWUpO1xuXHR9LFxuXG5cdGZhZGUocmF0aW8pIHtcblx0XHRyZXR1cm4gdGhpcy5hbHBoYSh0aGlzLnZhbHBoYSAtICh0aGlzLnZhbHBoYSAqIHJhdGlvKSk7XG5cdH0sXG5cblx0b3BhcXVlcihyYXRpbykge1xuXHRcdHJldHVybiB0aGlzLmFscGhhKHRoaXMudmFscGhhICsgKHRoaXMudmFscGhhICogcmF0aW8pKTtcblx0fSxcblxuXHRyb3RhdGUoZGVncmVlcykge1xuXHRcdGNvbnN0IGhzbCA9IHRoaXMuaHNsKCk7XG5cdFx0bGV0IGh1ZSA9IGhzbC5jb2xvclswXTtcblx0XHRodWUgPSAoaHVlICsgZGVncmVlcykgJSAzNjA7XG5cdFx0aHVlID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcblx0XHRoc2wuY29sb3JbMF0gPSBodWU7XG5cdFx0cmV0dXJuIGhzbDtcblx0fSxcblxuXHRtaXgobWl4aW5Db2xvciwgd2VpZ2h0KSB7XG5cdFx0Ly8gUG9ydGVkIGZyb20gc2FzcyBpbXBsZW1lbnRhdGlvbiBpbiBDXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3Nhc3MvbGlic2Fzcy9ibG9iLzBlNmI0YTI4NTAwOTIzNTZhYTNlY2UwN2M2YjI0OWYwMjIxY2FjZWQvZnVuY3Rpb25zLmNwcCNMMjA5XG5cdFx0aWYgKCFtaXhpbkNvbG9yIHx8ICFtaXhpbkNvbG9yLnJnYikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCB0byBcIm1peFwiIHdhcyBub3QgYSBDb2xvciBpbnN0YW5jZSwgYnV0IHJhdGhlciBhbiBpbnN0YW5jZSBvZiAnICsgdHlwZW9mIG1peGluQ29sb3IpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNvbG9yMSA9IG1peGluQ29sb3IucmdiKCk7XG5cdFx0Y29uc3QgY29sb3IyID0gdGhpcy5yZ2IoKTtcblx0XHRjb25zdCBwID0gd2VpZ2h0ID09PSB1bmRlZmluZWQgPyAwLjUgOiB3ZWlnaHQ7XG5cblx0XHRjb25zdCB3ID0gMiAqIHAgLSAxO1xuXHRcdGNvbnN0IGEgPSBjb2xvcjEuYWxwaGEoKSAtIGNvbG9yMi5hbHBoYSgpO1xuXG5cdFx0Y29uc3QgdzEgPSAoKCh3ICogYSA9PT0gLTEpID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDI7XG5cdFx0Y29uc3QgdzIgPSAxIC0gdzE7XG5cblx0XHRyZXR1cm4gQ29sb3IucmdiKFxuXHRcdFx0dzEgKiBjb2xvcjEucmVkKCkgKyB3MiAqIGNvbG9yMi5yZWQoKSxcblx0XHRcdHcxICogY29sb3IxLmdyZWVuKCkgKyB3MiAqIGNvbG9yMi5ncmVlbigpLFxuXHRcdFx0dzEgKiBjb2xvcjEuYmx1ZSgpICsgdzIgKiBjb2xvcjIuYmx1ZSgpLFxuXHRcdFx0Y29sb3IxLmFscGhhKCkgKiBwICsgY29sb3IyLmFscGhhKCkgKiAoMSAtIHApKTtcblx0fSxcbn07XG5cbi8vIE1vZGVsIGNvbnZlcnNpb24gbWV0aG9kcyBhbmQgc3RhdGljIGNvbnN0cnVjdG9yc1xuZm9yIChjb25zdCBtb2RlbCBvZiBPYmplY3Qua2V5cyhjb252ZXJ0KSkge1xuXHRpZiAoc2tpcHBlZE1vZGVscy5pbmNsdWRlcyhtb2RlbCkpIHtcblx0XHRjb250aW51ZTtcblx0fVxuXG5cdGNvbnN0IHtjaGFubmVsc30gPSBjb252ZXJ0W21vZGVsXTtcblxuXHQvLyBDb252ZXJzaW9uIG1ldGhvZHNcblx0Q29sb3IucHJvdG90eXBlW21vZGVsXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0aWYgKHRoaXMubW9kZWwgPT09IG1vZGVsKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHRoaXMpO1xuXHRcdH1cblxuXHRcdGlmIChhcmdzLmxlbmd0aCA+IDApIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IoYXJncywgbW9kZWwpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgQ29sb3IoWy4uLmFzc2VydEFycmF5KGNvbnZlcnRbdGhpcy5tb2RlbF1bbW9kZWxdLnJhdyh0aGlzLmNvbG9yKSksIHRoaXMudmFscGhhXSwgbW9kZWwpO1xuXHR9O1xuXG5cdC8vICdzdGF0aWMnIGNvbnN0cnVjdGlvbiBtZXRob2RzXG5cdENvbG9yW21vZGVsXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0bGV0IGNvbG9yID0gYXJnc1swXTtcblx0XHRpZiAodHlwZW9mIGNvbG9yID09PSAnbnVtYmVyJykge1xuXHRcdFx0Y29sb3IgPSB6ZXJvQXJyYXkoYXJncywgY2hhbm5lbHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgQ29sb3IoY29sb3IsIG1vZGVsKTtcblx0fTtcbn1cblxuZnVuY3Rpb24gcm91bmRUbyhudW1iZXIsIHBsYWNlcykge1xuXHRyZXR1cm4gTnVtYmVyKG51bWJlci50b0ZpeGVkKHBsYWNlcykpO1xufVxuXG5mdW5jdGlvbiByb3VuZFRvUGxhY2UocGxhY2VzKSB7XG5cdHJldHVybiBmdW5jdGlvbiAobnVtYmVyKSB7XG5cdFx0cmV0dXJuIHJvdW5kVG8obnVtYmVyLCBwbGFjZXMpO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBnZXRzZXQobW9kZWwsIGNoYW5uZWwsIG1vZGlmaWVyKSB7XG5cdG1vZGVsID0gQXJyYXkuaXNBcnJheShtb2RlbCkgPyBtb2RlbCA6IFttb2RlbF07XG5cblx0Zm9yIChjb25zdCBtIG9mIG1vZGVsKSB7XG5cdFx0KGxpbWl0ZXJzW21dIHx8IChsaW1pdGVyc1ttXSA9IFtdKSlbY2hhbm5lbF0gPSBtb2RpZmllcjtcblx0fVxuXG5cdG1vZGVsID0gbW9kZWxbMF07XG5cblx0cmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGxldCByZXN1bHQ7XG5cblx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKG1vZGlmaWVyKSB7XG5cdFx0XHRcdHZhbHVlID0gbW9kaWZpZXIodmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXN1bHQgPSB0aGlzW21vZGVsXSgpO1xuXHRcdFx0cmVzdWx0LmNvbG9yW2NoYW5uZWxdID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblxuXHRcdHJlc3VsdCA9IHRoaXNbbW9kZWxdKCkuY29sb3JbY2hhbm5lbF07XG5cdFx0aWYgKG1vZGlmaWVyKSB7XG5cdFx0XHRyZXN1bHQgPSBtb2RpZmllcihyZXN1bHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG59XG5cbmZ1bmN0aW9uIG1heGZuKG1heCkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKHYpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCB2KSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFycmF5KHZhbHVlKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cblxuZnVuY3Rpb24gemVyb0FycmF5KGFycmF5LCBsZW5ndGgpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgYXJyYXlbaV0gIT09ICdudW1iZXInKSB7XG5cdFx0XHRhcnJheVtpXSA9IDA7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuIl0sIm5hbWVzIjpbImNvbG9yU3RyaW5nIiwicmVxdWlyZSIsImNvbnZlcnQiLCJza2lwcGVkTW9kZWxzIiwiaGFzaGVkTW9kZWxLZXlzIiwibW9kZWwiLCJPYmplY3QiLCJrZXlzIiwibGFiZWxzIiwic29ydCIsImpvaW4iLCJsaW1pdGVycyIsIkNvbG9yIiwib2JqZWN0IiwiRXJyb3IiLCJpIiwiY2hhbm5lbHMiLCJjb2xvciIsInZhbHBoYSIsInJlc3VsdCIsImdldCIsInZhbHVlIiwic2xpY2UiLCJsZW5ndGgiLCJuZXdBcnJheSIsIkFycmF5IiwicHJvdG90eXBlIiwiY2FsbCIsInplcm9BcnJheSIsInNwbGljZSIsImluZGV4T2YiLCJhbHBoYSIsImhhc2hlZEtleXMiLCJKU09OIiwic3RyaW5naWZ5IiwicHVzaCIsImxpbWl0IiwiTWF0aCIsIm1heCIsIm1pbiIsImZyZWV6ZSIsInRvU3RyaW5nIiwic3RyaW5nIiwidG9KU09OIiwicGxhY2VzIiwic2VsZiIsInRvIiwicmdiIiwicm91bmQiLCJhcmdzIiwicGVyY2VudFN0cmluZyIsInBlcmNlbnQiLCJhcnJheSIsInVuaXRBcnJheSIsInVuaXRPYmplY3QiLCJyIiwiZyIsImIiLCJtYXAiLCJyb3VuZFRvUGxhY2UiLCJ1bmRlZmluZWQiLCJyZWQiLCJnZXRzZXQiLCJtYXhmbiIsImdyZWVuIiwiYmx1ZSIsImh1ZSIsInNhdHVyYXRpb25sIiwibGlnaHRuZXNzIiwic2F0dXJhdGlvbnYiLCJjaHJvbWEiLCJncmF5Iiwid2hpdGUiLCJ3YmxhY2siLCJjeWFuIiwibWFnZW50YSIsInllbGxvdyIsImJsYWNrIiwieCIsInkiLCJ6IiwibCIsImEiLCJrZXl3b3JkIiwiaGV4IiwiaGV4YSIsInJnYkFycmF5IiwiYWxwaGFIZXgiLCJ0b1VwcGVyQ2FzZSIsInJnYk51bWJlciIsImx1bWlub3NpdHkiLCJsdW0iLCJlbGVtZW50IiwiZW50cmllcyIsImNoYW4iLCJjb250cmFzdCIsImNvbG9yMiIsImx1bTEiLCJsdW0yIiwibGV2ZWwiLCJjb250cmFzdFJhdGlvIiwiaXNEYXJrIiwieWlxIiwiaXNMaWdodCIsIm5lZ2F0ZSIsImxpZ2h0ZW4iLCJyYXRpbyIsImhzbCIsImRhcmtlbiIsInNhdHVyYXRlIiwiZGVzYXR1cmF0ZSIsIndoaXRlbiIsImh3YiIsImJsYWNrZW4iLCJncmF5c2NhbGUiLCJmYWRlIiwib3BhcXVlciIsInJvdGF0ZSIsImRlZ3JlZXMiLCJtaXgiLCJtaXhpbkNvbG9yIiwid2VpZ2h0IiwiY29sb3IxIiwicCIsInciLCJ3MSIsIncyIiwiaW5jbHVkZXMiLCJhc3NlcnRBcnJheSIsInJhdyIsInJvdW5kVG8iLCJudW1iZXIiLCJOdW1iZXIiLCJ0b0ZpeGVkIiwiY2hhbm5lbCIsIm1vZGlmaWVyIiwiaXNBcnJheSIsIm0iLCJ2IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/color/index.js\n");

/***/ })

};
;